/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard_Transient.hxx>
#include <Standard_TypeDef.hxx>
#include <Standard_Handle.hxx>
#include <Message_Messenger.hxx>
#include <Transfer_ActorOfProcessForTransient.hxx>
#include <Transfer_Binder.hxx>
#include <Message_Msg.hxx>
#include <Interface_Check.hxx>
#include <Standard_Type.hxx>
#include <Transfer_IteratorOfProcessForTransient.hxx>
#include <Interface_CheckIterator.hxx>
#include <Message_ProgressIndicator.hxx>
#include <Transfer_ProcessForTransient.hxx>
#include <TColStd_IndexedMapOfInteger.hxx>
#include <Transfer_TransferMapOfProcessForTransient.hxx>

void bind_Transfer_ProcessForTransient(py::module &mod){

py::class_<Transfer_ProcessForTransient, opencascade::handle<Transfer_ProcessForTransient>, Standard_Transient> cls_Transfer_ProcessForTransient(mod, "Transfer_ProcessForTransient", "Manages Transfer of Transient Objects. Produces also ActorOfTransientProcess (deferred class), IteratorOfTransientProcess (for Results), TransferMapOfTransientProcess (internally used) Normally uses as TransientProcess, which adds some specifics");

// Constructors
cls_Transfer_ProcessForTransient.def(py::init<>());
cls_Transfer_ProcessForTransient.def(py::init<const Standard_Integer>(), py::arg("nb"));
cls_Transfer_ProcessForTransient.def(py::init<const opencascade::handle<Message_Messenger> &>(), py::arg("printer"));
cls_Transfer_ProcessForTransient.def(py::init<const opencascade::handle<Message_Messenger> &, const Standard_Integer>(), py::arg("printer"), py::arg("nb"));

// Fields

// Methods
cls_Transfer_ProcessForTransient.def("Clear", (void (Transfer_ProcessForTransient::*)()) &Transfer_ProcessForTransient::Clear, "Resets a TransferProcess as ready for a completely new work. Clears general data (roots) and the Map");
cls_Transfer_ProcessForTransient.def("Clean", (void (Transfer_ProcessForTransient::*)()) &Transfer_ProcessForTransient::Clean, "Rebuilds the Map and the roots to really remove Unbound items Because Unbind keeps the entity in place, even if not bound Hence, working by checking new items is meaningless if a formerly unbound item is rebound");
cls_Transfer_ProcessForTransient.def("Resize", (void (Transfer_ProcessForTransient::*)(const Standard_Integer)) &Transfer_ProcessForTransient::Resize, "Resizes the Map as required (if a new reliable value has been determined). Acts only if <nb> is greater than actual NbMapped", py::arg("nb"));
cls_Transfer_ProcessForTransient.def("SetActor", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Transfer_ActorOfProcessForTransient> &)) &Transfer_ProcessForTransient::SetActor, "Defines an Actor, which is used for automatic Transfer If already defined, the new Actor is cumulated (see SetNext from Actor)", py::arg("actor"));
cls_Transfer_ProcessForTransient.def("Actor", (opencascade::handle<Transfer_ActorOfProcessForTransient> (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::Actor, "Returns the defined Actor. Returns a Null Handle if not set.");
cls_Transfer_ProcessForTransient.def("Find", (opencascade::handle<Transfer_Binder> (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::Find, "Returns the Binder which is linked with a starting Object It can either bring a Result (Transfer done) or none (for a pre-binding). If no Binder is linked with <start>, returns a Null Handle Considers a category number, by default 0", py::arg("start"));
cls_Transfer_ProcessForTransient.def("IsBound", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::IsBound, "Returns True if a Result (whatever its form) is Bound with a starting Object. I.e., if a Binder with a Result set, is linked with it Considers a category number, by default 0", py::arg("start"));
cls_Transfer_ProcessForTransient.def("IsAlreadyUsed", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::IsAlreadyUsed, "Returns True if the result of the transfer of an object is already used in other ones. If it is, Rebind cannot change it. Considers a category number, by default 0", py::arg("start"));
cls_Transfer_ProcessForTransient.def("Bind", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Transfer_Binder> &)) &Transfer_ProcessForTransient::Bind, "Creates a Link a starting Object with a Binder. This Binder can either bring a Result (effective Binding) or none (it can be set later : pre-binding). Considers a category number, by default 0", py::arg("start"), py::arg("binder"));
cls_Transfer_ProcessForTransient.def("Rebind", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Transfer_Binder> &)) &Transfer_ProcessForTransient::Rebind, "Changes the Binder linked with a starting Object for its unitary transfer. This it can be useful when the exact form of the result is known once the transfer is widely engaged. This can be done only on first transfer. Considers a category number, by default 0", py::arg("start"), py::arg("binder"));
cls_Transfer_ProcessForTransient.def("Unbind", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::Unbind, "Removes the Binder linked with a starting object If this Binder brings a non-empty Check, it is replaced by a VoidBinder. Also removes from the list of Roots as required. Returns True if done, False if <start> was not bound Considers a category number, by default 0", py::arg("start"));
cls_Transfer_ProcessForTransient.def("FindElseBind", (opencascade::handle<Transfer_Binder> (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::FindElseBind, "Returns a Binder for a starting entity, as follows : Tries to Find the already bound one If none found, creates a VoidBinder and Binds it", py::arg("start"));
cls_Transfer_ProcessForTransient.def("SetMessenger", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Message_Messenger> &)) &Transfer_ProcessForTransient::SetMessenger, "Sets Messenger used for outputting messages.", py::arg("messenger"));
cls_Transfer_ProcessForTransient.def("Messenger", (opencascade::handle<Message_Messenger> (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::Messenger, "Returns Messenger used for outputting messages. The returned object is guaranteed to be non-null; default is Message::Messenger().");
cls_Transfer_ProcessForTransient.def("SetTraceLevel", (void (Transfer_ProcessForTransient::*)(const Standard_Integer)) &Transfer_ProcessForTransient::SetTraceLevel, "Sets trace level used for outputting messages: <trace> = 0 : no trace at all <trace> = 1 : handled exceptions and calls to AddError <trace> = 2 : also calls to AddWarning <trace> = 3 : also traces new Roots (uses method ErrorTrace). Default is 1 : Errors traced", py::arg("tracelev"));
cls_Transfer_ProcessForTransient.def("TraceLevel", (Standard_Integer (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::TraceLevel, "Returns trace level used for outputting messages.");
cls_Transfer_ProcessForTransient.def("SendFail", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Message_Msg &)) &Transfer_ProcessForTransient::SendFail, "New name for AddFail (Msg)", py::arg("start"), py::arg("amsg"));
cls_Transfer_ProcessForTransient.def("SendWarning", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Message_Msg &)) &Transfer_ProcessForTransient::SendWarning, "New name for AddWarning (Msg)", py::arg("start"), py::arg("amsg"));
cls_Transfer_ProcessForTransient.def("SendMsg", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Message_Msg &)) &Transfer_ProcessForTransient::SendMsg, "Adds an information message Trace is filled if trace level is at least 3", py::arg("start"), py::arg("amsg"));
cls_Transfer_ProcessForTransient.def("AddFail", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0, const Standard_CString a1) -> void { return self.AddFail(a0, a1); });
cls_Transfer_ProcessForTransient.def("AddFail", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_CString, const Standard_CString)) &Transfer_ProcessForTransient::AddFail, "Adds an Error message to a starting entity (to the check of its Binder of category 0, as a Fail)", py::arg("start"), py::arg("mess"), py::arg("orig"));
cls_Transfer_ProcessForTransient.def("AddError", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0, const Standard_CString a1) -> void { return self.AddError(a0, a1); });
cls_Transfer_ProcessForTransient.def("AddError", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_CString, const Standard_CString)) &Transfer_ProcessForTransient::AddError, "(other name of AddFail, maintained for compatibility)", py::arg("start"), py::arg("mess"), py::arg("orig"));
cls_Transfer_ProcessForTransient.def("AddFail", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Message_Msg &)) &Transfer_ProcessForTransient::AddFail, "Adds an Error Message to a starting entity from the definition of a Msg (Original+Value)", py::arg("start"), py::arg("amsg"));
cls_Transfer_ProcessForTransient.def("AddWarning", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0, const Standard_CString a1) -> void { return self.AddWarning(a0, a1); });
cls_Transfer_ProcessForTransient.def("AddWarning", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_CString, const Standard_CString)) &Transfer_ProcessForTransient::AddWarning, "Adds a Warning message to a starting entity (to the check of its Binder of category 0)", py::arg("start"), py::arg("mess"), py::arg("orig"));
cls_Transfer_ProcessForTransient.def("AddWarning", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Message_Msg &)) &Transfer_ProcessForTransient::AddWarning, "Adds a Warning Message to a starting entity from the definition of a Msg (Original+Value)", py::arg("start"), py::arg("amsg"));
cls_Transfer_ProcessForTransient.def("Mend", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0) -> void { return self.Mend(a0); });
cls_Transfer_ProcessForTransient.def("Mend", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_CString)) &Transfer_ProcessForTransient::Mend, "None", py::arg("start"), py::arg("pref"));
cls_Transfer_ProcessForTransient.def("Check", (opencascade::handle<Interface_Check> (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::Check, "Returns the Check attached to a starting entity. If <start> is unknown, returns an empty Check Adds a case name to a starting entity Adds a case value to a starting entity Returns the complete case list for an entity. Null Handle if empty In the list of mapped items (between 1 and NbMapped), searches for the first item which follows <num0>(not included) and which has an attribute named <name> Attributes are brought by Binders Hence, allows such an iteration", py::arg("start"));
cls_Transfer_ProcessForTransient.def("BindTransient", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::BindTransient, "Binds a starting object with a Transient Result. Uses a SimpleBinderOfTransient to work. If there is already one but with no Result set, sets its Result. Considers a category number, by default 0", py::arg("start"), py::arg("res"));
cls_Transfer_ProcessForTransient.def("FindTransient", (const opencascade::handle<Standard_Transient> & (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::FindTransient, "Returns the Result of the Transfer of an object <start> as a Transient Result. Returns a Null Handle if there is no Transient Result Considers a category number, by default 0 Warning : Supposes that Binding is done with a SimpleBinderOfTransient", py::arg("start"));
cls_Transfer_ProcessForTransient.def("BindMultiple", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::BindMultiple, "Prepares an object <start> to be bound with several results. If no Binder is yet attached to <obj>, a MultipleBinder is created, empty. If a Binder is already set, it must accept Multiple Binding. Considers a category number, by default 0", py::arg("start"));
cls_Transfer_ProcessForTransient.def("AddMultiple", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::AddMultiple, "Adds an item to a list of results bound to a starting object. Considers a category number, by default 0, for all results", py::arg("start"), py::arg("res"));
cls_Transfer_ProcessForTransient.def("FindTypedTransient", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Standard_Type> &, opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::FindTypedTransient, "Searches for a transient result attached to a starting object, according to its type, by criterium IsKind(atype)", py::arg("start"), py::arg("atype"), py::arg("val"));
cls_Transfer_ProcessForTransient.def("GetTypedTransient", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Transfer_Binder> &, const opencascade::handle<Standard_Type> &, opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::GetTypedTransient, "Searches for a transient result recorded in a Binder, whatever this Binder is recorded or not in <me>", py::arg("binder"), py::arg("atype"), py::arg("val"));
cls_Transfer_ProcessForTransient.def("NbMapped", (Standard_Integer (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::NbMapped, "Returns the maximum possible value for Map Index (no result can be bound with a value greater than it)");
cls_Transfer_ProcessForTransient.def("Mapped", (const opencascade::handle<Standard_Transient> & (Transfer_ProcessForTransient::*)(const Standard_Integer) const) &Transfer_ProcessForTransient::Mapped, "Returns the Starting Object bound to an Index,", py::arg("num"));
cls_Transfer_ProcessForTransient.def("MapIndex", (Standard_Integer (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::MapIndex, "Returns the Index value bound to a Starting Object, 0 if none", py::arg("start"));
cls_Transfer_ProcessForTransient.def("MapItem", (opencascade::handle<Transfer_Binder> (Transfer_ProcessForTransient::*)(const Standard_Integer) const) &Transfer_ProcessForTransient::MapItem, "Returns the Binder bound to an Index Considers a category number, by default 0", py::arg("num"));
cls_Transfer_ProcessForTransient.def("SetRoot", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::SetRoot, "Declares <obj> (and its Result) as Root. This status will be later exploited by RootResult, see below (Result can be produced at any time)", py::arg("start"));
cls_Transfer_ProcessForTransient.def("SetRootManagement", (void (Transfer_ProcessForTransient::*)(const Standard_Boolean)) &Transfer_ProcessForTransient::SetRootManagement, "Enable (if <stat> True) or Disables (if <stat> False) Root Management. If it is set, Transfers are considered as stacked (a first Transfer commands other Transfers, and so on) and the Transfers commanded by an external caller are 'Root'. Remark : SetRoot can be called whatever this status, on every object. Default is set to True.", py::arg("stat"));
cls_Transfer_ProcessForTransient.def("NbRoots", (Standard_Integer (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::NbRoots, "Returns the count of recorded Roots");
cls_Transfer_ProcessForTransient.def("Root", (const opencascade::handle<Standard_Transient> & (Transfer_ProcessForTransient::*)(const Standard_Integer) const) &Transfer_ProcessForTransient::Root, "Returns a Root Entity given its number in the list (1-NbRoots)", py::arg("num"));
cls_Transfer_ProcessForTransient.def("RootItem", (opencascade::handle<Transfer_Binder> (Transfer_ProcessForTransient::*)(const Standard_Integer) const) &Transfer_ProcessForTransient::RootItem, "Returns the Binder bound with a Root Entity given its number Considers a category number, by default 0", py::arg("num"));
cls_Transfer_ProcessForTransient.def("RootIndex", (Standard_Integer (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::RootIndex, "Returns the index in the list of roots for a starting item, or 0 if it is not recorded as a root", py::arg("start"));
cls_Transfer_ProcessForTransient.def("NestingLevel", (Standard_Integer (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::NestingLevel, "Returns Nesting Level of Transfers (managed by methods TranscriptWith & Co). Starts to zero. If no automatic Transfer is used, it remains to zero. Zero means Root Level.");
cls_Transfer_ProcessForTransient.def("ResetNestingLevel", (void (Transfer_ProcessForTransient::*)()) &Transfer_ProcessForTransient::ResetNestingLevel, "Resets Nesting Level of Transfers to Zero (Root Level), whatever its current value.");
cls_Transfer_ProcessForTransient.def("Recognize", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::Recognize, "Tells if <start> has been recognized as good candidate for Transfer. i.e. queries the Actor and its Nexts", py::arg("start"));
cls_Transfer_ProcessForTransient.def("Transferring", (opencascade::handle<Transfer_Binder> (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::Transferring, "Performs the Transfer of a Starting Object, by calling the method TransferProduct (see below). Mapping and Roots are managed : nothing is done if a Result is already Bound, an exception is raised in case of error.", py::arg("start"));
cls_Transfer_ProcessForTransient.def("Transfer", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &)) &Transfer_ProcessForTransient::Transfer, "Same as Transferring but does not return the Binder. Simply returns True in case of success (for user call)", py::arg("start"));
cls_Transfer_ProcessForTransient.def("SetErrorHandle", (void (Transfer_ProcessForTransient::*)(const Standard_Boolean)) &Transfer_ProcessForTransient::SetErrorHandle, "Allows controls if exceptions will be handled Transfer Operations <err> False : they are not handled with try {} catch {} <err> True : they are Default is False: no handling performed", py::arg("err"));
cls_Transfer_ProcessForTransient.def("ErrorHandle", (Standard_Boolean (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::ErrorHandle, "Returns error handling flag");
cls_Transfer_ProcessForTransient.def("StartTrace", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Transfer_Binder> &, const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Integer) const) &Transfer_ProcessForTransient::StartTrace, "Method called when trace is asked Calls PrintTrace to display information relevant for starting objects (which can be redefined) <level> is Nesting Level of Transfer (0 = root) <mode> controls the way the trace is done : 0 neutral, 1 for Error, 2 for Warning message, 3 for new Root", py::arg("binder"), py::arg("start"), py::arg("level"), py::arg("mode"));
cls_Transfer_ProcessForTransient.def("PrintTrace", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Message_Messenger> &) const) &Transfer_ProcessForTransient::PrintTrace, "Prints a short information on a starting object. By default prints its Dynamic Type. Can be redefined", py::arg("start"), py::arg("S"));
cls_Transfer_ProcessForTransient.def("IsLooping", (Standard_Boolean (Transfer_ProcessForTransient::*)(const Standard_Integer) const) &Transfer_ProcessForTransient::IsLooping, "Returns True if we are surely in a DeadLoop. Evaluation is not exact, it is a 'majorant' which must be computed fast. This 'majorant' is : <alevel> greater than NbMapped.", py::arg("alevel"));
cls_Transfer_ProcessForTransient.def("RootResult", [](Transfer_ProcessForTransient &self) -> Transfer_IteratorOfProcessForTransient { return self.RootResult(); });
cls_Transfer_ProcessForTransient.def("RootResult", (Transfer_IteratorOfProcessForTransient (Transfer_ProcessForTransient::*)(const Standard_Boolean) const) &Transfer_ProcessForTransient::RootResult, "Returns, as an iterator, the log of root transfer, i.e. the created objects and Binders bound to starting roots If withstart is given True, Starting Objets are also returned", py::arg("withstart"));
cls_Transfer_ProcessForTransient.def("CompleteResult", [](Transfer_ProcessForTransient &self) -> Transfer_IteratorOfProcessForTransient { return self.CompleteResult(); });
cls_Transfer_ProcessForTransient.def("CompleteResult", (Transfer_IteratorOfProcessForTransient (Transfer_ProcessForTransient::*)(const Standard_Boolean) const) &Transfer_ProcessForTransient::CompleteResult, "Returns, as an Iterator, the entire log of transfer (list of created objects and Binders which can bring errors) If withstart is given True, Starting Objets are also returned", py::arg("withstart"));
cls_Transfer_ProcessForTransient.def("AbnormalResult", (Transfer_IteratorOfProcessForTransient (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::AbnormalResult, "Returns Binders which are neither 'Done' nor 'Initial', that is Error,Loop or Run (abnormal states at end of Transfer) Starting Objects are given in correspondance in the iterator");
cls_Transfer_ProcessForTransient.def("CheckList", (Interface_CheckIterator (Transfer_ProcessForTransient::*)(const Standard_Boolean) const) &Transfer_ProcessForTransient::CheckList, "Returns a CheckList as a list of Check : each one is for a starting entity which have either check (warning or fail) messages are attached, or are in abnormal state : that case gives a specific message If <erronly> is True, checks with Warnings only are ignored", py::arg("erronly"));
cls_Transfer_ProcessForTransient.def("ResultOne", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0, const Standard_Integer a1) -> Transfer_IteratorOfProcessForTransient { return self.ResultOne(a0, a1); });
cls_Transfer_ProcessForTransient.def("ResultOne", (Transfer_IteratorOfProcessForTransient (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Boolean) const) &Transfer_ProcessForTransient::ResultOne, "Returns, as an Iterator, the log of transfer for one object <level> = 0 : this object only and if <start> is a scope owner (else, <level> is ignored) : <level> = 1 : object plus its immediate scoped ones <level> = 2 : object plus all its scoped ones", py::arg("start"), py::arg("level"), py::arg("withstart"));
cls_Transfer_ProcessForTransient.def("CheckListOne", (Interface_CheckIterator (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Boolean) const) &Transfer_ProcessForTransient::CheckListOne, "Returns a CheckList for one starting object <level> interpreted as by ResultOne If <erronly> is True, checks with Warnings only are ignored", py::arg("start"), py::arg("level"), py::arg("erronly"));
cls_Transfer_ProcessForTransient.def("IsCheckListEmpty", (Standard_Boolean (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Boolean) const) &Transfer_ProcessForTransient::IsCheckListEmpty, "Returns True if no check message is attached to a starting object. <level> interpreted as by ResultOne If <erronly> is True, checks with Warnings only are ignored", py::arg("start"), py::arg("level"), py::arg("erronly"));
cls_Transfer_ProcessForTransient.def("RemoveResult", [](Transfer_ProcessForTransient &self, const opencascade::handle<Standard_Transient> & a0, const Standard_Integer a1) -> void { return self.RemoveResult(a0, a1); });
cls_Transfer_ProcessForTransient.def("RemoveResult", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Boolean)) &Transfer_ProcessForTransient::RemoveResult, "Removes Results attached to (== Unbinds) a given object and, according <level> : <level> = 0 : only it <level> = 1 : it plus its immediately owned sub-results(scope) <level> = 2 : it plus all its owned sub-results(scope)", py::arg("start"), py::arg("level"), py::arg("compute"));
cls_Transfer_ProcessForTransient.def("CheckNum", (Standard_Integer (Transfer_ProcessForTransient::*)(const opencascade::handle<Standard_Transient> &) const) &Transfer_ProcessForTransient::CheckNum, "Computes a number to be associated to a starting object in a check or a check-list By default, returns 0; can be redefined", py::arg("start"));
cls_Transfer_ProcessForTransient.def("SetProgress", (void (Transfer_ProcessForTransient::*)(const opencascade::handle<Message_ProgressIndicator> &)) &Transfer_ProcessForTransient::SetProgress, "Sets Progress indicator", py::arg("theProgress"));
cls_Transfer_ProcessForTransient.def("GetProgress", (opencascade::handle<Message_ProgressIndicator> (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::GetProgress, "Gets Progress indicator");
cls_Transfer_ProcessForTransient.def_static("get_type_name_", (const char * (*)()) &Transfer_ProcessForTransient::get_type_name, "None");
cls_Transfer_ProcessForTransient.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Transfer_ProcessForTransient::get_type_descriptor, "None");
cls_Transfer_ProcessForTransient.def("DynamicType", (const opencascade::handle<Standard_Type> & (Transfer_ProcessForTransient::*)() const) &Transfer_ProcessForTransient::DynamicType, "None");

// Enums

}