/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Geom2d_BoundedCurve.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <Standard_TypeDef.hxx>
#include <gp_Pnt2d.hxx>
#include <gp_Vec2d.hxx>
#include <GeomAbs_Shape.hxx>
#include <GeomAbs_BSplKnotDistribution.hxx>
#include <gp_Trsf2d.hxx>
#include <Standard_Handle.hxx>
#include <Geom2d_Geometry.hxx>
#include <Geom2d_BSplineCurve.hxx>
#include <Standard_Type.hxx>
#include <TColgp_HArray1OfPnt2d.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <TColStd_HArray1OfInteger.hxx>

void bind_Geom2d_BSplineCurve(py::module &mod){

py::class_<Geom2d_BSplineCurve, opencascade::handle<Geom2d_BSplineCurve>, Geom2d_BoundedCurve> cls_Geom2d_BSplineCurve(mod, "Geom2d_BSplineCurve", "Describes a BSpline curve. A BSpline curve can be: - uniform or non-uniform, - rational or non-rational, - periodic or non-periodic. A BSpline curve is defined by: - its degree; the degree for a Geom2d_BSplineCurve is limited to a value (25) which is defined and controlled by the system. This value is returned by the function MaxDegree; - its periodic or non-periodic nature; - a table of poles (also called control points), with their associated weights if the BSpline curve is rational. The poles of the curve are 'control points' used to deform the curve. If the curve is non-periodic, the first pole is the start point of the curve, and the last pole is the end point of the curve. The segment, which joins the first pole to the second pole, is the tangent to the curve at its start point, and the segment, which joins the last pole to the second-from-last pole, is the tangent to the curve at its end point. If the curve is periodic, these geometric properties are not verified. It is more difficult to give a geometric signification to the weights but they are useful for providing exact representations of the arcs of a circle or ellipse. Moreover, if the weights of all the poles are equal, the curve has a polynomial equation; it is therefore a non-rational curve. - a table of knots with their multiplicities. For a Geom2d_BSplineCurve, the table of knots is an increasing sequence of reals without repetition; the multiplicities define the repetition of the knots. A BSpline curve is a piecewise polynomial or rational curve. The knots are the parameters of junction points between two pieces. The multiplicity Mult(i) of the knot Knot(i) of the BSpline curve is related to the degree of continuity of the curve at the knot Knot(i), which is equal to Degree - Mult(i) where Degree is the degree of the BSpline curve. If the knots are regularly spaced (i.e. the difference between two consecutive knots is a constant), three specific and frequently used cases of knot distribution can be identified: - 'uniform' if all multiplicities are equal to 1, - 'quasi-uniform' if all multiplicities are equal to 1, except the first and the last knot which have a multiplicity of Degree + 1, where Degree is the degree of the BSpline curve, - 'Piecewise Bezier' if all multiplicities are equal to Degree except the first and last knot which have a multiplicity of Degree + 1, where Degree is the degree of the BSpline curve. A curve of this type is a concatenation of arcs of Bezier curves. If the BSpline curve is not periodic: - the bounds of the Poles and Weights tables are 1 and NbPoles, where NbPoles is the number of poles of the BSpline curve, - the bounds of the Knots and Multiplicities tables are 1 and NbKnots, where NbKnots is the number of knots of the BSpline curve. If the BSpline curve is periodic, and if there are k periodic knots and p periodic poles, the period is: period = Knot(k + 1) - Knot(1) and the poles and knots tables can be considered as infinite tables, such that: - Knot(i+k) = Knot(i) + period - Pole(i+p) = Pole(i) Note: data structures of a periodic BSpline curve are more complex than those of a non-periodic one. Warnings : In this class we consider that a weight value is zero if Weight <= Resolution from package gp. For two parametric values (or two knot values) U1, U2 we consider that U1 = U2 if Abs (U2 - U1) <= Epsilon (U1). For two weights values W1, W2 we consider that W1 = W2 if Abs (W2 - W1) <= Epsilon (W1). The method Epsilon is defined in the class Real from package Standard.");

// Constructors
cls_Geom2d_BSplineCurve.def(py::init<const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("Poles"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"));
cls_Geom2d_BSplineCurve.def(py::init<const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"), py::arg("Periodic"));
cls_Geom2d_BSplineCurve.def(py::init<const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"));
cls_Geom2d_BSplineCurve.def(py::init<const TColgp_Array1OfPnt2d &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"), py::arg("Periodic"));

// Fields

// Methods
cls_Geom2d_BSplineCurve.def("IncreaseDegree", (void (Geom2d_BSplineCurve::*)(const Standard_Integer)) &Geom2d_BSplineCurve::IncreaseDegree, "Increases the degree of this BSpline curve to Degree. As a result, the poles, weights and multiplicities tables are modified; the knots table is not changed. Nothing is done if Degree is less than or equal to the current degree. Exceptions Standard_ConstructionError if Degree is greater than Geom2d_BSplineCurve::MaxDegree().", py::arg("Degree"));
cls_Geom2d_BSplineCurve.def("IncreaseMultiplicity", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Integer)) &Geom2d_BSplineCurve::IncreaseMultiplicity, "Increases the multiplicity of the knot <Index> to <M>.", py::arg("Index"), py::arg("M"));
cls_Geom2d_BSplineCurve.def("IncreaseMultiplicity", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom2d_BSplineCurve::IncreaseMultiplicity, "Increases the multiplicities of the knots in [I1,I2] to <M>.", py::arg("I1"), py::arg("I2"), py::arg("M"));
cls_Geom2d_BSplineCurve.def("IncrementMultiplicity", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom2d_BSplineCurve::IncrementMultiplicity, "Increases by M the multiplicity of the knots of indexes I1 to I2 in the knots table of this BSpline curve. For each knot, the resulting multiplicity is limited to the degree of this curve. If M is negative, nothing is done. As a result, the poles and weights tables of this BSpline curve are modified. Warning It is forbidden to modify the multiplicity of the first or last knot of a non-periodic curve. Be careful as Geom2d does not protect against this. Exceptions Standard_OutOfRange if I1 or I2 is outside the bounds of the knots table.", py::arg("I1"), py::arg("I2"), py::arg("M"));
cls_Geom2d_BSplineCurve.def("InsertKnot", [](Geom2d_BSplineCurve &self, const Standard_Real a0) -> void { return self.InsertKnot(a0); });
cls_Geom2d_BSplineCurve.def("InsertKnot", [](Geom2d_BSplineCurve &self, const Standard_Real a0, const Standard_Integer a1) -> void { return self.InsertKnot(a0, a1); });
cls_Geom2d_BSplineCurve.def("InsertKnot", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Real)) &Geom2d_BSplineCurve::InsertKnot, "Inserts a knot value in the sequence of knots. If <U> is an existing knot the multiplicity is increased by <M>.", py::arg("U"), py::arg("M"), py::arg("ParametricTolerance"));
cls_Geom2d_BSplineCurve.def("InsertKnots", [](Geom2d_BSplineCurve &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1) -> void { return self.InsertKnots(a0, a1); });
cls_Geom2d_BSplineCurve.def("InsertKnots", [](Geom2d_BSplineCurve &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1, const Standard_Real a2) -> void { return self.InsertKnots(a0, a1, a2); });
cls_Geom2d_BSplineCurve.def("InsertKnots", (void (Geom2d_BSplineCurve::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &Geom2d_BSplineCurve::InsertKnots, "Inserts the values of the array Knots, with the respective multiplicities given by the array Mults, into the knots table of this BSpline curve. If a value of the array Knots is an existing knot, its multiplicity is: - increased by M, if Add is true, or - increased to M, if Add is false (default value). The tolerance criterion used for knot equality is the larger of the values ParametricTolerance (defaulted to 0.) and Standard_Real::Epsilon(U), where U is the current knot value. Warning - For a value of the array Knots which is less than the first parameter or greater than the last parameter of this BSpline curve, nothing is done. - For a value of the array Mults which is negative or null, nothing is done. - The multiplicity of a knot is limited to the degree of this BSpline curve.", py::arg("Knots"), py::arg("Mults"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom2d_BSplineCurve.def("RemoveKnot", (Standard_Boolean (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom2d_BSplineCurve::RemoveKnot, "Reduces the multiplicity of the knot of index Index to M. If M is equal to 0, the knot is removed. With a modification of this type, the array of poles is also modified. Two different algorithms are systematically used to compute the new poles of the curve. If, for each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is less than Tolerance, this ensures that the curve is not modified by more than Tolerance. Under these conditions, true is returned; otherwise, false is returned. A low tolerance is used to prevent modification of the curve. A high tolerance is used to 'smooth' the curve. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table.", py::arg("Index"), py::arg("M"), py::arg("Tolerance"));
cls_Geom2d_BSplineCurve.def("InsertPoleAfter", [](Geom2d_BSplineCurve &self, const Standard_Integer a0, const gp_Pnt2d & a1) -> void { return self.InsertPoleAfter(a0, a1); });
cls_Geom2d_BSplineCurve.def("InsertPoleAfter", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const gp_Pnt2d &, const Standard_Real)) &Geom2d_BSplineCurve::InsertPoleAfter, "The new pole is inserted after the pole of range Index. If the curve was non rational it can become rational.", py::arg("Index"), py::arg("P"), py::arg("Weight"));
cls_Geom2d_BSplineCurve.def("InsertPoleBefore", [](Geom2d_BSplineCurve &self, const Standard_Integer a0, const gp_Pnt2d & a1) -> void { return self.InsertPoleBefore(a0, a1); });
cls_Geom2d_BSplineCurve.def("InsertPoleBefore", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const gp_Pnt2d &, const Standard_Real)) &Geom2d_BSplineCurve::InsertPoleBefore, "The new pole is inserted before the pole of range Index. If the curve was non rational it can become rational.", py::arg("Index"), py::arg("P"), py::arg("Weight"));
cls_Geom2d_BSplineCurve.def("RemovePole", (void (Geom2d_BSplineCurve::*)(const Standard_Integer)) &Geom2d_BSplineCurve::RemovePole, "Removes the pole of range Index If the curve was rational it can become non rational.", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("Reverse", (void (Geom2d_BSplineCurve::*)()) &Geom2d_BSplineCurve::Reverse, "Reverses the orientation of this BSpline curve. As a result - the knots and poles tables are modified; - the start point of the initial curve becomes the end point of the reversed curve; - the end point of the initial curve becomes the start point of the reversed curve.");
cls_Geom2d_BSplineCurve.def("ReversedParameter", (Standard_Real (Geom2d_BSplineCurve::*)(const Standard_Real) const) &Geom2d_BSplineCurve::ReversedParameter, "Computes the parameter on the reversed curve for the point of parameter U on this BSpline curve. The returned value is: UFirst + ULast - U, where UFirst and ULast are the values of the first and last parameters of this BSpline curve.", py::arg("U"));
cls_Geom2d_BSplineCurve.def("Segment", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Real)) &Geom2d_BSplineCurve::Segment, "Modifies this BSpline curve by segmenting it between U1 and U2. Either of these values can be outside the bounds of the curve, but U2 must be greater than U1. All data structure tables of this BSpline curve are modified, but the knots located between U1 and U2 are retained. The degree of the curve is not modified. Warnings : Even if <me> is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the curve <me> or if the curve makes loop. After the segmentation the length of a curve can be null. - The segmentation of a periodic curve over an interval corresponding to its period generates a non-periodic curve with equivalent geometry. Exceptions Standard_DomainError if U2 is less than U1. raises if U2 < U1. Standard_DomainError if U2 - U1 exceeds the period for periodic curves. i.e. ((U2 - U1) - Period) > Precision::PConfusion().", py::arg("U1"), py::arg("U2"));
cls_Geom2d_BSplineCurve.def("SetKnot", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Real)) &Geom2d_BSplineCurve::SetKnot, "Modifies this BSpline curve by assigning the value K to the knot of index Index in the knots table. This is a relatively local modification because K must be such that: Knots(Index - 1) < K < Knots(Index + 1) Exceptions Standard_ConstructionError if: - K is not such that: Knots(Index - 1) < K < Knots(Index + 1) - M is greater than the degree of this BSpline curve or lower than the previous multiplicity of knot of index Index in the knots table. Standard_OutOfRange if Index is outside the bounds of the knots table.", py::arg("Index"), py::arg("K"));
cls_Geom2d_BSplineCurve.def("SetKnots", (void (Geom2d_BSplineCurve::*)(const TColStd_Array1OfReal &)) &Geom2d_BSplineCurve::SetKnots, "Modifies this BSpline curve by assigning the array K to its knots table. The multiplicity of the knots is not modified. Exceptions Standard_ConstructionError if the values in the array K are not in ascending order. Standard_OutOfRange if the bounds of the array K are not respectively 1 and the number of knots of this BSpline curve.", py::arg("K"));
cls_Geom2d_BSplineCurve.def("SetKnot", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Real, const Standard_Integer)) &Geom2d_BSplineCurve::SetKnot, "Modifies this BSpline curve by assigning the value K to the knot of index Index in the knots table. This is a relatively local modification because K must be such that: Knots(Index - 1) < K < Knots(Index + 1) The second syntax allows you also to increase the multiplicity of the knot to M (but it is not possible to decrease the multiplicity of the knot with this function). Exceptions Standard_ConstructionError if: - K is not such that: Knots(Index - 1) < K < Knots(Index + 1) - M is greater than the degree of this BSpline curve or lower than the previous multiplicity of knot of index Index in the knots table. Standard_OutOfRange if Index is outside the bounds of the knots table.", py::arg("Index"), py::arg("K"), py::arg("M"));
cls_Geom2d_BSplineCurve.def("PeriodicNormalization", [](Geom2d_BSplineCurve &self, Standard_Real & U){ self.PeriodicNormalization(U); return U; }, "Computes the parameter normalized within the 'first' period of this BSpline curve, if it is periodic: the returned value is in the range Param1 and Param1 + Period, where: - Param1 is the 'first parameter', and - Period the period of this BSpline curve. Note: If this curve is not periodic, U is not modified.", py::arg("U"));
cls_Geom2d_BSplineCurve.def("SetPeriodic", (void (Geom2d_BSplineCurve::*)()) &Geom2d_BSplineCurve::SetPeriodic, "Changes this BSpline curve into a periodic curve. To become periodic, the curve must first be closed. Next, the knot sequence must be periodic. For this, FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2, the indexes in the knots array of the knots corresponding to the first and last parameters of this BSpline curve. The period is therefore Knot(I2) - Knot(I1). Consequently, the knots and poles tables are modified. Exceptions Standard_ConstructionError if this BSpline curve is not closed.");
cls_Geom2d_BSplineCurve.def("SetOrigin", (void (Geom2d_BSplineCurve::*)(const Standard_Integer)) &Geom2d_BSplineCurve::SetOrigin, "Assigns the knot of index Index in the knots table as the origin of this periodic BSpline curve. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this curve is not periodic. Standard_DomainError if Index is outside the bounds of the knots table.", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("SetNotPeriodic", (void (Geom2d_BSplineCurve::*)()) &Geom2d_BSplineCurve::SetNotPeriodic, "Changes this BSpline curve into a non-periodic curve. If this curve is already non-periodic, it is not modified. Note that the poles and knots tables are modified. Warning If this curve is periodic, as the multiplicity of the first and last knots is not modified, and is not equal to Degree + 1, where Degree is the degree of this BSpline curve, the start and end points of the curve are not its first and last poles.");
cls_Geom2d_BSplineCurve.def("SetPole", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const gp_Pnt2d &)) &Geom2d_BSplineCurve::SetPole, "Modifies this BSpline curve by assigning P to the pole of index Index in the poles table. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table. Standard_ConstructionError if Weight is negative or null.", py::arg("Index"), py::arg("P"));
cls_Geom2d_BSplineCurve.def("SetPole", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const gp_Pnt2d &, const Standard_Real)) &Geom2d_BSplineCurve::SetPole, "Modifies this BSpline curve by assigning P to the pole of index Index in the poles table. The second syntax also allows you to modify the weight of the modified pole, which becomes Weight. In this case, if this BSpline curve is non-rational, it can become rational and vice versa. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table. Standard_ConstructionError if Weight is negative or null.", py::arg("Index"), py::arg("P"), py::arg("Weight"));
cls_Geom2d_BSplineCurve.def("SetWeight", (void (Geom2d_BSplineCurve::*)(const Standard_Integer, const Standard_Real)) &Geom2d_BSplineCurve::SetWeight, "Assigns the weight Weight to the pole of index Index of the poles table. If the curve was non rational it can become rational. If the curve was rational it can become non rational. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table. Standard_ConstructionError if Weight is negative or null.", py::arg("Index"), py::arg("Weight"));
cls_Geom2d_BSplineCurve.def("MovePoint", [](Geom2d_BSplineCurve &self, const Standard_Real U, const gp_Pnt2d & P, const Standard_Integer Index1, const Standard_Integer Index2, Standard_Integer & FirstModifiedPole, Standard_Integer & LastModifiedPole){ self.MovePoint(U, P, Index1, Index2, FirstModifiedPole, LastModifiedPole); return std::tuple<Standard_Integer &, Standard_Integer &>(FirstModifiedPole, LastModifiedPole); }, "Moves the point of parameter U of this BSpline curve to P. Index1 and Index2 are the indexes in the table of poles of this BSpline curve of the first and last poles designated to be moved. FirstModifiedPole and LastModifiedPole are the indexes of the first and last poles, which are effectively modified. In the event of incompatibility between Index1, Index2 and the value U: - no change is made to this BSpline curve, and - the FirstModifiedPole and LastModifiedPole are returned null. Exceptions Standard_OutOfRange if: - Index1 is greater than or equal to Index2, or - Index1 or Index2 is less than 1 or greater than the number of poles of this BSpline curve.", py::arg("U"), py::arg("P"), py::arg("Index1"), py::arg("Index2"), py::arg("FirstModifiedPole"), py::arg("LastModifiedPole"));
cls_Geom2d_BSplineCurve.def("MovePointAndTangent", [](Geom2d_BSplineCurve &self, const Standard_Real U, const gp_Pnt2d & P, const gp_Vec2d & Tangent, const Standard_Real Tolerance, const Standard_Integer StartingCondition, const Standard_Integer EndingCondition, Standard_Integer & ErrorStatus){ self.MovePointAndTangent(U, P, Tangent, Tolerance, StartingCondition, EndingCondition, ErrorStatus); return ErrorStatus; }, "Move a point with parameter U to P. and makes it tangent at U be Tangent. StartingCondition = -1 means first can move EndingCondition = -1 means last point can move StartingCondition = 0 means the first point cannot move EndingCondition = 0 means the last point cannot move StartingCondition = 1 means the first point and tangent cannot move EndingCondition = 1 means the last point and tangent cannot move and so forth ErrorStatus != 0 means that there are not enought degree of freedom with the constrain to deform the curve accordingly", py::arg("U"), py::arg("P"), py::arg("Tangent"), py::arg("Tolerance"), py::arg("StartingCondition"), py::arg("EndingCondition"), py::arg("ErrorStatus"));
cls_Geom2d_BSplineCurve.def("IsCN", (Standard_Boolean (Geom2d_BSplineCurve::*)(const Standard_Integer) const) &Geom2d_BSplineCurve::IsCN, "Returns true if the degree of continuity of this BSpline curve is at least N. A BSpline curve is at least GeomAbs_C0. Exceptions Standard_RangeError if N is negative.", py::arg("N"));
cls_Geom2d_BSplineCurve.def("IsG1", (Standard_Boolean (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Real, const Standard_Real) const) &Geom2d_BSplineCurve::IsG1, "Check if curve has at least G1 continuity in interval [theTf, theTl] Returns true if IsCN(1) or angle betweem 'left' and 'right' first derivatives at knots with C0 continuity is less then theAngTol only knots in interval [theTf, theTl] is checked", py::arg("theTf"), py::arg("theTl"), py::arg("theAngTol"));
cls_Geom2d_BSplineCurve.def("IsClosed", (Standard_Boolean (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::IsClosed, "Returns true if the distance between the first point and the last point of the curve is lower or equal to Resolution from package gp. Warnings : The first and the last point can be different from the first pole and the last pole of the curve.");
cls_Geom2d_BSplineCurve.def("IsPeriodic", (Standard_Boolean (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::IsPeriodic, "Returns True if the curve is periodic.");
cls_Geom2d_BSplineCurve.def("IsRational", (Standard_Boolean (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::IsRational, "Returns True if the weights are not identical. The tolerance criterion is Epsilon of the class Real.");
cls_Geom2d_BSplineCurve.def("Continuity", (GeomAbs_Shape (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Continuity, "Returns the global continuity of the curve : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Curve, C2 : continuity of the second derivative all along the Curve, C3 : continuity of the third derivative all along the Curve, CN : the order of continuity is infinite. For a B-spline curve of degree d if a knot Ui has a multiplicity p the B-spline curve is only Cd-p continuous at Ui. So the global continuity of the curve can't be greater than Cd-p where p is the maximum multiplicity of the interior Knots. In the interior of a knot span the curve is infinitely continuously differentiable.");
cls_Geom2d_BSplineCurve.def("Degree", (Standard_Integer (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Degree, "Returns the degree of this BSpline curve. In this class the degree of the basis normalized B-spline functions cannot be greater than 'MaxDegree' Computation of value and derivatives");
cls_Geom2d_BSplineCurve.def("D0", (void (Geom2d_BSplineCurve::*)(const Standard_Real, gp_Pnt2d &) const) &Geom2d_BSplineCurve::D0, "None", py::arg("U"), py::arg("P"));
cls_Geom2d_BSplineCurve.def("D1", (void (Geom2d_BSplineCurve::*)(const Standard_Real, gp_Pnt2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::D1, "Raised if the continuity of the curve is not C1.", py::arg("U"), py::arg("P"), py::arg("V1"));
cls_Geom2d_BSplineCurve.def("D2", (void (Geom2d_BSplineCurve::*)(const Standard_Real, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::D2, "Raised if the continuity of the curve is not C2.", py::arg("U"), py::arg("P"), py::arg("V1"), py::arg("V2"));
cls_Geom2d_BSplineCurve.def("D3", (void (Geom2d_BSplineCurve::*)(const Standard_Real, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::D3, "For this BSpline curve, computes - the point P of parameter U, or - the point P and one or more of the following values: - V1, the first derivative vector, - V2, the second derivative vector, - V3, the third derivative vector. Warning On a point where the continuity of the curve is not the one requested, these functions impact the part defined by the parameter with a value greater than U, i.e. the part of the curve to the 'right' of the singularity. Raises UndefinedDerivative if the continuity of the curve is not C3.", py::arg("U"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
cls_Geom2d_BSplineCurve.def("DN", (gp_Vec2d (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer) const) &Geom2d_BSplineCurve::DN, "For the point of parameter U of this BSpline curve, computes the vector corresponding to the Nth derivative. Warning On a point where the continuity of the curve is not the one requested, this function impacts the part defined by the parameter with a value greater than U, i.e. the part of the curve to the 'right' of the singularity. Raises UndefinedDerivative if the continuity of the curve is not CN. RangeError if N < 1. The following functions computes the point of parameter U and the derivatives at this point on the B-spline curve arc defined between the knot FromK1 and the knot ToK2. U can be out of bounds [Knot (FromK1), Knot (ToK2)] but for the computation we only use the definition of the curve between these two knots. This method is useful to compute local derivative, if the order of continuity of the whole curve is not greater enough. Inside the parametric domain Knot (FromK1), Knot (ToK2) the evaluations are the same as if we consider the whole definition of the curve. Of course the evaluations are different outside this parametric domain.", py::arg("U"), py::arg("N"));
cls_Geom2d_BSplineCurve.def("LocalValue", (gp_Pnt2d (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer) const) &Geom2d_BSplineCurve::LocalValue, "Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"));
cls_Geom2d_BSplineCurve.def("LocalD0", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt2d &) const) &Geom2d_BSplineCurve::LocalD0, "Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"));
cls_Geom2d_BSplineCurve.def("LocalD1", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::LocalD1, "Raised if the local continuity of the curve is not C1 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"));
cls_Geom2d_BSplineCurve.def("LocalD2", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::LocalD2, "Raised if the local continuity of the curve is not C2 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"), py::arg("V2"));
cls_Geom2d_BSplineCurve.def("LocalD3", (void (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt2d &, gp_Vec2d &, gp_Vec2d &, gp_Vec2d &) const) &Geom2d_BSplineCurve::LocalD3, "Raised if the local continuity of the curve is not C3 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
cls_Geom2d_BSplineCurve.def("LocalDN", (gp_Vec2d (Geom2d_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer) const) &Geom2d_BSplineCurve::LocalDN, "Raised if the local continuity of the curve is not CN between the knot K1 and the knot K2. Raised if FromK1 = ToK2. Raised if N < 1.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("N"));
cls_Geom2d_BSplineCurve.def("EndPoint", (gp_Pnt2d (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::EndPoint, "Returns the last point of the curve. Warnings : The last point of the curve is different from the last pole of the curve if the multiplicity of the last knot is lower than Degree.");
cls_Geom2d_BSplineCurve.def("FirstUKnotIndex", (Standard_Integer (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::FirstUKnotIndex, "For a B-spline curve the first parameter (which gives the start point of the curve) is a knot value but if the multiplicity of the first knot index is lower than Degree + 1 it is not the first knot of the curve. This method computes the index of the knot corresponding to the first parameter.");
cls_Geom2d_BSplineCurve.def("FirstParameter", (Standard_Real (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::FirstParameter, "Computes the parametric value of the start point of the curve. It is a knot value.");
cls_Geom2d_BSplineCurve.def("Knot", (Standard_Real (Geom2d_BSplineCurve::*)(const Standard_Integer) const) &Geom2d_BSplineCurve::Knot, "Returns the knot of range Index. When there is a knot with a multiplicity greater than 1 the knot is not repeated. The method Multiplicity can be used to get the multiplicity of the Knot. Raised if Index < 1 or Index > NbKnots", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("Knots", (void (Geom2d_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom2d_BSplineCurve::Knots, "returns the knot values of the B-spline curve;", py::arg("K"));
cls_Geom2d_BSplineCurve.def("Knots", (const TColStd_Array1OfReal & (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Knots, "returns the knot values of the B-spline curve;");
cls_Geom2d_BSplineCurve.def("KnotSequence", (void (Geom2d_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom2d_BSplineCurve::KnotSequence, "Returns the knots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}", py::arg("K"));
cls_Geom2d_BSplineCurve.def("KnotSequence", (const TColStd_Array1OfReal & (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::KnotSequence, "Returns the knots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}");
cls_Geom2d_BSplineCurve.def("KnotDistribution", (GeomAbs_BSplKnotDistribution (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::KnotDistribution, "Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot the BSpline Curve can be : - Uniform if all the knots are of multiplicity 1, - QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1, - PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree A piecewise Bezier with only two knots is a BezierCurve. else the curve is non uniform. The tolerance criterion is Epsilon from class Real.");
cls_Geom2d_BSplineCurve.def("LastUKnotIndex", (Standard_Integer (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::LastUKnotIndex, "For a BSpline curve the last parameter (which gives the end point of the curve) is a knot value but if the multiplicity of the last knot index is lower than Degree + 1 it is not the last knot of the curve. This method computes the index of the knot corresponding to the last parameter.");
cls_Geom2d_BSplineCurve.def("LastParameter", (Standard_Real (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::LastParameter, "Computes the parametric value of the end point of the curve. It is a knot value.");
cls_Geom2d_BSplineCurve.def("LocateU", [](Geom2d_BSplineCurve &self, const Standard_Real U, const Standard_Real ParametricTolerance, Standard_Integer & I1, Standard_Integer & I2, const Standard_Boolean WithKnotRepetition){ self.LocateU(U, ParametricTolerance, I1, I2, WithKnotRepetition); return std::tuple<Standard_Integer &, Standard_Integer &>(I1, I2); }, "Locates the parametric value U in the sequence of knots. If 'WithKnotRepetition' is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. Knots (I1) <= U <= Knots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 < 1 => U < Knots (1) - Abs(ParametricTolerance) . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)", py::arg("U"), py::arg("ParametricTolerance"), py::arg("I1"), py::arg("I2"), py::arg("WithKnotRepetition"));
cls_Geom2d_BSplineCurve.def("Multiplicity", (Standard_Integer (Geom2d_BSplineCurve::*)(const Standard_Integer) const) &Geom2d_BSplineCurve::Multiplicity, "Returns the multiplicity of the knots of range Index. Raised if Index < 1 or Index > NbKnots", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("Multiplicities", (void (Geom2d_BSplineCurve::*)(TColStd_Array1OfInteger &) const) &Geom2d_BSplineCurve::Multiplicities, "Returns the multiplicity of the knots of the curve.", py::arg("M"));
cls_Geom2d_BSplineCurve.def("Multiplicities", (const TColStd_Array1OfInteger & (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Multiplicities, "returns the multiplicity of the knots of the curve.");
cls_Geom2d_BSplineCurve.def("NbKnots", (Standard_Integer (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::NbKnots, "Returns the number of knots. This method returns the number of knot without repetition of multiple knots.");
cls_Geom2d_BSplineCurve.def("NbPoles", (Standard_Integer (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::NbPoles, "Returns the number of poles");
cls_Geom2d_BSplineCurve.def("Pole", (const gp_Pnt2d & (Geom2d_BSplineCurve::*)(const Standard_Integer) const) &Geom2d_BSplineCurve::Pole, "Returns the pole of range Index. Raised if Index < 1 or Index > NbPoles.", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("Poles", (void (Geom2d_BSplineCurve::*)(TColgp_Array1OfPnt2d &) const) &Geom2d_BSplineCurve::Poles, "Returns the poles of the B-spline curve;", py::arg("P"));
cls_Geom2d_BSplineCurve.def("Poles", (const TColgp_Array1OfPnt2d & (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Poles, "Returns the poles of the B-spline curve;");
cls_Geom2d_BSplineCurve.def("StartPoint", (gp_Pnt2d (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::StartPoint, "Returns the start point of the curve. Warnings : This point is different from the first pole of the curve if the multiplicity of the first knot is lower than Degree.");
cls_Geom2d_BSplineCurve.def("Weight", (Standard_Real (Geom2d_BSplineCurve::*)(const Standard_Integer) const) &Geom2d_BSplineCurve::Weight, "Returns the weight of the pole of range Index . Raised if Index < 1 or Index > NbPoles.", py::arg("Index"));
cls_Geom2d_BSplineCurve.def("Weights", (void (Geom2d_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom2d_BSplineCurve::Weights, "Returns the weights of the B-spline curve;", py::arg("W"));
cls_Geom2d_BSplineCurve.def("Weights", (const TColStd_Array1OfReal * (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Weights, "Returns the weights of the B-spline curve;");
cls_Geom2d_BSplineCurve.def("Transform", (void (Geom2d_BSplineCurve::*)(const gp_Trsf2d &)) &Geom2d_BSplineCurve::Transform, "Applies the transformation T to this BSpline curve.", py::arg("T"));
cls_Geom2d_BSplineCurve.def_static("MaxDegree_", (Standard_Integer (*)()) &Geom2d_BSplineCurve::MaxDegree, "Returns the value of the maximum degree of the normalized B-spline basis functions in this package.");
cls_Geom2d_BSplineCurve.def("Resolution", [](Geom2d_BSplineCurve &self, const Standard_Real ToleranceUV, Standard_Real & UTolerance){ self.Resolution(ToleranceUV, UTolerance); return UTolerance; }, "Computes for this BSpline curve the parametric tolerance UTolerance for a given tolerance Tolerance3D (relative to dimensions in the plane). If f(t) is the equation of this BSpline curve, UTolerance ensures that: | t1 - t0| < Utolerance ===> |f(t1) - f(t0)| < ToleranceUV", py::arg("ToleranceUV"), py::arg("UTolerance"));
cls_Geom2d_BSplineCurve.def("Copy", (opencascade::handle<Geom2d_Geometry> (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::Copy, "Creates a new object which is a copy of this BSpline curve.");
cls_Geom2d_BSplineCurve.def_static("get_type_name_", (const char * (*)()) &Geom2d_BSplineCurve::get_type_name, "None");
cls_Geom2d_BSplineCurve.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Geom2d_BSplineCurve::get_type_descriptor, "None");
cls_Geom2d_BSplineCurve.def("DynamicType", (const opencascade::handle<Standard_Type> & (Geom2d_BSplineCurve::*)() const) &Geom2d_BSplineCurve::DynamicType, "None");

// Enums

}