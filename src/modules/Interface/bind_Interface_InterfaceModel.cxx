/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard_Transient.hxx>
#include <Standard_Handle.hxx>
#include <Interface_Protocol.hxx>
#include <Interface_GTool.hxx>
#include <Standard_TypeDef.hxx>
#include <Standard_Type.hxx>
#include <Interface_DataState.hxx>
#include <Interface_ReportEntity.hxx>
#include <Interface_CheckIterator.hxx>
#include <Interface_Check.hxx>
#include <Interface_GeneralLib.hxx>
#include <Interface_EntityIterator.hxx>
#include <Interface_InterfaceModel.hxx>
#include <Message_Messenger.hxx>
#include <TCollection_HAsciiString.hxx>
#include <TColStd_HSequenceOfHAsciiString.hxx>
#include <TColStd_IndexedMapOfTransient.hxx>
#include <TColStd_DataMapOfIntegerTransient.hxx>

void bind_Interface_InterfaceModel(py::module &mod){

py::class_<Interface_InterfaceModel, opencascade::handle<Interface_InterfaceModel>, Standard_Transient> cls_Interface_InterfaceModel(mod, "Interface_InterfaceModel", "Defines an (Indexed) Set of data corresponding to a complete Transfer by a File Interface, i.e. File Header and Transient Entities (Objects) contained in a File. Contained Entities are identified in the Model by unique and consecutive Numbers.");

// Fields

// Methods
cls_Interface_InterfaceModel.def("Destroy", (void (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::Destroy, "Clears the list of entities (service WhenDelete)");
cls_Interface_InterfaceModel.def("SetProtocol", (void (Interface_InterfaceModel::*)(const opencascade::handle<Interface_Protocol> &)) &Interface_InterfaceModel::SetProtocol, "Sets a Protocol for this Model It is also set by a call to AddWithRefs with Protocol It is used for : DumpHeader (as required), ClearEntities ...", py::arg("proto"));
cls_Interface_InterfaceModel.def("Protocol", (opencascade::handle<Interface_Protocol> (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::Protocol, "Returns the Protocol which has been set by SetProtocol, or AddWithRefs with Protocol");
cls_Interface_InterfaceModel.def("SetGTool", (void (Interface_InterfaceModel::*)(const opencascade::handle<Interface_GTool> &)) &Interface_InterfaceModel::SetGTool, "Sets a GTool for this model, which already defines a Protocol", py::arg("gtool"));
cls_Interface_InterfaceModel.def("GTool", (opencascade::handle<Interface_GTool> (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::GTool, "Returns the GTool, set by SetProtocol or by SetGTool");
cls_Interface_InterfaceModel.def("DispatchStatus", (Standard_Boolean & (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::DispatchStatus, "Returns the Dispatch Status, either for get or set A Model which is produced from Dispatch may share entities with the original (according to the Protocol), hence these non-copied entities should not be deleted");
cls_Interface_InterfaceModel.def("Clear", (void (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::Clear, "Erases contained data; used when a Model is copied to others : the new copied ones begin from clear Clear calls specific method ClearHeader (see below)");
cls_Interface_InterfaceModel.def("ClearEntities", (void (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::ClearEntities, "Clears the entities; uses the general service WhenDelete, in addition to the standard Memory Manager; can be redefined");
cls_Interface_InterfaceModel.def("ClearLabels", (void (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::ClearLabels, "Erases informations about labels, if any : specific to each norm");
cls_Interface_InterfaceModel.def("ClearHeader", (void (Interface_InterfaceModel::*)()) &Interface_InterfaceModel::ClearHeader, "Clears Model's header : specific to each norm");
cls_Interface_InterfaceModel.def("NbEntities", (Standard_Integer (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::NbEntities, "Returns count of contained Entities");
cls_Interface_InterfaceModel.def("Contains", (Standard_Boolean (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &) const) &Interface_InterfaceModel::Contains, "Returns True if a Model contains an Entity (for a ReportEntity, looks for the ReportEntity itself AND its Concerned Entity)", py::arg("anentity"));
cls_Interface_InterfaceModel.def("Number", (Standard_Integer (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &) const) &Interface_InterfaceModel::Number, "Returns the Number of an Entity in the Model if it contains it. Else returns 0. For a ReportEntity, looks at Concerned Entity. Returns the Directory entry Number of an Entity in the Model if it contains it. Else returns 0. For a ReportEntity, looks at Concerned Entity.", py::arg("anentity"));
cls_Interface_InterfaceModel.def("Value", (const opencascade::handle<Standard_Transient> & (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::Value, "Returns an Entity identified by its number in the Model Each sub-class of InterfaceModel can define its own method Entity to return its specific class of Entity (e.g. for VDA, VDAModel returns a VDAEntity), working by calling Value Remark : For a Reported Entity, (Erroneous, Corrected, Unknown), this method returns this Reported Entity. See ReportEntity for other questions.", py::arg("num"));
cls_Interface_InterfaceModel.def("NbTypes", (Standard_Integer (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &) const) &Interface_InterfaceModel::NbTypes, "Returns the count of DISTINCT types under which an entity may be processed. Defined by the Protocol, which gives default as 1 (dynamic Type).", py::arg("ent"));
cls_Interface_InterfaceModel.def("Type", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0) -> opencascade::handle<Standard_Type> { return self.Type(a0); });
cls_Interface_InterfaceModel.def("Type", (opencascade::handle<Standard_Type> (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer) const) &Interface_InterfaceModel::Type, "Returns a type, given its rank : defined by the Protocol (by default, the first one)", py::arg("ent"), py::arg("num"));
cls_Interface_InterfaceModel.def("TypeName", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0) -> Standard_CString { return self.TypeName(a0); });
cls_Interface_InterfaceModel.def("TypeName", (Standard_CString (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const Standard_Boolean) const) &Interface_InterfaceModel::TypeName, "Returns the type name of an entity, from the list of types (one or more ...) <complete> True (D) gives the complete type, else packages are removed WARNING : buffered, to be immediately copied or printed", py::arg("ent"), py::arg("complete"));
cls_Interface_InterfaceModel.def_static("ClassName_", (Standard_CString (*)(const Standard_CString)) &Interface_InterfaceModel::ClassName, "From a CDL Type Name, returns the Class part (package dropped) WARNING : buffered, to be immediately copied or printed", py::arg("typnam"));
cls_Interface_InterfaceModel.def("EntityState", (Interface_DataState (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::EntityState, "Returns the State of an entity, given its number", py::arg("num"));
cls_Interface_InterfaceModel.def("IsReportEntity", [](Interface_InterfaceModel &self, const Standard_Integer a0) -> Standard_Boolean { return self.IsReportEntity(a0); });
cls_Interface_InterfaceModel.def("IsReportEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer, const Standard_Boolean) const) &Interface_InterfaceModel::IsReportEntity, "Returns True if <num> identifies a ReportEntity in the Model Hence, ReportEntity can be called.", py::arg("num"), py::arg("semantic"));
cls_Interface_InterfaceModel.def("ReportEntity", [](Interface_InterfaceModel &self, const Standard_Integer a0) -> opencascade::handle<Interface_ReportEntity> { return self.ReportEntity(a0); });
cls_Interface_InterfaceModel.def("ReportEntity", (opencascade::handle<Interface_ReportEntity> (Interface_InterfaceModel::*)(const Standard_Integer, const Standard_Boolean) const) &Interface_InterfaceModel::ReportEntity, "Returns a ReportEntity identified by its number in the Model, or a Null Handle If <num> does not identify a ReportEntity.", py::arg("num"), py::arg("semantic"));
cls_Interface_InterfaceModel.def("IsErrorEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::IsErrorEntity, "Returns True if <num> identifies an Error Entity : in this case, a ReportEntity brings Fail Messages and possibly an 'undefined' Content, see IsRedefinedEntity", py::arg("num"));
cls_Interface_InterfaceModel.def("IsRedefinedContent", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::IsRedefinedContent, "Returns True if <num> identifies an Entity which content is redefined through a ReportEntity (i.e. with literal data only) This happens when an entity is syntactically erroneous in the way that its basic content remains empty. For more details (such as content itself), see ReportEntity", py::arg("num"));
cls_Interface_InterfaceModel.def("ClearReportEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer)) &Interface_InterfaceModel::ClearReportEntity, "Removes the ReportEntity attached to Entity <num>. Returns True if done, False if no ReportEntity was attached to <num>. Warning : the caller must assume that this clearing is meaningfull", py::arg("num"));
cls_Interface_InterfaceModel.def("SetReportEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer, const opencascade::handle<Interface_ReportEntity> &)) &Interface_InterfaceModel::SetReportEntity, "Sets or Replaces a ReportEntity for the Entity <num>. Returns True if Report is replaced, False if it has been replaced Warning : the caller must assume that this setting is meaningfull", py::arg("num"), py::arg("rep"));
cls_Interface_InterfaceModel.def("AddReportEntity", [](Interface_InterfaceModel &self, const opencascade::handle<Interface_ReportEntity> & a0) -> Standard_Boolean { return self.AddReportEntity(a0); });
cls_Interface_InterfaceModel.def("AddReportEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const opencascade::handle<Interface_ReportEntity> &, const Standard_Boolean)) &Interface_InterfaceModel::AddReportEntity, "Adds a ReportEntity as such. Returns False if the concerned entity is not recorded in the Model Else, adds it into, either the main report list or the list for semantic checks, then returns True", py::arg("rep"), py::arg("semantic"));
cls_Interface_InterfaceModel.def("IsUnknownEntity", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::IsUnknownEntity, "Returns True if <num> identifies an Unknown Entity : in this case, a ReportEntity with no Check Messages designates it.", py::arg("num"));
cls_Interface_InterfaceModel.def("FillSemanticChecks", [](Interface_InterfaceModel &self, const Interface_CheckIterator & a0) -> void { return self.FillSemanticChecks(a0); });
cls_Interface_InterfaceModel.def("FillSemanticChecks", (void (Interface_InterfaceModel::*)(const Interface_CheckIterator &, const Standard_Boolean)) &Interface_InterfaceModel::FillSemanticChecks, "Fills the list of semantic checks. This list is computed (by CheckTool). Hence, it can be stored in the model for later queries <clear> True (D) : new list replaces <clear> False : new list is cumulated", py::arg("checks"), py::arg("clear"));
cls_Interface_InterfaceModel.def("HasSemanticChecks", (Standard_Boolean (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::HasSemanticChecks, "Returns True if semantic checks have been filled");
cls_Interface_InterfaceModel.def("Check", (const opencascade::handle<Interface_Check> & (Interface_InterfaceModel::*)(const Standard_Integer, const Standard_Boolean) const) &Interface_InterfaceModel::Check, "Returns the check attached to an entity, designated by its Number. 0 for global check <semantic> True : recorded semantic check <semantic> False : recorded syntactic check (see ReportEntity) If no check is recorded for <num>, returns an empty Check", py::arg("num"), py::arg("syntactic"));
cls_Interface_InterfaceModel.def("Reservate", (void (Interface_InterfaceModel::*)(const Standard_Integer)) &Interface_InterfaceModel::Reservate, "Does a reservation for the List of Entities (for optimized storage management). If it is not called, storage management can be less efficient. <nbent> is the expected count of Entities to store", py::arg("nbent"));
cls_Interface_InterfaceModel.def("AddEntity", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &)) &Interface_InterfaceModel::AddEntity, "Internal method for adding an Entity. Used by file reading (defined by each Interface) and Transfer tools. It adds the entity required to be added, not its refs : see AddWithRefs. If <anentity> is a ReportEntity, it is added to the list of Reports, its Concerned Entity (Erroneous or Corrected, else Unknown) is added to the list of Entities. That is, the ReportEntity must be created before Adding", py::arg("anentity"));
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const opencascade::handle<Interface_Protocol> & a1) -> void { return self.AddWithRefs(a0, a1); });
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const opencascade::handle<Interface_Protocol> & a1, const Standard_Integer a2) -> void { return self.AddWithRefs(a0, a1, a2); });
cls_Interface_InterfaceModel.def("AddWithRefs", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Interface_Protocol> &, const Standard_Integer, const Standard_Boolean)) &Interface_InterfaceModel::AddWithRefs, "Adds to the Model, an Entity with all its References, as they are defined by General Services FillShared and ListImplied. Process is recursive (any sub-levels) if <level> = 0 (Default) Else, adds sub-entities until the required sub-level. Especially, if <level> = 1, adds immediate subs and that's all", py::arg("anent"), py::arg("proto"), py::arg("level"), py::arg("listall"));
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0) -> void { return self.AddWithRefs(a0); });
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const Standard_Integer a1) -> void { return self.AddWithRefs(a0, a1); });
cls_Interface_InterfaceModel.def("AddWithRefs", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const Standard_Boolean)) &Interface_InterfaceModel::AddWithRefs, "Same as above, but works with the Protocol of the Model", py::arg("anent"), py::arg("level"), py::arg("listall"));
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const Interface_GeneralLib & a1) -> void { return self.AddWithRefs(a0, a1); });
cls_Interface_InterfaceModel.def("AddWithRefs", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const Interface_GeneralLib & a1, const Standard_Integer a2) -> void { return self.AddWithRefs(a0, a1, a2); });
cls_Interface_InterfaceModel.def("AddWithRefs", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const Interface_GeneralLib &, const Standard_Integer, const Standard_Boolean)) &Interface_InterfaceModel::AddWithRefs, "Same as above, but works with an already created GeneralLib", py::arg("anent"), py::arg("lib"), py::arg("level"), py::arg("listall"));
cls_Interface_InterfaceModel.def("ReplaceEntity", (void (Interface_InterfaceModel::*)(const Standard_Integer, const opencascade::handle<Standard_Transient> &)) &Interface_InterfaceModel::ReplaceEntity, "Replace Entity with Number=nument on other entity - 'anent'", py::arg("nument"), py::arg("anent"));
cls_Interface_InterfaceModel.def("ReverseOrders", [](Interface_InterfaceModel &self) -> void { return self.ReverseOrders(); });
cls_Interface_InterfaceModel.def("ReverseOrders", (void (Interface_InterfaceModel::*)(const Standard_Integer)) &Interface_InterfaceModel::ReverseOrders, "Reverses the Numbers of the Entities, between <after> and the total count of Entities. Thus, the entities : 1,2 ... after, after+1 ... nb-1, nb become numbered as : 1,2 ... after, nb, nb-1 ... after+1 By default (after = 0) the whole list of Entities is reversed", py::arg("after"));
cls_Interface_InterfaceModel.def("ChangeOrder", [](Interface_InterfaceModel &self, const Standard_Integer a0, const Standard_Integer a1) -> void { return self.ChangeOrder(a0, a1); });
cls_Interface_InterfaceModel.def("ChangeOrder", (void (Interface_InterfaceModel::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Interface_InterfaceModel::ChangeOrder, "Changes the Numbers of some Entities : <oldnum> is moved to <newnum>, same for <count> entities. Thus : 1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives 1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1 (can be seen as a circular permutation)", py::arg("oldnum"), py::arg("newnum"), py::arg("count"));
cls_Interface_InterfaceModel.def("GetFromTransfer", (void (Interface_InterfaceModel::*)(const Interface_EntityIterator &)) &Interface_InterfaceModel::GetFromTransfer, "Gets contents from an EntityIterator, prepared by a Transfer tool (e.g TransferCopy). Starts from clear", py::arg("aniter"));
cls_Interface_InterfaceModel.def("GetFromAnother", (void (Interface_InterfaceModel::*)(const opencascade::handle<Interface_InterfaceModel> &)) &Interface_InterfaceModel::GetFromAnother, "Gets header (data specific of a defined Interface) from another InterfaceModel; called from TransferCopy", py::arg("other"));
cls_Interface_InterfaceModel.def("NewEmptyModel", (opencascade::handle<Interface_InterfaceModel> (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::NewEmptyModel, "Returns a New Empty Model, same type as <me> (whatever its Type); called to Copy parts a Model into other ones, then followed by a call to GetFromAnother (Header) then filling with specified Entities, themselves copied");
cls_Interface_InterfaceModel.def("SetCategoryNumber", (Standard_Boolean (Interface_InterfaceModel::*)(const Standard_Integer, const Standard_Integer)) &Interface_InterfaceModel::SetCategoryNumber, "Records a category number for an entity number Returns True when done, False if <num> is out of range", py::arg("num"), py::arg("val"));
cls_Interface_InterfaceModel.def("CategoryNumber", (Standard_Integer (Interface_InterfaceModel::*)(const Standard_Integer) const) &Interface_InterfaceModel::CategoryNumber, "Returns the recorded category number for a given entity number 0 if none was defined for this entity", py::arg("num"));
cls_Interface_InterfaceModel.def("FillIterator", (void (Interface_InterfaceModel::*)(Interface_EntityIterator &) const) &Interface_InterfaceModel::FillIterator, "Allows an EntityIterator to get a list of Entities", py::arg("iter"));
cls_Interface_InterfaceModel.def("Entities", (Interface_EntityIterator (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::Entities, "Returns the list of all Entities, as an Iterator on Entities (the Entities themselves, not the Reports)");
cls_Interface_InterfaceModel.def("Reports", [](Interface_InterfaceModel &self) -> Interface_EntityIterator { return self.Reports(); });
cls_Interface_InterfaceModel.def("Reports", (Interface_EntityIterator (Interface_InterfaceModel::*)(const Standard_Boolean) const) &Interface_InterfaceModel::Reports, "Returns the list of all ReportEntities, i.e. data about Entities read with Error or Warning informations (each item has to be casted to Report Entity then it can be queried for Concerned Entity, Content, Check ...) By default, returns the main reports, is <semantic> is True it returns the list for sematic checks", py::arg("semantic"));
cls_Interface_InterfaceModel.def("Redefineds", (Interface_EntityIterator (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::Redefineds, "Returns the list of ReportEntities which redefine data (generally, if concerned entity is 'Error', a literal content is added to it : this is a 'redefined entity'");
cls_Interface_InterfaceModel.def("GlobalCheck", [](Interface_InterfaceModel &self) -> const opencascade::handle<Interface_Check> & { return self.GlobalCheck(); });
cls_Interface_InterfaceModel.def("GlobalCheck", (const opencascade::handle<Interface_Check> & (Interface_InterfaceModel::*)(const Standard_Boolean) const) &Interface_InterfaceModel::GlobalCheck, "Returns the GlobalCheck, which memorizes messages global to the file (not specific to an Entity), especially Header", py::arg("syntactic"));
cls_Interface_InterfaceModel.def("SetGlobalCheck", (void (Interface_InterfaceModel::*)(const opencascade::handle<Interface_Check> &)) &Interface_InterfaceModel::SetGlobalCheck, "Allows to modify GlobalCheck, after getting then completing it Remark : it is SYNTACTIC check. Semantics, see FillChecks", py::arg("ach"));
cls_Interface_InterfaceModel.def("VerifyCheck", (void (Interface_InterfaceModel::*)(opencascade::handle<Interface_Check> &) const) &Interface_InterfaceModel::VerifyCheck, "Minimum Semantic Global Check on data in model (header) Can only check basic Data. See also GlobalCheck from Protocol for a check which takes the Graph into account Default does nothing, can be redefined", py::arg("ach"));
cls_Interface_InterfaceModel.def("DumpHeader", [](Interface_InterfaceModel &self, const opencascade::handle<Message_Messenger> & a0) -> void { return self.DumpHeader(a0); });
cls_Interface_InterfaceModel.def("DumpHeader", (void (Interface_InterfaceModel::*)(const opencascade::handle<Message_Messenger> &, const Standard_Integer) const) &Interface_InterfaceModel::DumpHeader, "Dumps Header in a short, easy to read, form, onto a Stream <level> allows to print more or less parts of the header, if necessary. 0 for basic print", py::arg("S"), py::arg("level"));
cls_Interface_InterfaceModel.def("Print", [](Interface_InterfaceModel &self, const opencascade::handle<Standard_Transient> & a0, const opencascade::handle<Message_Messenger> & a1) -> void { return self.Print(a0, a1); });
cls_Interface_InterfaceModel.def("Print", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Message_Messenger> &, const Standard_Integer) const) &Interface_InterfaceModel::Print, "Prints identification of a given entity in <me>, in order to be printed in a list or phrase <mode> < 0 : prints only its number <mode> = 1 : just calls PrintLabel <mode> = 0 (D) : prints its number plus '/' plus PrintLabel If <ent> == <me>, simply prints 'Global' If <ent> is unknown, prints '??/its type'", py::arg("ent"), py::arg("s"), py::arg("mode"));
cls_Interface_InterfaceModel.def("PrintLabel", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Message_Messenger> &) const) &Interface_InterfaceModel::PrintLabel, "Prints label specific to each norm, for a given entity. Must only print label itself, in order to be included in a phrase. Can call the result of StringLabel, but not obliged.", py::arg("ent"), py::arg("S"));
cls_Interface_InterfaceModel.def("PrintToLog", (void (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Message_Messenger> &) const) &Interface_InterfaceModel::PrintToLog, "Prints label specific to each norm in log format, for a given entity. By default, just calls PrintLabel, can be redefined", py::arg("ent"), py::arg("S"));
cls_Interface_InterfaceModel.def("StringLabel", (opencascade::handle<TCollection_HAsciiString> (Interface_InterfaceModel::*)(const opencascade::handle<Standard_Transient> &) const) &Interface_InterfaceModel::StringLabel, "Returns a string with the label attached to a given entity. Warning : While this string may be edited on the spot, if it is a read field, the returned value must be copied before.", py::arg("ent"));
cls_Interface_InterfaceModel.def("NextNumberForLabel", [](Interface_InterfaceModel &self, const Standard_CString a0) -> Standard_Integer { return self.NextNumberForLabel(a0); });
cls_Interface_InterfaceModel.def("NextNumberForLabel", [](Interface_InterfaceModel &self, const Standard_CString a0, const Standard_Integer a1) -> Standard_Integer { return self.NextNumberForLabel(a0, a1); });
cls_Interface_InterfaceModel.def("NextNumberForLabel", (Standard_Integer (Interface_InterfaceModel::*)(const Standard_CString, const Standard_Integer, const Standard_Boolean) const) &Interface_InterfaceModel::NextNumberForLabel, "Searches a label which matches with one entity. Begins from <lastnum>+1 (default:1) and scans the entities until <NbEntities>. For the first which matches <label>, this method returns its Number. Returns 0 if nothing found Can be called recursively (labels are not specified as unique) <exact> : if True (default), exact match is required else, checks the END of entity label", py::arg("label"), py::arg("lastnum"), py::arg("exact"));
cls_Interface_InterfaceModel.def_static("HasTemplate_", (Standard_Boolean (*)(const Standard_CString)) &Interface_InterfaceModel::HasTemplate, "Returns true if a template is attached to a given name", py::arg("name"));
cls_Interface_InterfaceModel.def_static("Template_", (opencascade::handle<Interface_InterfaceModel> (*)(const Standard_CString)) &Interface_InterfaceModel::Template, "Returns the template model attached to a name, or a Null Handle", py::arg("name"));
cls_Interface_InterfaceModel.def_static("SetTemplate_", (Standard_Boolean (*)(const Standard_CString, const opencascade::handle<Interface_InterfaceModel> &)) &Interface_InterfaceModel::SetTemplate, "Records a new template model with a name. If the name was already recorded, the corresponding template is replaced by the new one. Then, WARNING : test HasTemplate to avoid surprises", py::arg("name"), py::arg("model"));
cls_Interface_InterfaceModel.def_static("ListTemplates_", (opencascade::handle<TColStd_HSequenceOfHAsciiString> (*)()) &Interface_InterfaceModel::ListTemplates, "Returns the complete list of names attached to template models");
cls_Interface_InterfaceModel.def_static("get_type_name_", (const char * (*)()) &Interface_InterfaceModel::get_type_name, "None");
cls_Interface_InterfaceModel.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Interface_InterfaceModel::get_type_descriptor, "None");
cls_Interface_InterfaceModel.def("DynamicType", (const opencascade::handle<Standard_Type> & (Interface_InterfaceModel::*)() const) &Interface_InterfaceModel::DynamicType, "None");

// Enums

}