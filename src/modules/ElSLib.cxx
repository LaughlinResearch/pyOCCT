/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard.hxx>
#include <gp_Pnt.hxx>
#include <Standard_TypeDef.hxx>
#include <gp_Pln.hxx>
#include <gp_Cone.hxx>
#include <gp_Cylinder.hxx>
#include <gp_Sphere.hxx>
#include <gp_Torus.hxx>
#include <gp_Vec.hxx>
#include <gp_Ax3.hxx>
#include <gp_Lin.hxx>
#include <gp_Circ.hxx>
#include <ElSLib.hxx>

PYBIND11_MODULE(ElSLib, mod) {

py::module::import("OCCT.Standard");
py::module::import("OCCT.gp");

// CLASS: ELSLIB
py::class_<ElSLib> cls_ElSLib(mod, "ElSLib", "Provides functions for basic geometric computation on elementary surfaces. This includes: - calculation of a point or derived vector on a surface where the surface is provided by the gp package, or defined in canonical form (as in the gp package), and the point is defined with a parameter, - evaluation of the parameters corresponding to a point on an elementary surface from gp, - calculation of isoparametric curves on an elementary surface defined in canonical form (as in the gp package). Notes: - ElSLib stands for Elementary Surfaces Library. - If the surfaces provided by the gp package are not explicitly parameterized, they still have an implicit parameterization, similar to that which they infer on the equivalent Geom surfaces. Note: ElSLib stands for Elementary Surfaces Library.");

// Methods
// cls_ElSLib.def_static("operator new_", (void * (*)(size_t)) &ElSLib::operator new, "None", py::arg("theSize"));
// cls_ElSLib.def_static("operator delete_", (void (*)(void *)) &ElSLib::operator delete, "None", py::arg("theAddress"));
// cls_ElSLib.def_static("operator new[]_", (void * (*)(size_t)) &ElSLib::operator new[], "None", py::arg("theSize"));
// cls_ElSLib.def_static("operator delete[]_", (void (*)(void *)) &ElSLib::operator delete[], "None", py::arg("theAddress"));
// cls_ElSLib.def_static("operator new_", (void * (*)(size_t, void *)) &ElSLib::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_ElSLib.def_static("operator delete_", (void (*)(void *, void *)) &ElSLib::operator delete, "None", py::arg(""), py::arg(""));
cls_ElSLib.def_static("Value_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Pln &)) &ElSLib::Value, "For elementary surfaces from the gp package (planes, cones, cylinders, spheres and tori), computes the point of parameters (U, V).", py::arg("U"), py::arg("V"), py::arg("Pl"));
cls_ElSLib.def_static("Value_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Cone &)) &ElSLib::Value, "None", py::arg("U"), py::arg("V"), py::arg("C"));
cls_ElSLib.def_static("Value_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &)) &ElSLib::Value, "None", py::arg("U"), py::arg("V"), py::arg("C"));
cls_ElSLib.def_static("Value_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Sphere &)) &ElSLib::Value, "None", py::arg("U"), py::arg("V"), py::arg("S"));
cls_ElSLib.def_static("Value_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Torus &)) &ElSLib::Value, "None", py::arg("U"), py::arg("V"), py::arg("T"));
cls_ElSLib.def_static("DN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Pln &, const Standard_Integer, const Standard_Integer)) &ElSLib::DN, "For elementary surfaces from the gp package (planes, cones, cylinders, spheres and tori), computes the derivative vector of order Nu and Nv in the u and v parametric directions respectively, at the point of parameters (U, V).", py::arg("U"), py::arg("V"), py::arg("Pl"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("DN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Cone &, const Standard_Integer, const Standard_Integer)) &ElSLib::DN, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("DN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &, const Standard_Integer, const Standard_Integer)) &ElSLib::DN, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("DN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Sphere &, const Standard_Integer, const Standard_Integer)) &ElSLib::DN, "None", py::arg("U"), py::arg("V"), py::arg("S"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("DN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Torus &, const Standard_Integer, const Standard_Integer)) &ElSLib::DN, "None", py::arg("U"), py::arg("V"), py::arg("T"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Pln &, gp_Pnt &)) &ElSLib::D0, "For elementary surfaces from the gp package (planes, cones, cylinders, spheres and tori), computes the point P of parameters (U, V).inline", py::arg("U"), py::arg("V"), py::arg("Pl"), py::arg("P"));
cls_ElSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cone &, gp_Pnt &)) &ElSLib::D0, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"));
cls_ElSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &, gp_Pnt &)) &ElSLib::D0, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"));
cls_ElSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Sphere &, gp_Pnt &)) &ElSLib::D0, "None", py::arg("U"), py::arg("V"), py::arg("S"), py::arg("P"));
cls_ElSLib.def_static("D0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Torus &, gp_Pnt &)) &ElSLib::D0, "None", py::arg("U"), py::arg("V"), py::arg("T"), py::arg("P"));
cls_ElSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Pln &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::D1, "For elementary surfaces from the gp package (planes, cones, cylinders, spheres and tori), computes: - the point P of parameters (U, V), and - the first derivative vectors Vu and Vv at this point in the u and v parametric directions respectively.", py::arg("U"), py::arg("V"), py::arg("Pl"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cone &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::D1, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::D1, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Sphere &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::D1, "None", py::arg("U"), py::arg("V"), py::arg("S"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("D1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Torus &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::D1, "None", py::arg("U"), py::arg("V"), py::arg("T"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cone &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D2, "For elementary surfaces from the gp package (cones, cylinders, spheres and tori), computes: - the point P of parameters (U, V), and - the first derivative vectors Vu and Vv at this point in the u and v parametric directions respectively, and - the second derivative vectors Vuu, Vvv and Vuv at this point.", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D2, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Sphere &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D2, "None", py::arg("U"), py::arg("V"), py::arg("S"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("D2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Torus &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D2, "None", py::arg("U"), py::arg("V"), py::arg("T"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cone &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D3, "For elementary surfaces from the gp package (cones, cylinders, spheres and tori), computes: - the point P of parameters (U,V), and - the first derivative vectors Vu and Vv at this point in the u and v parametric directions respectively, and - the second derivative vectors Vuu, Vvv and Vuv at this point, and - the third derivative vectors Vuuu, Vvvv, Vuuv and Vuvv at this point.", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Cylinder &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D3, "None", py::arg("U"), py::arg("V"), py::arg("C"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Sphere &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D3, "None", py::arg("U"), py::arg("V"), py::arg("S"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("D3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Torus &, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::D3, "Surface evaluation The following functions compute the point and the derivatives on elementary surfaces defined with their geometric characterisitics. You don't need to create the surface to use these functions. These functions are called by the previous ones. Example : A cylinder is defined with its position and its radius.", py::arg("U"), py::arg("V"), py::arg("T"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("PlaneValue_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &)) &ElSLib::PlaneValue, "None", py::arg("U"), py::arg("V"), py::arg("Pos"));
cls_ElSLib.def_static("CylinderValue_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real)) &ElSLib::CylinderValue, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"));
cls_ElSLib.def_static("ConeValue_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::ConeValue, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"));
cls_ElSLib.def_static("SphereValue_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real)) &ElSLib::SphereValue, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"));
cls_ElSLib.def_static("TorusValue_", (gp_Pnt (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::TorusValue, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"));
cls_ElSLib.def_static("PlaneDN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Integer, const Standard_Integer)) &ElSLib::PlaneDN, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("CylinderDN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Integer, const Standard_Integer)) &ElSLib::CylinderDN, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("ConeDN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer)) &ElSLib::ConeDN, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("SphereDN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Integer, const Standard_Integer)) &ElSLib::SphereDN, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("TorusDN_", (gp_Vec (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer)) &ElSLib::TorusDN, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("Nu"), py::arg("Nv"));
cls_ElSLib.def_static("PlaneD0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, gp_Pnt &)) &ElSLib::PlaneD0, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("P"));
cls_ElSLib.def_static("ConeD0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &)) &ElSLib::ConeD0, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("P"));
cls_ElSLib.def_static("CylinderD0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &)) &ElSLib::CylinderD0, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"));
cls_ElSLib.def_static("SphereD0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &)) &ElSLib::SphereD0, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"));
cls_ElSLib.def_static("TorusD0_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &)) &ElSLib::TorusD0, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("P"));
cls_ElSLib.def_static("PlaneD1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::PlaneD1, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("ConeD1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::ConeD1, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("CylinderD1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::CylinderD1, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("SphereD1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::SphereD1, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("TorusD1_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &)) &ElSLib::TorusD1, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"));
cls_ElSLib.def_static("ConeD2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::ConeD2, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("CylinderD2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::CylinderD2, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("SphereD2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::SphereD2, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("TorusD2_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::TorusD2, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"));
cls_ElSLib.def_static("ConeD3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::ConeD3, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("CylinderD3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::CylinderD3, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("SphereD3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::SphereD3, "None", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("TorusD3_", (void (*)(const Standard_Real, const Standard_Real, const gp_Ax3 &, const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &)) &ElSLib::TorusD3, "The following functions compute the parametric values corresponding to a given point on a elementary surface. The point should be on the surface.", py::arg("U"), py::arg("V"), py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("P"), py::arg("Vu"), py::arg("Vv"), py::arg("Vuu"), py::arg("Vvv"), py::arg("Vuv"), py::arg("Vuuu"), py::arg("Vvvv"), py::arg("Vuuv"), py::arg("Vuvv"));
cls_ElSLib.def_static("Parameters_", [](const gp_Pln & Pl, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::Parameters(Pl, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection()", py::arg("Pl"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("Parameters_", [](const gp_Cylinder & C, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::Parameters(C, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + V * ZDirection + Radius * (Cos(U) * XDirection + Sin (U) * YDirection)", py::arg("C"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("Parameters_", [](const gp_Cone & C, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::Parameters(C, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + V * ZDirection + (Radius + V * Tan (SemiAngle)) * (Cos(U) * XDirection + Sin(U) * YDirection)", py::arg("C"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("Parameters_", [](const gp_Sphere & S, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::Parameters(S, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) + Radius * Sin (V) * ZDirection", py::arg("S"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("Parameters_", [](const gp_Torus & T, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::Parameters(T, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + (MajorRadius + MinorRadius * Cos(U)) * (Cos(V) * XDirection - Sin(V) * YDirection) + MinorRadius * Sin(U) * ZDirection", py::arg("T"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("PlaneParameters_", [](const gp_Ax3 & Pos, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::PlaneParameters(Pos, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection()", py::arg("Pos"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("CylinderParameters_", [](const gp_Ax3 & Pos, const Standard_Real Radius, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::CylinderParameters(Pos, Radius, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + V * ZDirection + Radius * (Cos(U) * XDirection + Sin (U) * YDirection)", py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("ConeParameters_", [](const gp_Ax3 & Pos, const Standard_Real Radius, const Standard_Real SAngle, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::ConeParameters(Pos, Radius, SAngle, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + V * ZDirection + (Radius + V * Tan (SemiAngle)) * (Cos(U) * XDirection + Sin(U) * YDirection)", py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("SphereParameters_", [](const gp_Ax3 & Pos, const Standard_Real Radius, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::SphereParameters(Pos, Radius, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) + Radius * Sin (V) * ZDirection", py::arg("Pos"), py::arg("Radius"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("TorusParameters_", [](const gp_Ax3 & Pos, const Standard_Real MajorRadius, const Standard_Real MinorRadius, const gp_Pnt & P, Standard_Real & U, Standard_Real & V){ ElSLib::TorusParameters(Pos, MajorRadius, MinorRadius, P, U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "parametrization P (U, V) = Location + (MajorRadius + MinorRadius * Cos(U)) * (Cos(V) * XDirection - Sin(V) * YDirection) + MinorRadius * Sin(U) * ZDirection", py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("P"), py::arg("U"), py::arg("V"));
cls_ElSLib.def_static("PlaneUIso_", (gp_Lin (*)(const gp_Ax3 &, const Standard_Real)) &ElSLib::PlaneUIso, "compute the U Isoparametric gp_Lin of the plane.", py::arg("Pos"), py::arg("U"));
cls_ElSLib.def_static("CylinderUIso_", (gp_Lin (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::CylinderUIso, "compute the U Isoparametric gp_Lin of the cylinder.", py::arg("Pos"), py::arg("Radius"), py::arg("U"));
cls_ElSLib.def_static("ConeUIso_", (gp_Lin (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Real)) &ElSLib::ConeUIso, "compute the U Isoparametric gp_Lin of the cone.", py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("U"));
cls_ElSLib.def_static("SphereUIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::SphereUIso, "compute the U Isoparametric gp_Circ of the sphere, (the meridian is not trimmed).", py::arg("Pos"), py::arg("Radius"), py::arg("U"));
cls_ElSLib.def_static("TorusUIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Real)) &ElSLib::TorusUIso, "compute the U Isoparametric gp_Circ of the torus.", py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("U"));
cls_ElSLib.def_static("PlaneVIso_", (gp_Lin (*)(const gp_Ax3 &, const Standard_Real)) &ElSLib::PlaneVIso, "compute the V Isoparametric gp_Lin of the plane.", py::arg("Pos"), py::arg("V"));
cls_ElSLib.def_static("CylinderVIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::CylinderVIso, "compute the V Isoparametric gp_Circ of the cylinder.", py::arg("Pos"), py::arg("Radius"), py::arg("V"));
cls_ElSLib.def_static("ConeVIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Real)) &ElSLib::ConeVIso, "compute the V Isoparametric gp_Circ of the cone.", py::arg("Pos"), py::arg("Radius"), py::arg("SAngle"), py::arg("V"));
cls_ElSLib.def_static("SphereVIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real)) &ElSLib::SphereVIso, "compute the V Isoparametric gp_Circ of the sphere, (the meridian is not trimmed).", py::arg("Pos"), py::arg("Radius"), py::arg("V"));
cls_ElSLib.def_static("TorusVIso_", (gp_Circ (*)(const gp_Ax3 &, const Standard_Real, const Standard_Real, const Standard_Real)) &ElSLib::TorusVIso, "compute the V Isoparametric gp_Circ of the torus.", py::arg("Pos"), py::arg("MajorRadius"), py::arg("MinorRadius"), py::arg("V"));


}
