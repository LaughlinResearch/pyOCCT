/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard_Transient.hxx>
#include <AIS_LocalContext.hxx>
#include <Standard_Handle.hxx>
#include <AIS_InteractiveContext.hxx>
#include <Standard_Type.hxx>
#include <V3d_Viewer.hxx>
#include <AIS_DisplayStatus.hxx>
#include <AIS_InteractiveObject.hxx>
#include <TCollection_ExtendedString.hxx>
#include <Standard_TypeDef.hxx>
#include <AIS_KindOfInteractive.hxx>
#include <Prs3d_Drawer.hxx>
#include <Prs3d_TypeOfHighlight.hxx>
#include <SelectMgr_EntityOwner.hxx>
#include <Graphic3d_ZLayerId.hxx>
#include <V3d_View.hxx>
#include <TopLoc_Location.hxx>
#include <Graphic3d_TransformPers.hxx>
#include <Graphic3d_TransModeFlags.hxx>
#include <gp_Pnt.hxx>
#include <AIS_StatusOfDetection.hxx>
#include <TopoDS_Shape.hxx>
#include <Prs3d_BasicAspect.hxx>
#include <AIS_StatusOfPick.hxx>
#include <TColgp_Array1OfPnt2d.hxx>
#include <AIS_SelectionModesConcurrency.hxx>
#include <TColStd_ListOfInteger.hxx>
#include <SelectMgr_IndexedMapOfOwner.hxx>
#include <SelectMgr_ListOfFilter.hxx>
#include <SelectMgr_Filter.hxx>
#include <SelectMgr_PickingStrategy.hxx>
#include <SelectMgr_SelectionManager.hxx>
#include <PrsMgr_PresentationManager3d.hxx>
#include <StdSelect_ViewerSelector3d.hxx>
#include <AIS_ListOfInteractive.hxx>
#include <Aspect_TypeOfFacingModel.hxx>
#include <Quantity_Color.hxx>
#include <Graphic3d_MaterialAspect.hxx>
#include <Prs3d_LineAspect.hxx>
#include <AIS_TypeOfIso.hxx>
#include <AIS_ClearMode.hxx>
#include <TopAbs_ShapeEnum.hxx>
#include <Standard_ProgramError.hxx>
#include <AIS_DataMapOfIOStatus.hxx>
#include <AIS_Selection.hxx>
#include <SelectMgr_OrFilter.hxx>
#include <AIS_DataMapOfILC.hxx>
#include <TColStd_SequenceOfInteger.hxx>

void bind_AIS_InteractiveContext(py::module &mod){

py::class_<AIS_InteractiveContext, opencascade::handle<AIS_InteractiveContext>, Standard_Transient> cls_AIS_InteractiveContext(mod, "AIS_InteractiveContext", "The Interactive Context allows you to manage graphic behavior and selection of Interactive Objects in one or more viewers. Class methods make this highly transparent. It is essential to remember that an Interactive Object which is already known by the Interactive Context must be modified using Context methods. You can only directly call the methods available for an Interactive Object if it has not been loaded into an Interactive Context.");

// Constructors
cls_AIS_InteractiveContext.def(py::init<const opencascade::handle<V3d_Viewer> &>(), py::arg("MainViewer"));

// Fields

// Methods
cls_AIS_InteractiveContext.def_static("get_type_name_", (const char * (*)()) &AIS_InteractiveContext::get_type_name, "None");
cls_AIS_InteractiveContext.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &AIS_InteractiveContext::get_type_descriptor, "None");
cls_AIS_InteractiveContext.def("DynamicType", (const opencascade::handle<Standard_Type> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DynamicType, "None");
cls_AIS_InteractiveContext.def("DisplayStatus", (AIS_DisplayStatus (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::DisplayStatus, "Returns the display status of the entity anIobj. This will be one of the following: - AIS_DS_Displayed displayed in main viewer - AIS_DS_Erased hidden in main viewer - AIS_DS_Temporary temporarily displayed - AIS_DS_None nowhere displayed.", py::arg("anIobj"));
cls_AIS_InteractiveContext.def("Status", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, TCollection_ExtendedString &) const) &AIS_InteractiveContext::Status, "Returns the status of the Interactive Context for the view of the Interactive Object.", py::arg("anObj"), py::arg("astatus"));
cls_AIS_InteractiveContext.def("IsDisplayed", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::IsDisplayed, "Returns true if Object is displayed in the interactive context.", py::arg("anIobj"));
cls_AIS_InteractiveContext.def("IsDisplayed", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer) const) &AIS_InteractiveContext::IsDisplayed, "None", py::arg("aniobj"), py::arg("aMode"));
cls_AIS_InteractiveContext.def("SetAutoActivateSelection", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::SetAutoActivateSelection, "Enable or disable automatic activation of default selection mode while displaying the object.", py::arg("theIsAuto"));
cls_AIS_InteractiveContext.def("GetAutoActivateSelection", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::GetAutoActivateSelection, "Manages displaying the new object should also automatically activate default selection mode; TRUE by default.");
cls_AIS_InteractiveContext.def("Display", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Display, "Displays the object in this Context using default Display Mode. This will be the object's default display mode, if there is one. Otherwise, it will be the context mode. The Interactive Object's default selection mode is activated if GetAutoActivateSelection() is TRUE. In general, this is 0.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Display", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1, const Standard_Integer a2, const Standard_Boolean a3) -> void { return self.Display(a0, a1, a2, a3); });
cls_AIS_InteractiveContext.def("Display", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1, const Standard_Integer a2, const Standard_Boolean a3, const Standard_Boolean a4) -> void { return self.Display(a0, a1, a2, a3, a4); });
cls_AIS_InteractiveContext.def("Display", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean, const AIS_DisplayStatus)) &AIS_InteractiveContext::Display, "Sets status, display mode and selection mode for specified Object If theSelectionMode equals -1, theIObj will not be activated: it will be displayed but will not be selectable.", py::arg("theIObj"), py::arg("theDispMode"), py::arg("theSelectionMode"), py::arg("theToUpdateViewer"), py::arg("theToAllowDecomposition"), py::arg("theDispStatus"));
cls_AIS_InteractiveContext.def("Load", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> void { return self.Load(a0); });
cls_AIS_InteractiveContext.def("Load", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1) -> void { return self.Load(a0, a1); });
cls_AIS_InteractiveContext.def("Load", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::Load, "Allows you to load the Interactive Object with a given selection mode, and/or with the desired decomposition option, whether the object is visualized or not. If AllowDecomp = Standard_True and, if the interactive object is of the 'Shape' type, these 'standard' selection modes will be automatically activated as a function of the modes present in the Local Context. The loaded objects will be selectable but displayable in highlighting only when detected by the Selector.", py::arg("aniobj"), py::arg("SelectionMode"), py::arg("AllowDecomp"));
cls_AIS_InteractiveContext.def("Erase", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Erase, "Hides the object. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show hidden objects, use Display().", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("EraseAll", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::EraseAll, "Hides all objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show all hidden objects, use DisplayAll().", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("DisplayAll", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::DisplayAll, "Displays all hidden objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("EraseSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::EraseSelected, "Hides selected objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing. To show hidden objects, use Display().", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("DisplaySelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::DisplaySelected, "Displays current objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ClearPrs", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::ClearPrs, "Empties the graphic presentation of the mode indexed by aMode. Warning! Removes theIObj. theIObj is still active if it was previously activated.", py::arg("theIObj"), py::arg("theMode"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Remove", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Remove, "Removes Object from every viewer.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("RemoveAll", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::RemoveAll, "Removes all the objects from Context.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Redisplay", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Boolean a1) -> void { return self.Redisplay(a0, a1); });
cls_AIS_InteractiveContext.def("Redisplay", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean, const Standard_Boolean)) &AIS_InteractiveContext::Redisplay, "Recomputes the seen parts presentation of the Object. If theAllModes equals true, all presentations are present in the object even if unseen.", py::arg("theIObj"), py::arg("theToUpdateViewer"), py::arg("theAllModes"));
cls_AIS_InteractiveContext.def("Redisplay", (void (AIS_InteractiveContext::*)(const AIS_KindOfInteractive, const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::Redisplay, "Recomputes the Prs/Selection of displayed objects of a given type and a given signature. if signature = -1 doesn't take signature criterion.", py::arg("theTypeOfObject"), py::arg("theSignature"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("RecomputePrsOnly", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Boolean a1) -> void { return self.RecomputePrsOnly(a0, a1); });
cls_AIS_InteractiveContext.def("RecomputePrsOnly", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean, const Standard_Boolean)) &AIS_InteractiveContext::RecomputePrsOnly, "Recomputes the displayed presentations, flags the others. Doesn't update presentations.", py::arg("theIObj"), py::arg("theToUpdateViewer"), py::arg("theAllModes"));
cls_AIS_InteractiveContext.def("RecomputeSelectionOnly", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::RecomputeSelectionOnly, "Recomputes the active selections, flags the others. Doesn't update presentations.", py::arg("anIObj"));
cls_AIS_InteractiveContext.def("Update", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Update, "Updates displayed interactive object by checking and recomputing its flagged as 'to be recomputed' presentation and selection structures. This method does not force any recomputation on its own. The method recomputes selections even if they are loaded without activation in particular selector.", py::arg("theIObj"), py::arg("theUpdateViewer"));
cls_AIS_InteractiveContext.def("HighlightStyle", (const opencascade::handle<Prs3d_Drawer> & (AIS_InteractiveContext::*)(const Prs3d_TypeOfHighlight) const) &AIS_InteractiveContext::HighlightStyle, "Returns highlight style settings.", py::arg("theStyleType"));
cls_AIS_InteractiveContext.def("SetHighlightStyle", (void (AIS_InteractiveContext::*)(const Prs3d_TypeOfHighlight, const opencascade::handle<Prs3d_Drawer> &)) &AIS_InteractiveContext::SetHighlightStyle, "Setup highlight style settings.", py::arg("theStyleType"), py::arg("theStyle"));
cls_AIS_InteractiveContext.def("HighlightStyle", (const opencascade::handle<Prs3d_Drawer> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HighlightStyle, "Returns current dynamic highlight style settings. By default: - the color of dynamic highlight is Quantity_NOC_CYAN1; - the presentation for dynamic highlight is completely opaque; - the type of highlight is Aspect_TOHM_COLOR.");
cls_AIS_InteractiveContext.def("SetHighlightStyle", (void (AIS_InteractiveContext::*)(const opencascade::handle<Prs3d_Drawer> &)) &AIS_InteractiveContext::SetHighlightStyle, "Setup the style of dynamic highlighting.", py::arg("theStyle"));
cls_AIS_InteractiveContext.def("SelectionStyle", (const opencascade::handle<Prs3d_Drawer> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SelectionStyle, "Returns current selection style settings. By default: - the color of selection is Quantity_NOC_GRAY80; - the presentation for selection is completely opaque; - the type of highlight is Aspect_TOHM_COLOR.");
cls_AIS_InteractiveContext.def("SetSelectionStyle", (void (AIS_InteractiveContext::*)(const opencascade::handle<Prs3d_Drawer> &)) &AIS_InteractiveContext::SetSelectionStyle, "Setup the style of selection highlighting.", py::arg("theStyle"));
cls_AIS_InteractiveContext.def("HighlightStyle", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, opencascade::handle<Prs3d_Drawer> &) const) &AIS_InteractiveContext::HighlightStyle, "Returns highlight style of the object if it is marked as highlighted via global status", py::arg("theObj"), py::arg("theStyle"));
cls_AIS_InteractiveContext.def("HighlightStyle", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &, opencascade::handle<Prs3d_Drawer> &) const) &AIS_InteractiveContext::HighlightStyle, "Returns highlight style of the owner if it is selected", py::arg("theOwner"), py::arg("theStyle"));
cls_AIS_InteractiveContext.def("IsHilighted", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::IsHilighted, "Returns true if the object is marked as highlighted via its global status", py::arg("theObj"));
cls_AIS_InteractiveContext.def("IsHilighted", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &) const) &AIS_InteractiveContext::IsHilighted, "Returns true if the owner is marked as selected", py::arg("theOwner"));
cls_AIS_InteractiveContext.def("Hilight", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Hilight, "Updates the display in the viewer to take dynamic detection into account. On dynamic detection by the mouse cursor, sensitive primitives are highlighted. The highlight color of entities detected by mouse movement is white by default.", py::arg("theObj"), py::arg("theIsToUpdateViewer"));
cls_AIS_InteractiveContext.def("HilightWithColor", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<Prs3d_Drawer> &, const Standard_Boolean)) &AIS_InteractiveContext::HilightWithColor, "Changes the color of all the lines of the object in view.", py::arg("theObj"), py::arg("theStyle"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Unhilight", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::Unhilight, "Removes hilighting from the Object.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("DisplayPriority", (Standard_Integer (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::DisplayPriority, "Returns the display priority of the Object.", py::arg("theIObj"));
cls_AIS_InteractiveContext.def("SetDisplayPriority", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer)) &AIS_InteractiveContext::SetDisplayPriority, "Sets the display priority of the seen parts presentation of the Object.", py::arg("theIObj"), py::arg("thePriority"));
cls_AIS_InteractiveContext.def("GetZLayer", (Graphic3d_ZLayerId (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::GetZLayer, "Get Z layer id set for displayed interactive object.", py::arg("theIObj"));
cls_AIS_InteractiveContext.def("SetZLayer", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Graphic3d_ZLayerId)) &AIS_InteractiveContext::SetZLayer, "Set Z layer id for interactive object. The Z layers can be used to display temporarily presentations of some object in front of the other objects in the scene. The ids for Z layers are generated by V3d_Viewer.", py::arg("theIObj"), py::arg("theLayerId"));
cls_AIS_InteractiveContext.def("SetViewAffinity", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::SetViewAffinity, "Setup object visibility in specified view. Has no effect if object is not displayed in this context.", py::arg("theIObj"), py::arg("theView"), py::arg("theIsVisible"));
cls_AIS_InteractiveContext.def("DisplayMode", (Standard_Integer (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DisplayMode, "Returns the Display Mode setting to be used by default.");
cls_AIS_InteractiveContext.def("SetDisplayMode", (void (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::SetDisplayMode, "Sets the display mode of seen Interactive Objects (which have no overridden Display Mode).", py::arg("theMode"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetDisplayMode", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::SetDisplayMode, "Sets the display mode of seen Interactive Objects. theMode provides the display mode index of the entity theIObj.", py::arg("theIObj"), py::arg("theMode"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetDisplayMode", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetDisplayMode, "Unsets the display mode of seen Interactive Objects.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetLocation", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const TopLoc_Location &)) &AIS_InteractiveContext::SetLocation, "Puts the location on the initial graphic representation and the selection for the Object.", py::arg("theObject"), py::arg("theLocation"));
cls_AIS_InteractiveContext.def("ResetLocation", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::ResetLocation, "Puts the Object back into its initial position.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("HasLocation", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::HasLocation, "Returns true if the Object has a location.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("Location", (TopLoc_Location (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::Location, "Returns the location of the Object.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("SetTransformPersistence", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<Graphic3d_TransformPers> &)) &AIS_InteractiveContext::SetTransformPersistence, "Sets transform persistence.", py::arg("theObject"), py::arg("theTrsfPers"));
cls_AIS_InteractiveContext.def("SetTransformPersistence", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Graphic3d_TransModeFlags & a1) -> void { return self.SetTransformPersistence(a0, a1); });
cls_AIS_InteractiveContext.def("SetTransformPersistence", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Graphic3d_TransModeFlags &, const gp_Pnt &)) &AIS_InteractiveContext::SetTransformPersistence, "None", py::arg("theObj"), py::arg("theFlag"), py::arg("thePoint"));
cls_AIS_InteractiveContext.def("SetPixelTolerance", [](AIS_InteractiveContext &self) -> void { return self.SetPixelTolerance(); });
cls_AIS_InteractiveContext.def("SetPixelTolerance", (void (AIS_InteractiveContext::*)(const Standard_Integer)) &AIS_InteractiveContext::SetPixelTolerance, "Setup pixel tolerance for MoveTo() operation.", py::arg("thePrecision"));
cls_AIS_InteractiveContext.def("PixelTolerance", (Standard_Integer (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::PixelTolerance, "Returns the pixel tolerance, default is 2. Pixel Tolerance extends sensitivity within MoveTo() operation (picking by point) and can be adjusted by application based on user input precision (e.g. screen pixel density, input device precision, etc.).");
cls_AIS_InteractiveContext.def("SetSelectionSensitivity", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Integer)) &AIS_InteractiveContext::SetSelectionSensitivity, "Allows to manage sensitivity of a particular selection of interactive object theObject and changes previous sensitivity value of all sensitive entities in selection with theMode to the given theNewSensitivity.", py::arg("theObject"), py::arg("theMode"), py::arg("theNewSensitivity"));
cls_AIS_InteractiveContext.def("MoveTo", (AIS_StatusOfDetection (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Integer, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::MoveTo, "Relays mouse position in pixels theXPix and theYPix to the interactive context selectors. This is done by the view theView passing this position to the main viewer and updating it. If theToRedrawOnUpdate is set to false, callee should call RedrawImmediate() to highlight detected object.", py::arg("theXPix"), py::arg("theYPix"), py::arg("theView"), py::arg("theToRedrawOnUpdate"));
cls_AIS_InteractiveContext.def("ClearDetected", [](AIS_InteractiveContext &self) -> Standard_Boolean { return self.ClearDetected(); });
cls_AIS_InteractiveContext.def("ClearDetected", (Standard_Boolean (AIS_InteractiveContext::*)(Standard_Boolean)) &AIS_InteractiveContext::ClearDetected, "Clears the list of entities detected by MoveTo() and resets dynamic highlighting.", py::arg("theToRedrawImmediate"));
cls_AIS_InteractiveContext.def("HasDetected", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasDetected, "Returns true if there is a mouse-detected entity in context.");
cls_AIS_InteractiveContext.def("DetectedOwner", (opencascade::handle<SelectMgr_EntityOwner> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedOwner, "Returns the owner of the detected sensitive primitive which is currently dynamically highlighted. WARNING! This method is irrelevant to InitDetected()/MoreDetected()/NextDetected().");
cls_AIS_InteractiveContext.def("DetectedInteractive", (opencascade::handle<AIS_InteractiveObject> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedInteractive, "Returns the interactive objects last detected in context. In general this is just a wrapper for Handle(AIS_InteractiveObject)::DownCast(DetectedOwner()->Selectable()).");
cls_AIS_InteractiveContext.def("HasDetectedShape", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasDetectedShape, "Returns true if there is a detected shape in local context.");
cls_AIS_InteractiveContext.def("DetectedShape", (const TopoDS_Shape & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedShape, "Returns the shape detected in local context.");
cls_AIS_InteractiveContext.def("HasNextDetected", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasNextDetected, "returns True if other entities were detected in the last mouse detection");
cls_AIS_InteractiveContext.def("HilightNextDetected", [](AIS_InteractiveContext &self, const opencascade::handle<V3d_View> & a0) -> Standard_Integer { return self.HilightNextDetected(a0); });
cls_AIS_InteractiveContext.def("HilightNextDetected", (Standard_Integer (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::HilightNextDetected, "If more than 1 object is detected by the selector, only the 'best' owner is hilighted at the mouse position. This Method allows the user to hilight one after another the other detected entities. If The method select is called, the selected entity will be the hilighted one! WARNING: Loop Method. When all the detected entities have been hilighted, the next call will hilight the first one again.", py::arg("theView"), py::arg("theToRedrawImmediate"));
cls_AIS_InteractiveContext.def("HilightPreviousDetected", [](AIS_InteractiveContext &self, const opencascade::handle<V3d_View> & a0) -> Standard_Integer { return self.HilightPreviousDetected(a0); });
cls_AIS_InteractiveContext.def("HilightPreviousDetected", (Standard_Integer (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::HilightPreviousDetected, "Same as previous methods in reverse direction.", py::arg("theView"), py::arg("theToRedrawImmediate"));
cls_AIS_InteractiveContext.def("InitDetected", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::InitDetected, "Initialization for iteration through mouse-detected objects in interactive context or in local context if it is opened.");
cls_AIS_InteractiveContext.def("MoreDetected", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::MoreDetected, "Return TRUE if there is more mouse-detected objects after the current one during iteration through mouse-detected interactive objects.");
cls_AIS_InteractiveContext.def("NextDetected", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NextDetected, "Gets next current object during iteration through mouse-detected interactive objects.");
cls_AIS_InteractiveContext.def("DetectedCurrentOwner", (opencascade::handle<SelectMgr_EntityOwner> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedCurrentOwner, "Returns the owner from detected list pointed by current iterator position. WARNING! This method is irrelevant to DetectedOwner() which returns last picked Owner regardless of iterator position!");
cls_AIS_InteractiveContext.def("SetSelectedAspect", (void (AIS_InteractiveContext::*)(const opencascade::handle<Prs3d_BasicAspect> &, const Standard_Boolean)) &AIS_InteractiveContext::SetSelectedAspect, "Sets the graphic basic aspect to the current presentation of ALL selected objects.", py::arg("theAspect"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("AddSelect", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &)) &AIS_InteractiveContext::AddSelect, "Adds object in the selection.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("AddSelect", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::AddSelect, "Adds object in the selection.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("Select", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::Select, "Selects everything found in the bounding rectangle defined by the pixel minima and maxima, XPMin, YPMin, XPMax, and YPMax in the view. The objects detected are passed to the main viewer, which is then updated.", py::arg("theXPMin"), py::arg("theYPMin"), py::arg("theXPMax"), py::arg("theYPMax"), py::arg("theView"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Select", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const TColgp_Array1OfPnt2d &, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::Select, "polyline selection; clears the previous picked list", py::arg("thePolyline"), py::arg("theView"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Select", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::Select, "Stores and hilights the previous detected; Unhilights the previous picked.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ShiftSelect", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::ShiftSelect, "Adds the last detected to the list of previous picked. If the last detected was already declared as picked, removes it from the Picked List.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ShiftSelect", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const TColgp_Array1OfPnt2d &, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::ShiftSelect, "Adds the last detected to the list of previous picked. If the last detected was already declared as picked, removes it from the Picked List.", py::arg("thePolyline"), py::arg("theView"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ShiftSelect", (AIS_StatusOfPick (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const opencascade::handle<V3d_View> &, const Standard_Boolean)) &AIS_InteractiveContext::ShiftSelect, "Rectangle of selection; adds new detected entities into the picked list, removes the detected entities that were already stored.", py::arg("theXPMin"), py::arg("theYPMin"), py::arg("theXPMax"), py::arg("theYPMax"), py::arg("theView"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("FitSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::FitSelected, "Fits the view correspondingly to the bounds of selected objects. Infinite objects are ignored if infinite state of AIS_InteractiveObject is set to true.", py::arg("theView"), py::arg("theMargin"), py::arg("theToUpdate"));
cls_AIS_InteractiveContext.def("FitSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &)) &AIS_InteractiveContext::FitSelected, "Fits the view correspondingly to the bounds of selected objects. Infinite objects are ignored if infinite state of AIS_InteractiveObject is set to true.", py::arg("theView"));
cls_AIS_InteractiveContext.def("SetToHilightSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::SetToHilightSelected, "Specify whether selected object must be hilighted when mouse cursor is moved above it (in MoveTo method). By default this value is false and selected object is not hilighted in this case.", py::arg("toHilight"));
cls_AIS_InteractiveContext.def("ToHilightSelected", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::ToHilightSelected, "Return value specified whether selected object must be hilighted when mouse cursor is moved above it");
cls_AIS_InteractiveContext.def("SetSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &, const Standard_Boolean)) &AIS_InteractiveContext::SetSelected, "Unhighlights previously selected owners and marks them as not selected. Marks owner given as selected and highlights it. Performs selection filters check.", py::arg("theOwners"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::SetSelected, "Puts the interactive object aniObj in the list of selected objects. Performs selection filters check.", py::arg("theObject"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("AddOrRemoveSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::AddOrRemoveSelected, "Allows to highlight or unhighlight the owner given depending on its selection status", py::arg("theObject"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("HilightSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::HilightSelected, "Highlights selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnhilightSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::UnhilightSelected, "Removes highlighting from selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UpdateSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::UpdateSelected, "Updates the list of selected objects: i.e. highlights the newly selected ones and unhighlights previously selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ClearSelected", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::ClearSelected, "Empties previous selected objects in order to get the selected objects detected by the selector using UpdateSelected.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("AddOrRemoveSelected", (void (AIS_InteractiveContext::*)(const TopoDS_Shape &, const Standard_Boolean)) &AIS_InteractiveContext::AddOrRemoveSelected, "No right to Add a selected Shape (Internal Management of shape Selection). A Previous selected shape may only be removed.", py::arg("theShape"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("AddOrRemoveSelected", (void (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &, const Standard_Boolean)) &AIS_InteractiveContext::AddOrRemoveSelected, "Allows to highlight or unhighlight the owner given depending on its selection status", py::arg("theOwner"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("IsSelected", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_EntityOwner> &) const) &AIS_InteractiveContext::IsSelected, "Returns true is the owner given is selected", py::arg("theOwner"));
cls_AIS_InteractiveContext.def("IsSelected", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::IsSelected, "Returns true is the object given is selected", py::arg("theObj"));
cls_AIS_InteractiveContext.def("FirstSelectedObject", (opencascade::handle<AIS_InteractiveObject> (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::FirstSelectedObject, "Returns the first selected object in the list of current selected.");
cls_AIS_InteractiveContext.def("NbSelected", (Standard_Integer (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NbSelected, "Count a number of selected entities using InitSelected()+MoreSelected()+NextSelected() iterator.");
cls_AIS_InteractiveContext.def("InitSelected", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::InitSelected, "Initializes a scan of the selected objects.");
cls_AIS_InteractiveContext.def("MoreSelected", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::MoreSelected, "Returns true if there is another object found by the scan of the list of selected objects.");
cls_AIS_InteractiveContext.def("NextSelected", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NextSelected, "Continues the scan to the next object in the list of selected objects.");
cls_AIS_InteractiveContext.def("SelectedOwner", (opencascade::handle<SelectMgr_EntityOwner> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SelectedOwner, "Returns the owner of the selected entity.");
cls_AIS_InteractiveContext.def("SelectedInteractive", (opencascade::handle<AIS_InteractiveObject> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SelectedInteractive, "Return Handle(AIS_InteractiveObject)::DownCast (SelectedOwner()->Selectable()).");
cls_AIS_InteractiveContext.def("HasSelectedShape", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasSelectedShape, "Returns TRUE if the interactive context has a shape selected.");
cls_AIS_InteractiveContext.def("SelectedShape", (TopoDS_Shape (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SelectedShape, "Returns the selected shape. Basically it is just a shape returned stored by StdSelect_BRepOwner with graphic transformation being applied:");
cls_AIS_InteractiveContext.def("HasApplicative", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasApplicative, "Returns SelectedInteractive()->HasOwner().");
cls_AIS_InteractiveContext.def("Applicative", (opencascade::handle<Standard_Transient> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::Applicative, "Returns SelectedInteractive()->GetOwner().");
cls_AIS_InteractiveContext.def("BeginImmediateDraw", (Standard_Boolean (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::BeginImmediateDraw, "initializes the list of presentations to be displayed returns False if no local context is opened.");
cls_AIS_InteractiveContext.def("ImmediateAdd", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> Standard_Boolean { return self.ImmediateAdd(a0); });
cls_AIS_InteractiveContext.def("ImmediateAdd", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer)) &AIS_InteractiveContext::ImmediateAdd, "returns True if <anIObj> has been stored in the list.", py::arg("theObj"), py::arg("theMode"));
cls_AIS_InteractiveContext.def("EndImmediateDraw", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &)) &AIS_InteractiveContext::EndImmediateDraw, "returns True if the immediate display has been done.", py::arg("theView"));
cls_AIS_InteractiveContext.def("EndImmediateDraw", (Standard_Boolean (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::EndImmediateDraw, "Uses the First Active View of Main Viewer! returns True if the immediate display has been done.");
cls_AIS_InteractiveContext.def("IsImmediateModeOn", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::IsImmediateModeOn, "None");
cls_AIS_InteractiveContext.def("RedrawImmediate", (void (AIS_InteractiveContext::*)(const opencascade::handle<V3d_Viewer> &)) &AIS_InteractiveContext::RedrawImmediate, "Redraws immediate structures in all views of the viewer given taking into account its visibility.", py::arg("theViewer"));
cls_AIS_InteractiveContext.def("SetSelectionModeActive", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1, const Standard_Boolean a2) -> void { return self.SetSelectionModeActive(a0, a1, a2); });
cls_AIS_InteractiveContext.def("SetSelectionModeActive", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1, const Standard_Boolean a2, const AIS_SelectionModesConcurrency a3) -> void { return self.SetSelectionModeActive(a0, a1, a2, a3); });
cls_AIS_InteractiveContext.def("SetSelectionModeActive", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Boolean, const AIS_SelectionModesConcurrency, const Standard_Boolean)) &AIS_InteractiveContext::SetSelectionModeActive, "Activates or deactivates the selection mode for specified object. Has no effect if selection mode was already active/deactivated.", py::arg("theObj"), py::arg("theMode"), py::arg("theToActivate"), py::arg("theConcurrency"), py::arg("theIsForce"));
cls_AIS_InteractiveContext.def("Activate", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> void { return self.Activate(a0); });
cls_AIS_InteractiveContext.def("Activate", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0, const Standard_Integer a1) -> void { return self.Activate(a0, a1); });
cls_AIS_InteractiveContext.def("Activate", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::Activate, "Activates the selection mode aMode whose index is given, for the given interactive entity anIobj.", py::arg("theObj"), py::arg("theMode"), py::arg("theIsForce"));
cls_AIS_InteractiveContext.def("Activate", [](AIS_InteractiveContext &self, const Standard_Integer a0) -> void { return self.Activate(a0); });
cls_AIS_InteractiveContext.def("Activate", (void (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::Activate, "Activates the given selection mode for the all displayed objects.", py::arg("theMode"), py::arg("theIsForce"));
cls_AIS_InteractiveContext.def("Deactivate", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::Deactivate, "Deactivates all the activated selection modes of an object.", py::arg("theObj"));
cls_AIS_InteractiveContext.def("Deactivate", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer)) &AIS_InteractiveContext::Deactivate, "Deactivates all the activated selection modes of the interactive object anIobj with a given selection mode aMode.", py::arg("theObj"), py::arg("theMode"));
cls_AIS_InteractiveContext.def("Deactivate", (void (AIS_InteractiveContext::*)(const Standard_Integer)) &AIS_InteractiveContext::Deactivate, "Deactivates the given selection mode for all displayed objects.", py::arg("theMode"));
cls_AIS_InteractiveContext.def("Deactivate", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::Deactivate, "Deactivates all the activated selection mode at all displayed objects.");
cls_AIS_InteractiveContext.def("ActivatedModes", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, TColStd_ListOfInteger &) const) &AIS_InteractiveContext::ActivatedModes, "Returns the list of activated selection modes.", py::arg("anIobj"), py::arg("theList"));
cls_AIS_InteractiveContext.def("EntityOwners", [](AIS_InteractiveContext &self, opencascade::handle<SelectMgr_IndexedMapOfOwner> & a0, const opencascade::handle<AIS_InteractiveObject> & a1) -> void { return self.EntityOwners(a0, a1); });
cls_AIS_InteractiveContext.def("EntityOwners", (void (AIS_InteractiveContext::*)(opencascade::handle<SelectMgr_IndexedMapOfOwner> &, const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer) const) &AIS_InteractiveContext::EntityOwners, "Returns a collection containing all entity owners created for the interactive object in specified selection mode (in all active modes if the Mode == -1)", py::arg("theOwners"), py::arg("theIObj"), py::arg("theMode"));
cls_AIS_InteractiveContext.def("Filters", (const SelectMgr_ListOfFilter & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::Filters, "Returns the list of filters active in a local context.");
cls_AIS_InteractiveContext.def("AddFilter", (void (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_Filter> &)) &AIS_InteractiveContext::AddFilter, "Allows you to add the filter.", py::arg("theFilter"));
cls_AIS_InteractiveContext.def("RemoveFilter", (void (AIS_InteractiveContext::*)(const opencascade::handle<SelectMgr_Filter> &)) &AIS_InteractiveContext::RemoveFilter, "Removes a filter from context.", py::arg("theFilter"));
cls_AIS_InteractiveContext.def("RemoveFilters", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::RemoveFilters, "Remove all filters from context.");
cls_AIS_InteractiveContext.def("PickingStrategy", (SelectMgr_PickingStrategy (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::PickingStrategy, "Return picking strategy; SelectMgr_PickingStrategy_FirstAcceptable by default.");
cls_AIS_InteractiveContext.def("SetPickingStrategy", (void (AIS_InteractiveContext::*)(const SelectMgr_PickingStrategy)) &AIS_InteractiveContext::SetPickingStrategy, "Setup picking strategy - which entities detected by picking line will be accepted, considering Selection Filters. By default (SelectMgr_PickingStrategy_FirstAcceptable), Selection Filters reduce the list of entities so that the context accepts topmost in remaining.", py::arg("theStrategy"));
cls_AIS_InteractiveContext.def("DefaultDrawer", (const opencascade::handle<Prs3d_Drawer> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DefaultDrawer, "Returns the default attribute manager. This contains all the color and line attributes which can be used by interactive objects which do not have their own attributes.");
cls_AIS_InteractiveContext.def("CurrentViewer", (const opencascade::handle<V3d_Viewer> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::CurrentViewer, "Returns the current viewer.");
cls_AIS_InteractiveContext.def("SelectionManager", (const opencascade::handle<SelectMgr_SelectionManager> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SelectionManager, "None");
cls_AIS_InteractiveContext.def("MainPrsMgr", (const opencascade::handle<PrsMgr_PresentationManager3d> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::MainPrsMgr, "None");
cls_AIS_InteractiveContext.def("MainSelector", (const opencascade::handle<StdSelect_ViewerSelector3d> & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::MainSelector, "None");
cls_AIS_InteractiveContext.def("UpdateCurrentViewer", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::UpdateCurrentViewer, "Updates the current viewer.");
cls_AIS_InteractiveContext.def("DisplayedObjects", [](AIS_InteractiveContext &self, AIS_ListOfInteractive & a0) -> void { return self.DisplayedObjects(a0); });
cls_AIS_InteractiveContext.def("DisplayedObjects", (void (AIS_InteractiveContext::*)(AIS_ListOfInteractive &, const Standard_Boolean) const) &AIS_InteractiveContext::DisplayedObjects, "Returns the list of displayed objects of a particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals -1. This means that there is a check on type only.", py::arg("aListOfIO"), py::arg("OnlyFromNeutral"));
cls_AIS_InteractiveContext.def("DisplayedObjects", [](AIS_InteractiveContext &self, const AIS_KindOfInteractive a0, const Standard_Integer a1, AIS_ListOfInteractive & a2) -> void { return self.DisplayedObjects(a0, a1, a2); });
cls_AIS_InteractiveContext.def("DisplayedObjects", (void (AIS_InteractiveContext::*)(const AIS_KindOfInteractive, const Standard_Integer, AIS_ListOfInteractive &, const Standard_Boolean) const) &AIS_InteractiveContext::DisplayedObjects, "gives the list of displayed objects of a particular Type and signature. by Default, <WhichSignature> = -1 means control only on <WhichKind>.", py::arg("WhichKind"), py::arg("WhichSignature"), py::arg("aListOfIO"), py::arg("OnlyFromNeutral"));
cls_AIS_InteractiveContext.def("ErasedObjects", (void (AIS_InteractiveContext::*)(AIS_ListOfInteractive &) const) &AIS_InteractiveContext::ErasedObjects, "Returns the list theListOfIO of erased objects (hidden objects) particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals 1. This means that there is a check on type only.", py::arg("theListOfIO"));
cls_AIS_InteractiveContext.def("ErasedObjects", (void (AIS_InteractiveContext::*)(const AIS_KindOfInteractive, const Standard_Integer, AIS_ListOfInteractive &) const) &AIS_InteractiveContext::ErasedObjects, "gives the list of erased objects (hidden objects) Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.", py::arg("WhichKind"), py::arg("WhichSignature"), py::arg("theListOfIO"));
cls_AIS_InteractiveContext.def("ObjectsByDisplayStatus", (void (AIS_InteractiveContext::*)(const AIS_DisplayStatus, AIS_ListOfInteractive &) const) &AIS_InteractiveContext::ObjectsByDisplayStatus, "Returns the list theListOfIO of objects with indicated display status particular Type WhichKind and Signature WhichSignature. By Default, WhichSignature equals 1. This means that there is a check on type only.", py::arg("theStatus"), py::arg("theListOfIO"));
cls_AIS_InteractiveContext.def("ObjectsByDisplayStatus", (void (AIS_InteractiveContext::*)(const AIS_KindOfInteractive, const Standard_Integer, const AIS_DisplayStatus, AIS_ListOfInteractive &) const) &AIS_InteractiveContext::ObjectsByDisplayStatus, "gives the list of objects with indicated display status Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.", py::arg("WhichKind"), py::arg("WhichSignature"), py::arg("theStatus"), py::arg("theListOfIO"));
cls_AIS_InteractiveContext.def("ObjectsInside", [](AIS_InteractiveContext &self, AIS_ListOfInteractive & a0) -> void { return self.ObjectsInside(a0); });
cls_AIS_InteractiveContext.def("ObjectsInside", [](AIS_InteractiveContext &self, AIS_ListOfInteractive & a0, const AIS_KindOfInteractive a1) -> void { return self.ObjectsInside(a0, a1); });
cls_AIS_InteractiveContext.def("ObjectsInside", (void (AIS_InteractiveContext::*)(AIS_ListOfInteractive &, const AIS_KindOfInteractive, const Standard_Integer) const) &AIS_InteractiveContext::ObjectsInside, "fills <aListOfIO> with objects of a particular Type and Signature with no consideration of display status. by Default, <WhichSignature> = -1 means control only on <WhichKind>. if <WhichKind> = AIS_KOI_None and <WhichSignature> = -1, all the objects are put into the list.", py::arg("aListOfIO"), py::arg("WhichKind"), py::arg("WhichSignature"));
cls_AIS_InteractiveContext.def("RebuildSelectionStructs", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::RebuildSelectionStructs, "Rebuilds 1st level of BVH selection forcibly");
cls_AIS_InteractiveContext.def("Disconnect", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> void { return self.Disconnect(a0); });
cls_AIS_InteractiveContext.def("Disconnect", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::Disconnect, "Disconnects theObjToDisconnect from theAssembly and removes dependent selection structures", py::arg("theAssembly"), py::arg("theObjToDisconnect"));
cls_AIS_InteractiveContext.def("ObjectsForView", [](AIS_InteractiveContext &self, AIS_ListOfInteractive & a0, const opencascade::handle<V3d_View> & a1, const Standard_Boolean a2) -> void { return self.ObjectsForView(a0, a1, a2); });
cls_AIS_InteractiveContext.def("ObjectsForView", (void (AIS_InteractiveContext::*)(AIS_ListOfInteractive &, const opencascade::handle<V3d_View> &, const Standard_Boolean, const AIS_DisplayStatus) const) &AIS_InteractiveContext::ObjectsForView, "Query objects visible or hidden in specified view due to affinity mask.", py::arg("theListOfIO"), py::arg("theView"), py::arg("theIsVisibleInView"), py::arg("theStatus"));
cls_AIS_InteractiveContext.def("PurgeDisplay", (Standard_Integer (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::PurgeDisplay, "Clears all the structures which don't belong to objects displayed at neutral point only effective when no Local Context is opened... returns the number of removed structures from the viewers.");
cls_AIS_InteractiveContext.def("DisplayActiveSensitive", (void (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &)) &AIS_InteractiveContext::DisplayActiveSensitive, "Visualization of sensitives - for debugging purposes!", py::arg("aView"));
cls_AIS_InteractiveContext.def("ClearActiveSensitive", (void (AIS_InteractiveContext::*)(const opencascade::handle<V3d_View> &)) &AIS_InteractiveContext::ClearActiveSensitive, "Clear visualization of sensitives.", py::arg("aView"));
cls_AIS_InteractiveContext.def("DisplayActiveSensitive", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<V3d_View> &)) &AIS_InteractiveContext::DisplayActiveSensitive, "Visualization of sensitives - for debugging purposes!", py::arg("anObject"), py::arg("aView"));
cls_AIS_InteractiveContext.def("SetLocalAttributes", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<Prs3d_Drawer> &, const Standard_Boolean)) &AIS_InteractiveContext::SetLocalAttributes, "Sets the graphic attributes of the interactive object, such as visualization mode, color, and material.", py::arg("theIObj"), py::arg("theDrawer"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetLocalAttributes", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetLocalAttributes, "Removes the settings for local attributes of the Object and returns to defaults.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetCurrentFacingModel", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> void { return self.SetCurrentFacingModel(a0); });
cls_AIS_InteractiveContext.def("SetCurrentFacingModel", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Aspect_TypeOfFacingModel)) &AIS_InteractiveContext::SetCurrentFacingModel, "change the current facing model apply on polygons for SetColor(), SetTransparency(), SetMaterial() methods default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is applying both on the front and back face.", py::arg("aniobj"), py::arg("aModel"));
cls_AIS_InteractiveContext.def("HasColor", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::HasColor, "Returns true if a view of the Interactive Object has color.", py::arg("aniobj"));
cls_AIS_InteractiveContext.def("Color", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, Quantity_Color &) const) &AIS_InteractiveContext::Color, "Returns the color of the Object in the interactive context.", py::arg("aniobj"), py::arg("acolor"));
cls_AIS_InteractiveContext.def("SetColor", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Quantity_Color &, const Standard_Boolean)) &AIS_InteractiveContext::SetColor, "Sets the color of the selected entity.", py::arg("theIObj"), py::arg("theColor"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetColor", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetColor, "Removes the color selection for the selected entity.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("Width", (Standard_Real (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::Width, "Returns the width of the Interactive Object in the interactive context.", py::arg("aniobj"));
cls_AIS_InteractiveContext.def("SetWidth", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetWidth, "Sets the width of the Object.", py::arg("theIObj"), py::arg("theValue"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetWidth", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetWidth, "Removes the width setting of the Object.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetMaterial", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Graphic3d_MaterialAspect &, const Standard_Boolean)) &AIS_InteractiveContext::SetMaterial, "Provides the type of material setting for the view of the Object.", py::arg("theIObj"), py::arg("theMaterial"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetMaterial", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetMaterial, "Removes the type of material setting for viewing the Object.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetTransparency", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetTransparency, "Provides the transparency settings for viewing the Object. The transparency value aValue may be between 0.0, opaque, and 1.0, fully transparent.", py::arg("theIObj"), py::arg("theValue"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnsetTransparency", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::UnsetTransparency, "Removes the transparency settings for viewing the Object.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetPolygonOffsets", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer, const Standard_ShortReal, const Standard_ShortReal, const Standard_Boolean)) &AIS_InteractiveContext::SetPolygonOffsets, "Sets up polygon offsets for the given AIS_InteractiveObject. It simply calls AIS_InteractiveObject::SetPolygonOffsets().", py::arg("theIObj"), py::arg("theMode"), py::arg("theFactor"), py::arg("theUnits"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("HasPolygonOffsets", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::HasPolygonOffsets, "Simply calls AIS_InteractiveObject::HasPolygonOffsets().", py::arg("anObj"));
cls_AIS_InteractiveContext.def("PolygonOffsets", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & anObj, Standard_Integer & aMode, Standard_ShortReal & aFactor, Standard_ShortReal & aUnits){ self.PolygonOffsets(anObj, aMode, aFactor, aUnits); return aMode; }, "Retrieves current polygon offsets settings for Object.", py::arg("anObj"), py::arg("aMode"), py::arg("aFactor"), py::arg("aUnits"));
cls_AIS_InteractiveContext.def("SetTrihedronSize", (void (AIS_InteractiveContext::*)(const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetTrihedronSize, "Sets the size aSize of the trihedron. Is used to change the default value 100 mm for display of trihedra. Use of this function in one of your own interactive objects requires a call to the Compute function of the new class. This will recalculate the presentation for every trihedron displayed.", py::arg("theSize"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("TrihedronSize", (Standard_Real (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::TrihedronSize, "returns the current value of trihedron size.");
cls_AIS_InteractiveContext.def("SetPlaneSize", (void (AIS_InteractiveContext::*)(const Standard_Real, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetPlaneSize, "Sets the plane size defined by the length in the X direction XSize and that in the Y direction YSize.", py::arg("theSizeX"), py::arg("theSizeY"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetPlaneSize", (void (AIS_InteractiveContext::*)(const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetPlaneSize, "Sets the plane size aSize.", py::arg("theSize"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("PlaneSize", [](AIS_InteractiveContext &self, Standard_Real & XSize, Standard_Real & YSize){ Standard_Boolean rv = self.PlaneSize(XSize, YSize); return std::tuple<Standard_Boolean, Standard_Real &, Standard_Real &>(rv, XSize, YSize); }, "Returns true if the length in the X direction XSize is the same as that in the Y direction YSize.", py::arg("XSize"), py::arg("YSize"));
cls_AIS_InteractiveContext.def("SetDeviationCoefficient", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetDeviationCoefficient, "Sets the deviation coefficient theCoefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient theCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through the method: SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient.", py::arg("theIObj"), py::arg("theCoefficient"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetDeviationAngle", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetDeviationAngle, "None", py::arg("theIObj"), py::arg("theAngle"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetAngleAndDeviation", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetAngleAndDeviation, "Calls the AIS_Shape SetAngleAndDeviation to set both Angle and Deviation coefficients", py::arg("theIObj"), py::arg("theAngle"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetHLRDeviationCoefficient", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetHLRDeviationCoefficient, "Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations. The Default value is 0.02.", py::arg("theIObj"), py::arg("theCoefficient"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetHLRDeviationAngle", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetHLRDeviationAngle, "None", py::arg("theIObj"), py::arg("theAngle"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetHLRAngleAndDeviation", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Real, const Standard_Boolean)) &AIS_InteractiveContext::SetHLRAngleAndDeviation, "Computes a HLRAngle and a HLRDeviationCoefficient by means of the angle anAngle and sets the corresponding methods in the default drawing tool with these values.", py::arg("theIObj"), py::arg("theAngle"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SetDeviationCoefficient", (void (AIS_InteractiveContext::*)(const Standard_Real)) &AIS_InteractiveContext::SetDeviationCoefficient, "Sets the deviation coefficient theCoefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient theCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through the method: SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient.", py::arg("theCoefficient"));
cls_AIS_InteractiveContext.def("DeviationCoefficient", (Standard_Real (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DeviationCoefficient, "Returns the deviation coefficient. Drawings of curves or patches are made with respect to a maximal chordal deviation. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. This deviation is absolute and is set through Prs3d_Drawer::SetMaximalChordialDeviation. The default value is 0.001. In drawing shapes, however, you are allowed to ask for a relative deviation. This deviation will be: SizeOfObject * DeviationCoefficient.");
cls_AIS_InteractiveContext.def("SetDeviationAngle", (void (AIS_InteractiveContext::*)(const Standard_Real)) &AIS_InteractiveContext::SetDeviationAngle, "default 12 degrees", py::arg("anAngle"));
cls_AIS_InteractiveContext.def("DeviationAngle", (Standard_Real (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DeviationAngle, "None");
cls_AIS_InteractiveContext.def("SetHLRDeviationCoefficient", (void (AIS_InteractiveContext::*)(const Standard_Real)) &AIS_InteractiveContext::SetHLRDeviationCoefficient, "Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations. The Default value is 0.02.", py::arg("aCoefficient"));
cls_AIS_InteractiveContext.def("HLRDeviationCoefficient", (Standard_Real (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HLRDeviationCoefficient, "Returns the real number value of the hidden line removal deviation coefficient. A Deviation coefficient is used in the shading display mode. The shape is seen decomposed into triangles. These are used to calculate reflection of light from the surface of the object. The triangles are formed from chords of the curves in the shape. The deviation coefficient give the highest value of the angle with which a chord can deviate from a tangent to a curve. If this limit is reached, a new triangle is begun. To find the hidden lines, hidden line display mode entails recalculation of the view at each different projector perspective. Because hidden lines entail calculations of more than usual complexity to decompose them into these triangles, a deviation coefficient allowing greater tolerance is used. This increases efficiency in calculation. The Default value is 0.02.");
cls_AIS_InteractiveContext.def("SetHLRAngle", (void (AIS_InteractiveContext::*)(const Standard_Real)) &AIS_InteractiveContext::SetHLRAngle, "Sets the HLR angle.", py::arg("theAngle"));
cls_AIS_InteractiveContext.def("HLRAngle", (Standard_Real (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HLRAngle, "Returns the real number value of the deviation angle in hidden line removal views in this interactive context. The default value is 20*PI/180.");
cls_AIS_InteractiveContext.def("SetHLRAngleAndDeviation", (void (AIS_InteractiveContext::*)(const Standard_Real)) &AIS_InteractiveContext::SetHLRAngleAndDeviation, "compute with theAngle a HLRAngle and a HLRDeviationCoefficient and set them in myHLRAngle and in myHLRDeviationCoefficient of myDefaultDrawer; theAngle is in radian; ( 1 deg < angle in deg < 20 deg)", py::arg("theAngle"));
cls_AIS_InteractiveContext.def("HiddenLineAspect", (opencascade::handle<Prs3d_LineAspect> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HiddenLineAspect, "Initializes hidden line aspect in the default drawing tool, or Drawer. The default values are: Color: Quantity_NOC_YELLOW Type of line: Aspect_TOL_DASH Width: 1.");
cls_AIS_InteractiveContext.def("SetHiddenLineAspect", (void (AIS_InteractiveContext::*)(const opencascade::handle<Prs3d_LineAspect> &) const) &AIS_InteractiveContext::SetHiddenLineAspect, "Sets the hidden line aspect anAspect. Aspect defines display attributes for hidden lines in HLR projections.", py::arg("anAspect"));
cls_AIS_InteractiveContext.def("DrawHiddenLine", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DrawHiddenLine, "returns Standard_True if the hidden lines are to be drawn. By default the hidden lines are not drawn.");
cls_AIS_InteractiveContext.def("EnableDrawHiddenLine", (void (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::EnableDrawHiddenLine, "None");
cls_AIS_InteractiveContext.def("DisableDrawHiddenLine", (void (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DisableDrawHiddenLine, "None");
cls_AIS_InteractiveContext.def("SetIsoNumber", [](AIS_InteractiveContext &self, const Standard_Integer a0) -> void { return self.SetIsoNumber(a0); });
cls_AIS_InteractiveContext.def("SetIsoNumber", (void (AIS_InteractiveContext::*)(const Standard_Integer, const AIS_TypeOfIso)) &AIS_InteractiveContext::SetIsoNumber, "Sets the number of U and V isoparameters displayed.", py::arg("NbIsos"), py::arg("WhichIsos"));
cls_AIS_InteractiveContext.def("IsoNumber", [](AIS_InteractiveContext &self) -> Standard_Integer { return self.IsoNumber(); });
cls_AIS_InteractiveContext.def("IsoNumber", (Standard_Integer (AIS_InteractiveContext::*)(const AIS_TypeOfIso)) &AIS_InteractiveContext::IsoNumber, "Returns the number of U and V isoparameters displayed.", py::arg("WhichIsos"));
cls_AIS_InteractiveContext.def("IsoOnPlane", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::IsoOnPlane, "Returns True if drawing isoparameters on planes is enabled.", py::arg("SwitchOn"));
cls_AIS_InteractiveContext.def("IsoOnPlane", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::IsoOnPlane, "Returns True if drawing isoparameters on planes is enabled. if <forUIsos> = False,");
cls_AIS_InteractiveContext.def("IsoOnTriangulation", (void (AIS_InteractiveContext::*)(const Standard_Boolean, const opencascade::handle<AIS_InteractiveObject> &)) &AIS_InteractiveContext::IsoOnTriangulation, "Enables or disables on-triangulation build for isolines for a particular object. In case if on-triangulation builder is disabled, default on-plane builder will compute isolines for the object given.", py::arg("theIsEnabled"), py::arg("theObject"));
cls_AIS_InteractiveContext.def("IsoOnTriangulation", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::IsoOnTriangulation, "Enables or disables on-triangulation build for isolines for default drawer. In case if on-triangulation builder is disabled, default on-plane builder will compute isolines for the object given.", py::arg("theToSwitchOn"));
cls_AIS_InteractiveContext.def("IsoOnTriangulation", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::IsoOnTriangulation, "Returns true if drawing isolines on triangulation algorithm is enabled.");
cls_AIS_InteractiveContext.def("HasOpenedContext", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HasOpenedContext, "Returns true if there is an open context.");
cls_AIS_InteractiveContext.def("HighestIndex", (Standard_Integer (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::HighestIndex, "None");
cls_AIS_InteractiveContext.def("LocalContext", (opencascade::handle<AIS_LocalContext> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::LocalContext, "For advanced usage! You should use other (non-internal) methods of class AIS_InteractiveContext without trying to obtain an instance of AIS_LocalContext.");
cls_AIS_InteractiveContext.def("LocalSelector", (opencascade::handle<StdSelect_ViewerSelector3d> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::LocalSelector, "None");
cls_AIS_InteractiveContext.def("OpenLocalContext", [](AIS_InteractiveContext &self) -> Standard_Integer { return self.OpenLocalContext(); });
cls_AIS_InteractiveContext.def("OpenLocalContext", [](AIS_InteractiveContext &self, const Standard_Boolean a0) -> Standard_Integer { return self.OpenLocalContext(a0); });
cls_AIS_InteractiveContext.def("OpenLocalContext", [](AIS_InteractiveContext &self, const Standard_Boolean a0, const Standard_Boolean a1) -> Standard_Integer { return self.OpenLocalContext(a0, a1); });
cls_AIS_InteractiveContext.def("OpenLocalContext", [](AIS_InteractiveContext &self, const Standard_Boolean a0, const Standard_Boolean a1, const Standard_Boolean a2) -> Standard_Integer { return self.OpenLocalContext(a0, a1, a2); });
cls_AIS_InteractiveContext.def("OpenLocalContext", (Standard_Integer (AIS_InteractiveContext::*)(const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &AIS_InteractiveContext::OpenLocalContext, "Opens local contexts and specifies how this is to be done. The options listed above function in the following manner: - UseDisplayedObjects - allows you to load or not load the interactive objects visualized at Neutral Point in the local context which you open. If false, the local context is empty after being opened. If true, the objects at Neutral Point are loaded by their default selection mode. - AllowShapeDecomposition - AIS_Shape allows or prevents decomposition in standard shape location mode of objects at Neutral Point which are type-'privileged'. This Flag is only taken into account when UseDisplayedObjects is true. - AcceptEraseOfObjects - authorises other local contexts to erase the interactive objects present in this context. This option is rarely used. - BothViewers - Has no use currently defined. This method returns the index of the created local context. It should be kept and used to close the context. Opening a local context allows you to prepare an environment for temporary presentations and selections which will disappear once the local context is closed. You can open several local contexts, but only the last one will be active.", py::arg("UseDisplayedObjects"), py::arg("AllowShapeDecomposition"), py::arg("AcceptEraseOfObjects"), py::arg("BothViewers"));
cls_AIS_InteractiveContext.def("CloseLocalContext", [](AIS_InteractiveContext &self) -> void { return self.CloseLocalContext(); });
cls_AIS_InteractiveContext.def("CloseLocalContext", [](AIS_InteractiveContext &self, const Standard_Integer a0) -> void { return self.CloseLocalContext(a0); });
cls_AIS_InteractiveContext.def("CloseLocalContext", (void (AIS_InteractiveContext::*)(const Standard_Integer, const Standard_Boolean)) &AIS_InteractiveContext::CloseLocalContext, "Allows you to close local contexts. For greater security, you should close the context with the index Index given on opening. When you close a local context, the one before, which is still on the stack, reactivates. If none is left, you return to Neutral Point. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated. Warning When the index isn't specified, the current context is closed. This option can be dangerous, as other Interactive Functions can open local contexts without necessarily warning the user.", py::arg("theIndex"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("IndexOfCurrentLocal", (Standard_Integer (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::IndexOfCurrentLocal, "returns -1 if no opened local context.");
cls_AIS_InteractiveContext.def("CloseAllContexts", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::CloseAllContexts, "Allows you to close all local contexts at one go and return to Neutral Point. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ResetOriginalState", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::ResetOriginalState, "to be used only with no opened local context.. displays and activates objects in their original state before local contexts were opened...", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ClearLocalContext", [](AIS_InteractiveContext &self) -> void { return self.ClearLocalContext(); });
cls_AIS_InteractiveContext.def("ClearLocalContext", (void (AIS_InteractiveContext::*)(const AIS_ClearMode)) &AIS_InteractiveContext::ClearLocalContext, "clears Objects/Filters/Activated Modes list in the current opened local context.", py::arg("TheMode"));
cls_AIS_InteractiveContext.def("UseDisplayedObjects", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::UseDisplayedObjects, "None");
cls_AIS_InteractiveContext.def("NotUseDisplayedObjects", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NotUseDisplayedObjects, "when a local Context is opened, one is able to use/not use the displayed objects at neutral point at anytime.");
cls_AIS_InteractiveContext.def("SetShapeDecomposition", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::SetShapeDecomposition, "to be Used only with opened local context and if <anIobj> is of type shape... if <aStatus> = True <anIobj> will be sensitive to shape selection modes activation. = False, <anIobj> will not be sensitive any more.", py::arg("anIobj"), py::arg("aStatus"));
cls_AIS_InteractiveContext.def("SetTemporaryAttributes", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const opencascade::handle<Prs3d_Drawer> &, const Standard_Boolean)) &AIS_InteractiveContext::SetTemporaryAttributes, "Sets the temporary graphic attributes of the entity anObj. These are provided by the attribute manager aDrawer and are valid for a particular local context only. If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode; the object is displayed but no viewer will be updated.", py::arg("theIObj"), py::arg("theDrawer"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ActivateStandardMode", (void (AIS_InteractiveContext::*)(const TopAbs_ShapeEnum)) &AIS_InteractiveContext::ActivateStandardMode, "Provides an alternative to the Display methods when activating specific selection modes. This has the effect of activating the corresponding selection mode aStandardActivation for all objects in Local Context which accept decomposition into sub-shapes. Every new Object which has been loaded into the interactive context and which answers these decomposition criteria is automatically activated according to these modes. Warning If you have opened a local context by loading an object with the default options (<AllowShapeDecomposition >= Standard_True), all objects of the 'Shape' type are also activated with the same modes. You can act on the state of these 'Standard' objects by using SetShapeDecomposition(Status).", py::arg("aStandardActivation"));
cls_AIS_InteractiveContext.def("DeactivateStandardMode", (void (AIS_InteractiveContext::*)(const TopAbs_ShapeEnum)) &AIS_InteractiveContext::DeactivateStandardMode, "Provides an alternative to the Display methods when deactivating specific selection modes. This has the effect of deactivating the corresponding selection mode aStandardActivation for all objects in Local Context which accept decomposition into sub-shapes.", py::arg("aStandardActivation"));
cls_AIS_InteractiveContext.def("ActivatedStandardModes", (const TColStd_ListOfInteger & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::ActivatedStandardModes, "None");
cls_AIS_InteractiveContext.def("IsInLocal", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & anObject, Standard_Integer & TheIndex){ Standard_Boolean rv = self.IsInLocal(anObject, TheIndex); return std::tuple<Standard_Boolean, Standard_Integer &>(rv, TheIndex); }, "returns if possible, the first local context where the object is seen", py::arg("anObject"), py::arg("TheIndex"));
cls_AIS_InteractiveContext.def("SetAutomaticHilight", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::SetAutomaticHilight, "Sets the highlighting status aStatus of detected and selected entities. Whether you are in Neutral Point or local context, this is automatically managed by the Interactive Context. This function allows you to disconnect the automatic mode.", py::arg("aStatus"));
cls_AIS_InteractiveContext.def("AutomaticHilight", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::AutomaticHilight, "Returns true if the automatic highlight mode is active in an open context.");
cls_AIS_InteractiveContext.def("KeepTemporary", [](AIS_InteractiveContext &self, const opencascade::handle<AIS_InteractiveObject> & a0) -> Standard_Boolean { return self.KeepTemporary(a0); });
cls_AIS_InteractiveContext.def("KeepTemporary", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Integer)) &AIS_InteractiveContext::KeepTemporary, "Changes the status of a temporary object. It will be kept at the neutral point, i.e. put in the list of displayed objects along with its temporary attributes. These include display mode and selection mode, for example. Returns true if done. inWhichLocal gives the local context in which anIObj is displayed. By default, the index -1 refers to the last Local Context opened.", py::arg("anIObj"), py::arg("InWhichLocal"));
cls_AIS_InteractiveContext.def("SetCurrentObject", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::SetCurrentObject, "Updates the view of the current object in open context. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("AddOrRemoveCurrentObject", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::AddOrRemoveCurrentObject, "Allows to add or remove the object given to the list of current and highlight/unhighlight it correspondingly. Is valid for global context only; for local context use method AddOrRemoveSelected. Since this method makes sence only for neutral point selection of a whole object, if 0 selection of the object is empty this method simply does nothing.", py::arg("theObj"), py::arg("theIsToUpdateViewer"));
cls_AIS_InteractiveContext.def("UpdateCurrent", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::UpdateCurrent, "Updates the list of current objects, i.e. hilights new current objects, removes hilighting from former current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.");
cls_AIS_InteractiveContext.def("IsCurrent", (Standard_Boolean (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &) const) &AIS_InteractiveContext::IsCurrent, "Returns true if there is a non-null interactive object in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.", py::arg("theObject"));
cls_AIS_InteractiveContext.def("InitCurrent", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::InitCurrent, "Initializes a scan of the current selected objects in Neutral Point. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.");
cls_AIS_InteractiveContext.def("MoreCurrent", (Standard_Boolean (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::MoreCurrent, "Returns true if there is another object found by the scan of the list of current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.");
cls_AIS_InteractiveContext.def("NextCurrent", (void (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NextCurrent, "Continues the scan to the next object in the list of current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.");
cls_AIS_InteractiveContext.def("Current", (opencascade::handle<AIS_InteractiveObject> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::Current, "Returns the current interactive object. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.");
cls_AIS_InteractiveContext.def("NbCurrents", (Standard_Integer (AIS_InteractiveContext::*)()) &AIS_InteractiveContext::NbCurrents, "None");
cls_AIS_InteractiveContext.def("HilightCurrents", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::HilightCurrents, "Highlights current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("UnhilightCurrents", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::UnhilightCurrents, "Removes highlighting from current objects. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("ClearCurrents", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::ClearCurrents, "Empties previous current objects in order to get the current objects detected by the selector using UpdateCurrent. Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("DetectedCurrentShape", (const TopoDS_Shape & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedCurrentShape, "Returns current mouse-detected shape or empty (null) shape, if current interactive object is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all. DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().");
cls_AIS_InteractiveContext.def("DetectedCurrentObject", (opencascade::handle<AIS_InteractiveObject> (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::DetectedCurrentObject, "Returns current mouse-detected interactive object or null object, if there is no currently detected interactives DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().");
cls_AIS_InteractiveContext.def("SubIntensityColor", (const Quantity_Color & (AIS_InteractiveContext::*)() const) &AIS_InteractiveContext::SubIntensityColor, "Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight, but without actual selection (e.g., global status and owner's selection state will not be updated). The method returns the color of such highlighting. By default, it is Quantity_NOC_GRAY40.");
cls_AIS_InteractiveContext.def("SetSubIntensityColor", (void (AIS_InteractiveContext::*)(const Quantity_Color &)) &AIS_InteractiveContext::SetSubIntensityColor, "Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight, but without actual selection (e.g., global status and owner's selection state will not be updated). The method sets up the color for such highlighting. By default, this is Quantity_NOC_GRAY40.", py::arg("theColor"));
cls_AIS_InteractiveContext.def("SubIntensityOn", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::SubIntensityOn, "Highlights, and removes highlights from, the displayed object which is displayed at Neutral Point with subintensity color. Available only for active local context. There is no effect if there is no local context. If a local context is open, the presentation of the Interactive Object activates the selection mode.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SubIntensityOff", (void (AIS_InteractiveContext::*)(const opencascade::handle<AIS_InteractiveObject> &, const Standard_Boolean)) &AIS_InteractiveContext::SubIntensityOff, "Removes the subintensity option for the entity. If a local context is open, the presentation of the Interactive Object activates the selection mode.", py::arg("theIObj"), py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SubIntensityOn", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::SubIntensityOn, "hilights/unhilights displayed objects which are displayed at neutral state with subintensity color. Available only for active local context. No effect if no local context.", py::arg("theToUpdateViewer"));
cls_AIS_InteractiveContext.def("SubIntensityOff", (void (AIS_InteractiveContext::*)(const Standard_Boolean)) &AIS_InteractiveContext::SubIntensityOff, "Removes subintensity option for all objects.", py::arg("theToUpdateViewer"));

// Enums

}