/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard.hxx>
#include <TopoDS_Shape.hxx>
#include <GProp_GProps.hxx>
#include <Standard_TypeDef.hxx>
#include <gp_Pln.hxx>
#include <BRepGProp_EdgeTool.hxx>
#include <BRepGProp_Face.hxx>
#include <BRepGProp_Domain.hxx>
#include <BRepGProp_Cinert.hxx>
#include <BRepGProp_Sinert.hxx>
#include <BRepGProp_Vinert.hxx>
#include <BRepGProp_VinertGK.hxx>
#include <BRepGProp_UFunction.hxx>
#include <BRepGProp_TFunction.hxx>
#include <BRepGProp.hxx>

void bind_BRepGProp(py::module &mod){

py::class_<BRepGProp> cls_BRepGProp(mod, "BRepGProp", "Provides global functions to compute a shape's global properties for lines, surfaces or volumes, and bring them together with the global properties already computed for a geometric system. The global properties computed for a system are : - its mass, - its center of mass, - its matrix of inertia, - its moment about an axis, - its radius of gyration about an axis, - and its principal properties of inertia such as principal axis, principal moments, principal radius of gyration.");

// Constructors

// Fields

// Methods
// cls_BRepGProp.def_static("operator new_", (void * (*)(size_t)) &BRepGProp::operator new, "None", py::arg("theSize"));
// cls_BRepGProp.def_static("operator delete_", (void (*)(void *)) &BRepGProp::operator delete, "None", py::arg("theAddress"));
// cls_BRepGProp.def_static("operator new[]_", (void * (*)(size_t)) &BRepGProp::operator new[], "None", py::arg("theSize"));
// cls_BRepGProp.def_static("operator delete[]_", (void (*)(void *)) &BRepGProp::operator delete[], "None", py::arg("theAddress"));
// cls_BRepGProp.def_static("operator new_", (void * (*)(size_t, void *)) &BRepGProp::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_BRepGProp.def_static("operator delete_", (void (*)(void *, void *)) &BRepGProp::operator delete, "None", py::arg(""), py::arg(""));
cls_BRepGProp.def_static("LinearProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1) -> void { return BRepGProp::LinearProperties(a0, a1); });
cls_BRepGProp.def_static("LinearProperties_", (void (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Boolean)) &BRepGProp::LinearProperties, "Computes the linear global properties of the shape S, i.e. the global properties induced by each edge of the shape S, and brings them together with the global properties still retained by the framework LProps. If the current system of LProps was empty, its global properties become equal to the linear global properties of S. For this computation no linear density is attached to the edges. So, for example, the added mass corresponds to the sum of the lengths of the edges of S. The density of the composed systems, i.e. that of each component of the current system of LProps, and that of S which is considered to be equal to 1, must be coherent. Note that this coherence cannot be checked. You are advised to use a separate framework for each density, and then to bring these frameworks together into a global one. The point relative to which the inertia of the system is computed is the reference point of the framework LProps. Note: if your programming ensures that the framework LProps retains only linear global properties (brought together for example, by the function LinearProperties) for objects the density of which is equal to 1 (or is not defined), the function Mass will return the total length of edges of the system analysed by LProps. Warning No check is performed to verify that the shape S retains truly linear properties. If S is simply a vertex, it is not considered to present any additional global properties. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, edges, shared by two or more faces, are taken into calculation only once. If we have cube with sizes 1, 1, 1, its linear properties = 12 for SkipEdges = true and 24 for SkipEdges = false.", py::arg("S"), py::arg("LProps"), py::arg("SkipShared"));
cls_BRepGProp.def_static("SurfaceProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1) -> void { return BRepGProp::SurfaceProperties(a0, a1); });
cls_BRepGProp.def_static("SurfaceProperties_", (void (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Boolean)) &BRepGProp::SurfaceProperties, "Computes the surface global properties of the shape S, i.e. the global properties induced by each face of the shape S, and brings them together with the global properties still retained by the framework SProps. If the current system of SProps was empty, its global properties become equal to the surface global properties of S. For this computation, no surface density is attached to the faces. Consequently, the added mass corresponds to the sum of the areas of the faces of S. The density of the component systems, i.e. that of each component of the current system of SProps, and that of S which is considered to be equal to 1, must be coherent. Note that this coherence cannot be checked. You are advised to use a framework for each different value of density, and then to bring these frameworks together into a global one. The point relative to which the inertia of the system is computed is the reference point of the framework SProps. Note : if your programming ensures that the framework SProps retains only surface global properties, brought together, for example, by the function SurfaceProperties, for objects the density of which is equal to 1 (or is not defined), the function Mass will return the total area of faces of the system analysed by SProps. Warning No check is performed to verify that the shape S retains truly surface properties. If S is simply a vertex, an edge or a wire, it is not considered to present any additional global properties. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, faces, shared by two or more shells, are taken into calculation only once.", py::arg("S"), py::arg("SProps"), py::arg("SkipShared"));
cls_BRepGProp.def_static("SurfaceProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2) -> Standard_Real { return BRepGProp::SurfaceProperties(a0, a1, a2); });
cls_BRepGProp.def_static("SurfaceProperties_", (Standard_Real (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Real, const Standard_Boolean)) &BRepGProp::SurfaceProperties, "Updates <SProps> with the shape <S>, that contains its pricipal properties. The surface properties of all the faces in <S> are computed. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (area) for each face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. Method returns estimation of relative error reached for whole shape. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, faces, shared by two or more shells, are taken into calculation only once.", py::arg("S"), py::arg("SProps"), py::arg("Eps"), py::arg("SkipShared"));
cls_BRepGProp.def_static("VolumeProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1) -> void { return BRepGProp::VolumeProperties(a0, a1); });
cls_BRepGProp.def_static("VolumeProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Boolean a2) -> void { return BRepGProp::VolumeProperties(a0, a1, a2); });
cls_BRepGProp.def_static("VolumeProperties_", (void (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Boolean, const Standard_Boolean)) &BRepGProp::VolumeProperties, "Computes the global volume properties of the solid S, and brings them together with the global properties still retained by the framework VProps. If the current system of VProps was empty, its global properties become equal to the global properties of S for volume. For this computation, no volume density is attached to the solid. Consequently, the added mass corresponds to the volume of S. The density of the component systems, i.e. that of each component of the current system of VProps, and that of S which is considered to be equal to 1, must be coherent to each other. Note that this coherence cannot be checked. You are advised to use a separate framework for each density, and then to bring these frameworks together into a global one. The point relative to which the inertia of the system is computed is the reference point of the framework VProps. Note: if your programming ensures that the framework VProps retains only global properties of volume (brought together for example, by the function VolumeProperties) for objects the density of which is equal to 1 (or is not defined), the function Mass will return the total volume of the solids of the system analysed by VProps. Warning The shape S must represent an object whose global volume properties can be computed. It may be a finite solid, or a series of finite solids all oriented in a coherent way. Nonetheless, S must be exempt of any free boundary. Note that these conditions of coherence are not checked by this algorithm, and results will be false if they are not respected. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, the volumes formed by the equal (the same TShape, location and orientation) faces are taken into calculation only once.", py::arg("S"), py::arg("VProps"), py::arg("OnlyClosed"), py::arg("SkipShared"));
cls_BRepGProp.def_static("VolumeProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2) -> Standard_Real { return BRepGProp::VolumeProperties(a0, a1, a2); });
cls_BRepGProp.def_static("VolumeProperties_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2, const Standard_Boolean a3) -> Standard_Real { return BRepGProp::VolumeProperties(a0, a1, a2, a3); });
cls_BRepGProp.def_static("VolumeProperties_", (Standard_Real (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Real, const Standard_Boolean, const Standard_Boolean)) &BRepGProp::VolumeProperties, "Updates <VProps> with the shape <S>, that contains its pricipal properties. The volume properties of all the FORWARD and REVERSED faces in <S> are computed. If OnlyClosed is True then computed faces must belong to closed Shells. Adaptive 2D Gauss integration is used. Parameter Eps sets maximal relative error of computed mass (volume) for each face. Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values for two successive steps of adaptive integration. Method returns estimation of relative error reached for whole shape. WARNING: if Eps > 0.001 algorithm performs non-adaptive integration. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, the volumes formed by the equal (the same TShape, location and orientation) faces are taken into calculation only once.", py::arg("S"), py::arg("VProps"), py::arg("Eps"), py::arg("OnlyClosed"), py::arg("SkipShared"));
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2, const Standard_Boolean a3) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2, const Standard_Boolean a3, const Standard_Boolean a4) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4, a5); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const Standard_Real a2, const Standard_Boolean a3, const Standard_Boolean a4, const Standard_Boolean a5, const Standard_Boolean a6) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepGProp.def_static("VolumePropertiesGK_", (Standard_Real (*)(const TopoDS_Shape &, GProp_GProps &, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &BRepGProp::VolumePropertiesGK, "Updates <VProps> with the shape <S>, that contains its pricipal properties. The volume properties of all the FORWARD and REVERSED faces in <S> are computed. If OnlyClosed is True then computed faces must belong to closed Shells. Adaptive 2D Gauss integration is used. Parameter IsUseSpan says if it is necessary to define spans on a face. This option has an effect only for BSpline faces. Parameter Eps sets maximal relative error of computed property for each face. Error is delivered by the adaptive Gauss-Kronrod method of integral computation that is used for properties computation. Method returns estimation of relative error reached for whole shape. Returns negative value if the computation is failed. SkipShared is special flag, which allows to take in calculation shared topological entities or not For ex., if SkipShared = True, the volumes formed by the equal (the same TShape, location and orientation) faces are taken into calculation only once.", py::arg("S"), py::arg("VProps"), py::arg("Eps"), py::arg("OnlyClosed"), py::arg("IsUseSpan"), py::arg("CGFlag"), py::arg("IFlag"), py::arg("SkipShared"));
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2, const Standard_Real a3) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2, const Standard_Real a3, const Standard_Boolean a4) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2, const Standard_Real a3, const Standard_Boolean a4, const Standard_Boolean a5) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4, a5); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2, const Standard_Real a3, const Standard_Boolean a4, const Standard_Boolean a5, const Standard_Boolean a6) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4, a5, a6); });
cls_BRepGProp.def_static("VolumePropertiesGK_", [](const TopoDS_Shape & a0, GProp_GProps & a1, const gp_Pln & a2, const Standard_Real a3, const Standard_Boolean a4, const Standard_Boolean a5, const Standard_Boolean a6, const Standard_Boolean a7) -> Standard_Real { return BRepGProp::VolumePropertiesGK(a0, a1, a2, a3, a4, a5, a6, a7); });
cls_BRepGProp.def_static("VolumePropertiesGK_", (Standard_Real (*)(const TopoDS_Shape &, GProp_GProps &, const gp_Pln &, const Standard_Real, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean, const Standard_Boolean)) &BRepGProp::VolumePropertiesGK, "None", py::arg("S"), py::arg("VProps"), py::arg("thePln"), py::arg("Eps"), py::arg("OnlyClosed"), py::arg("IsUseSpan"), py::arg("CGFlag"), py::arg("IFlag"), py::arg("SkipShared"));

// Enums

}