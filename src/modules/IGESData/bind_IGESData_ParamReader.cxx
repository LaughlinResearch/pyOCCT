/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard.hxx>
#include <Standard_Handle.hxx>
#include <Interface_ParamList.hxx>
#include <Interface_Check.hxx>
#include <Standard_TypeDef.hxx>
#include <IGESData_ReadStage.hxx>
#include <Interface_ParamType.hxx>
#include <IGESData_IGESEntity.hxx>
#include <IGESData_IGESReaderData.hxx>
#include <IGESData_ParamCursor.hxx>
#include <Message_Msg.hxx>
#include <gp_XY.hxx>
#include <gp_XYZ.hxx>
#include <TCollection_HAsciiString.hxx>
#include <IGESData_Status.hxx>
#include <Standard_Type.hxx>
#include <IGESData_ParamReader.hxx>
#include <TColStd_HArray1OfInteger.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <Interface_HArray1OfHAsciiString.hxx>
#include <IGESData_HArray1OfIGESEntity.hxx>
#include <Interface_EntityList.hxx>

void bind_IGESData_ParamReader(py::module &mod){

py::class_<IGESData_ParamReader, std::unique_ptr<IGESData_ParamReader, Deleter<IGESData_ParamReader>>> cls_IGESData_ParamReader(mod, "IGESData_ParamReader", "access to a list of parameters, with management of read stage (owned parameters, properties, associativities) and current parameter number, read errors (which feed a Check), plus convenient facilities to read parameters, in particular : - first parameter is ignored (it repeats entity type), hence number 1 gives 2nd parameter, etc... - lists are not explicit, list-reading methods are provided which manage a current param. number - interpretation is made as possible (texts, reals, entities ...) (in particular, Reading a Real accepts an Integer)");

// Constructors
cls_IGESData_ParamReader.def(py::init<const opencascade::handle<Interface_ParamList> &, const opencascade::handle<Interface_Check> &>(), py::arg("list"), py::arg("ach"));
cls_IGESData_ParamReader.def(py::init<const opencascade::handle<Interface_ParamList> &, const opencascade::handle<Interface_Check> &, const Standard_Integer>(), py::arg("list"), py::arg("ach"), py::arg("base"));
cls_IGESData_ParamReader.def(py::init<const opencascade::handle<Interface_ParamList> &, const opencascade::handle<Interface_Check> &, const Standard_Integer, const Standard_Integer>(), py::arg("list"), py::arg("ach"), py::arg("base"), py::arg("nbpar"));
cls_IGESData_ParamReader.def(py::init<const opencascade::handle<Interface_ParamList> &, const opencascade::handle<Interface_Check> &, const Standard_Integer, const Standard_Integer, const Standard_Integer>(), py::arg("list"), py::arg("ach"), py::arg("base"), py::arg("nbpar"), py::arg("num"));

// Fields

// Methods
// cls_IGESData_ParamReader.def_static("operator new_", (void * (*)(size_t)) &IGESData_ParamReader::operator new, "None", py::arg("theSize"));
// cls_IGESData_ParamReader.def_static("operator delete_", (void (*)(void *)) &IGESData_ParamReader::operator delete, "None", py::arg("theAddress"));
// cls_IGESData_ParamReader.def_static("operator new[]_", (void * (*)(size_t)) &IGESData_ParamReader::operator new[], "None", py::arg("theSize"));
// cls_IGESData_ParamReader.def_static("operator delete[]_", (void (*)(void *)) &IGESData_ParamReader::operator delete[], "None", py::arg("theAddress"));
// cls_IGESData_ParamReader.def_static("operator new_", (void * (*)(size_t, void *)) &IGESData_ParamReader::operator new, "None", py::arg(""), py::arg("theAddress"));
// cls_IGESData_ParamReader.def_static("operator delete_", (void (*)(void *, void *)) &IGESData_ParamReader::operator delete, "None", py::arg(""), py::arg(""));
cls_IGESData_ParamReader.def("EntityNumber", (Standard_Integer (IGESData_ParamReader::*)() const) &IGESData_ParamReader::EntityNumber, "Returns the entity number in the file");
cls_IGESData_ParamReader.def("Clear", (void (IGESData_ParamReader::*)()) &IGESData_ParamReader::Clear, "resets state (stage, current param number, check with no fail)");
cls_IGESData_ParamReader.def("CurrentNumber", (Standard_Integer (IGESData_ParamReader::*)() const) &IGESData_ParamReader::CurrentNumber, "returns the current parameter number This notion is involved by the organisation of an IGES list of parameter : it can be ended by two lists (Associativities and Properties), which can be empty, or even absent. Hence, it is necessary to know, at the end of specific reading, how many parameters have been read : the optionnal lists follow");
cls_IGESData_ParamReader.def("SetCurrentNumber", (void (IGESData_ParamReader::*)(const Standard_Integer)) &IGESData_ParamReader::SetCurrentNumber, "sets current parameter number to a new value must be done at end of each step : set on first parameter following last read one; is done by some Read... methods (must be done directly if these method are not used) num greater than NbParams means that following lists are empty If current num is not managed, it remains at 1, which probably will cause error when successive steps of reading are made", py::arg("num"));
cls_IGESData_ParamReader.def("Stage", (IGESData_ReadStage (IGESData_ParamReader::*)() const) &IGESData_ParamReader::Stage, "gives current stage (Own-Props-Assocs-End, begins at Own)");
cls_IGESData_ParamReader.def("NextStage", (void (IGESData_ParamReader::*)()) &IGESData_ParamReader::NextStage, "passes to next stage (must be linked with setting Current)");
cls_IGESData_ParamReader.def("EndAll", (void (IGESData_ParamReader::*)()) &IGESData_ParamReader::EndAll, "passes directly to the end of reading process");
cls_IGESData_ParamReader.def("NbParams", (Standard_Integer (IGESData_ParamReader::*)() const) &IGESData_ParamReader::NbParams, "returns number of parameters (minus the first one) following method skip the first parameter (1 gives the 2nd)");
cls_IGESData_ParamReader.def("ParamType", (Interface_ParamType (IGESData_ParamReader::*)(const Standard_Integer) const) &IGESData_ParamReader::ParamType, "returns type of parameter; note that 'Ident' or 'Sub' cannot be encountered, they correspond to 'Integer', see also below", py::arg("num"));
cls_IGESData_ParamReader.def("ParamValue", (Standard_CString (IGESData_ParamReader::*)(const Standard_Integer) const) &IGESData_ParamReader::ParamValue, "returns litteral value of a parameter, as it was in file", py::arg("num"));
cls_IGESData_ParamReader.def("IsParamDefined", (Standard_Boolean (IGESData_ParamReader::*)(const Standard_Integer) const) &IGESData_ParamReader::IsParamDefined, "says if a parameter is defined (not void) See also DefinedElseSkip", py::arg("num"));
cls_IGESData_ParamReader.def("IsParamEntity", (Standard_Boolean (IGESData_ParamReader::*)(const Standard_Integer) const) &IGESData_ParamReader::IsParamEntity, "says if a parameter can be regarded as an entity reference (see Prepare from IGESReaderData for more explanation) Note that such a parameter can seen as be a plain Integer too", py::arg("num"));
cls_IGESData_ParamReader.def("ParamNumber", (Standard_Integer (IGESData_ParamReader::*)(const Standard_Integer) const) &IGESData_ParamReader::ParamNumber, "returns entity number corresponding to a parameter if there is otherwise zero (according criterium IsParamEntity)", py::arg("num"));
cls_IGESData_ParamReader.def("ParamEntity", (opencascade::handle<IGESData_IGESEntity> (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const Standard_Integer)) &IGESData_ParamReader::ParamEntity, "directly returns entity referenced by a parameter", py::arg("IR"), py::arg("num"));
cls_IGESData_ParamReader.def("Current", (IGESData_ParamCursor (IGESData_ParamReader::*)() const) &IGESData_ParamReader::Current, "Creates a ParamCursor from the Current Number, to read one parameter, and to advance Current Number after reading");
cls_IGESData_ParamReader.def("CurrentList", [](IGESData_ParamReader &self, const Standard_Integer a0) -> IGESData_ParamCursor { return self.CurrentList(a0); });
cls_IGESData_ParamReader.def("CurrentList", (IGESData_ParamCursor (IGESData_ParamReader::*)(const Standard_Integer, const Standard_Integer) const) &IGESData_ParamReader::CurrentList, "Creates a ParamCursor from the Current Number, to read a list of 'nb' items, and to advance Current Number after reading By default, each item is made of one parameter If size is given, it precises the number of params per item", py::arg("nb"), py::arg("size"));
cls_IGESData_ParamReader.def("DefinedElseSkip", (Standard_Boolean (IGESData_ParamReader::*)()) &IGESData_ParamReader::DefinedElseSkip, "Allows to simply process a parameter which can be defaulted. Waits on the Current Number a defined parameter or skips it : If the parameter <num> is defined, changes nothing and returns True Hence, the next reading with current cursor will concern <num> If it is void, advances Current Position by one, and returns False The next reading will concern <num+1> (except if <num> = NbParams)");
cls_IGESData_ParamReader.def("ReadInteger", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, Standard_Integer & val){ Standard_Boolean rv = self.ReadInteger(PC, val); return std::tuple<Standard_Boolean, Standard_Integer &>(rv, val); }, "None", py::arg("PC"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadInteger", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, const Standard_CString mess, Standard_Integer & val){ Standard_Boolean rv = self.ReadInteger(PC, mess, val); return std::tuple<Standard_Boolean, Standard_Integer &>(rv, val); }, "Reads an Integer value designated by PC The method Current designates the current parameter and advances the Current Number by one after reading Note that if a count (not 1) is given, it is ignored If it is not an Integer, fills Check with a Fail (using mess) and returns False", py::arg("PC"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadBoolean", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, const Message_Msg & amsg, Standard_Boolean & val, const Standard_Boolean exact){ Standard_Boolean rv = self.ReadBoolean(PC, amsg, val, exact); return std::tuple<Standard_Boolean, Standard_Boolean &>(rv, val); }, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("exact"));
cls_IGESData_ParamReader.def("ReadBoolean", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, const Standard_CString mess, Standard_Boolean & val, const Standard_Boolean exact){ Standard_Boolean rv = self.ReadBoolean(PC, mess, val, exact); return std::tuple<Standard_Boolean, Standard_Boolean &>(rv, val); }, "Reads a Boolean value from parameter 'num' A Boolean is given as an Integer value 0 (False) or 1 (True) Anyway, an Integer is demanded (else, Check is filled) If exact is given True, those precise values are demanded Else, Correction is done, as False for 0 or <0, True for >0 (with a Warning error message, and return is True) In case of error (not an Integer, or not 0/1 and exact True), Check is filled with a Fail (using mess) and return is False", py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("exact"));
cls_IGESData_ParamReader.def("ReadReal", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, Standard_Real & val){ Standard_Boolean rv = self.ReadReal(PC, val); return std::tuple<Standard_Boolean, Standard_Real &>(rv, val); }, "None", py::arg("PC"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadReal", [](IGESData_ParamReader &self, const IGESData_ParamCursor & PC, const Standard_CString mess, Standard_Real & val){ Standard_Boolean rv = self.ReadReal(PC, mess, val); return std::tuple<Standard_Boolean, Standard_Real &>(rv, val); }, "Reads a Real value from parameter 'num' An Integer is accepted (Check is filled with a Warning message) and causes return to be True (as normal case) In other cases, Check is filled with a Fail and return is False", py::arg("PC"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadXY", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, Message_Msg &, gp_XY &)) &IGESData_ParamReader::ReadXY, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadXY", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, gp_XY &)) &IGESData_ParamReader::ReadXY, "Reads a couple of Real values (X,Y) from parameter 'num' Integers are accepted (Check is filled with a Warning message) and cause return to be True (as normal case) In other cases, Check is filled with a Fail and return is False", py::arg("PC"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadXYZ", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, Message_Msg &, gp_XYZ &)) &IGESData_ParamReader::ReadXYZ, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadXYZ", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, gp_XYZ &)) &IGESData_ParamReader::ReadXYZ, "Reads a triplet of Real values (X,Y,Z) from parameter 'num' Integers are accepted (Check is filled with a Warning message) and cause return to be True (as normal case) In other cases, Check is filled with a Fail and return is False For Message", py::arg("PC"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadText", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Message_Msg &, opencascade::handle<TCollection_HAsciiString> &)) &IGESData_ParamReader::ReadText, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadText", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<TCollection_HAsciiString> &)) &IGESData_ParamReader::ReadText, "Reads a Text value from parameter 'num', as a String from Collection, that is, Hollerith text without leading 'nnnH' If it is not a String, fills Check with a Fail (using mess) and returns False", py::arg("PC"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadEntity", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, IGESData_Status & a2, opencascade::handle<IGESData_IGESEntity> & a3) -> Standard_Boolean { return self.ReadEntity(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEntity", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, IGESData_Status &, opencascade::handle<IGESData_IGESEntity> &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntity, "None", py::arg("IR"), py::arg("PC"), py::arg("aStatus"), py::arg("val"), py::arg("canbenul"));
cls_IGESData_ParamReader.def("ReadEntity", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, const Standard_CString a2, opencascade::handle<IGESData_IGESEntity> & a3) -> Standard_Boolean { return self.ReadEntity(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEntity", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<IGESData_IGESEntity> &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntity, "Reads an IGES entity from parameter 'num' An Entity is known by its reference, which has the form of an odd Integer Value (a number in the Directory) If <canbenul> is given True, a Reference can also be Null : in this case, the result is a Null Handle with no Error If <canbenul> is False, a Null Reference causes an Error If the parameter cannot refer to an entity (or null), fills Check with a Fail (using mess) and returns False", py::arg("IR"), py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("canbenul"));
cls_IGESData_ParamReader.def("ReadEntity", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, IGESData_Status & a2, const opencascade::handle<Standard_Type> & a3, opencascade::handle<IGESData_IGESEntity> & a4) -> Standard_Boolean { return self.ReadEntity(a0, a1, a2, a3, a4); });
cls_IGESData_ParamReader.def("ReadEntity", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, IGESData_Status &, const opencascade::handle<Standard_Type> &, opencascade::handle<IGESData_IGESEntity> &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntity, "None", py::arg("IR"), py::arg("PC"), py::arg("aStatus"), py::arg("type"), py::arg("val"), py::arg("canbenul"));
cls_IGESData_ParamReader.def("ReadEntity", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, const Standard_CString a2, const opencascade::handle<Standard_Type> & a3, opencascade::handle<IGESData_IGESEntity> & a4) -> Standard_Boolean { return self.ReadEntity(a0, a1, a2, a3, a4); });
cls_IGESData_ParamReader.def("ReadEntity", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, const Standard_CString, const opencascade::handle<Standard_Type> &, opencascade::handle<IGESData_IGESEntity> &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntity, "Works as ReadEntity without Type, but in addition checks the Type of the Entity, which must be 'kind of' a given <type> Then, gives the same fail cases as ReadEntity without Type, plus the case 'Incorrect Type' (in such a case, returns False and givel <val> = Null)", py::arg("IR"), py::arg("PC"), py::arg("mess"), py::arg("type"), py::arg("val"), py::arg("canbenul"));
cls_IGESData_ParamReader.def("ReadInts", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, const Message_Msg & a1, opencascade::handle<TColStd_HArray1OfInteger> & a2) -> Standard_Boolean { return self.ReadInts(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadInts", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Message_Msg &, opencascade::handle<TColStd_HArray1OfInteger> &, const Standard_Integer)) &IGESData_ParamReader::ReadInts, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadInts", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, const Standard_CString a1, opencascade::handle<TColStd_HArray1OfInteger> & a2) -> Standard_Boolean { return self.ReadInts(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadInts", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<TColStd_HArray1OfInteger> &, const Standard_Integer)) &IGESData_ParamReader::ReadInts, "Reads a list of Integer values, defined by PC (with a count of parameters). PC can start from Current Number and command it to advance after reading (use method CurrentList to do this) The list is given as a HArray1, numered from 'index' If all params are not Integer, Check is filled (using mess) and return value is False", py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadReals", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, Message_Msg & a1, opencascade::handle<TColStd_HArray1OfReal> & a2) -> Standard_Boolean { return self.ReadReals(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadReals", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, Message_Msg &, opencascade::handle<TColStd_HArray1OfReal> &, const Standard_Integer)) &IGESData_ParamReader::ReadReals, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadReals", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, const Standard_CString a1, opencascade::handle<TColStd_HArray1OfReal> & a2) -> Standard_Boolean { return self.ReadReals(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadReals", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<TColStd_HArray1OfReal> &, const Standard_Integer)) &IGESData_ParamReader::ReadReals, "Reads a list of Real values defined by PC Same conditions as for ReadInts, for PC and index An Integer parameter is accepted, if at least one parameter is Integer, Check is filled with a 'Warning' message If all params are neither Real nor Integer, Check is filled (using mess) and return value is False", py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadTexts", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, const Message_Msg & a1, opencascade::handle<Interface_HArray1OfHAsciiString> & a2) -> Standard_Boolean { return self.ReadTexts(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadTexts", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Message_Msg &, opencascade::handle<Interface_HArray1OfHAsciiString> &, const Standard_Integer)) &IGESData_ParamReader::ReadTexts, "None", py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadTexts", [](IGESData_ParamReader &self, const IGESData_ParamCursor & a0, const Standard_CString a1, opencascade::handle<Interface_HArray1OfHAsciiString> & a2) -> Standard_Boolean { return self.ReadTexts(a0, a1, a2); });
cls_IGESData_ParamReader.def("ReadTexts", (Standard_Boolean (IGESData_ParamReader::*)(const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<Interface_HArray1OfHAsciiString> &, const Standard_Integer)) &IGESData_ParamReader::ReadTexts, "Reads a list of Hollerith Texts, defined by PC Texts are read as Hollerith texts without leading 'nnnH' Same conditions as for ReadInts, for PC and index If all params are not Text, Check is filled (using mess) and return value is False", py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadEnts", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, const Message_Msg & a2, opencascade::handle<IGESData_HArray1OfIGESEntity> & a3) -> Standard_Boolean { return self.ReadEnts(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEnts", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, const Message_Msg &, opencascade::handle<IGESData_HArray1OfIGESEntity> &, const Standard_Integer)) &IGESData_ParamReader::ReadEnts, "None", py::arg("IR"), py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadEnts", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, const Standard_CString a2, opencascade::handle<IGESData_HArray1OfIGESEntity> & a3) -> Standard_Boolean { return self.ReadEnts(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEnts", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, const Standard_CString, opencascade::handle<IGESData_HArray1OfIGESEntity> &, const Standard_Integer)) &IGESData_ParamReader::ReadEnts, "Reads a list of Entities defined by PC Same conditions as for ReadInts, for PC and index The list is given as a HArray1, numered from 'index' If all params cannot be read as Entities, Check is filled (using mess) and return value is False Remark : Null references are accepted, they are ignored (negative pointers too : they provoke a Warning message) If the caller wants to check them, a loop on ReadEntity should be used", py::arg("IR"), py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("index"));
cls_IGESData_ParamReader.def("ReadEntList", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, Message_Msg & a2, Interface_EntityList & a3) -> Standard_Boolean { return self.ReadEntList(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEntList", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, Message_Msg &, Interface_EntityList &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntList, "None", py::arg("IR"), py::arg("PC"), py::arg("amsg"), py::arg("val"), py::arg("ord"));
cls_IGESData_ParamReader.def("ReadEntList", [](IGESData_ParamReader &self, const opencascade::handle<IGESData_IGESReaderData> & a0, const IGESData_ParamCursor & a1, const Standard_CString a2, Interface_EntityList & a3) -> Standard_Boolean { return self.ReadEntList(a0, a1, a2, a3); });
cls_IGESData_ParamReader.def("ReadEntList", (Standard_Boolean (IGESData_ParamReader::*)(const opencascade::handle<IGESData_IGESReaderData> &, const IGESData_ParamCursor &, const Standard_CString, Interface_EntityList &, const Standard_Boolean)) &IGESData_ParamReader::ReadEntList, "Reads a list of Entities defined by PC Same conditions as for ReadEnts, for PC The list is given as an EntityList (index has no meaning; the EntityList starts from clear) If 'ord' is given True (default), entities will be added to the list in their original order Remark : Negative or Null Pointers are ignored Else ('ord' False), order is not garanteed (faster mode) If all params cannot be read as Entities, same as above Warning Give 'ord' to False ONLY if order is not significant", py::arg("IR"), py::arg("PC"), py::arg("mess"), py::arg("val"), py::arg("ord"));
cls_IGESData_ParamReader.def("ReadingReal", [](IGESData_ParamReader &self, const Standard_Integer num, Standard_Real & val){ Standard_Boolean rv = self.ReadingReal(num, val); return std::tuple<Standard_Boolean, Standard_Real &>(rv, val); }, "None", py::arg("num"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadingReal", [](IGESData_ParamReader &self, const Standard_Integer num, const Standard_CString mess, Standard_Real & val){ Standard_Boolean rv = self.ReadingReal(num, mess, val); return std::tuple<Standard_Boolean, Standard_Real &>(rv, val); }, "Routine which reads a Real parameter, given its number Same conditions as ReadReal for mess, val, and return value", py::arg("num"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadingEntityNumber", [](IGESData_ParamReader &self, const Standard_Integer num, Standard_Integer & val){ Standard_Boolean rv = self.ReadingEntityNumber(num, val); return std::tuple<Standard_Boolean, Standard_Integer &>(rv, val); }, "None", py::arg("num"), py::arg("val"));
cls_IGESData_ParamReader.def("ReadingEntityNumber", [](IGESData_ParamReader &self, const Standard_Integer num, const Standard_CString mess, Standard_Integer & val){ Standard_Boolean rv = self.ReadingEntityNumber(num, mess, val); return std::tuple<Standard_Boolean, Standard_Integer &>(rv, val); }, "Routine which reads an Entity Number (which allows to read the Entity in the IGESReaderData by BoundEntity), given its number in the list of Parameters Same conditions as ReadEntity for mess, val, and return value In particular, returns True and val to zero means Null Entity, and val not zero means Entity read by BoundEntity", py::arg("num"), py::arg("mess"), py::arg("val"));
cls_IGESData_ParamReader.def("SendFail", (void (IGESData_ParamReader::*)(const Message_Msg &)) &IGESData_ParamReader::SendFail, "None", py::arg("amsg"));
cls_IGESData_ParamReader.def("SendWarning", (void (IGESData_ParamReader::*)(const Message_Msg &)) &IGESData_ParamReader::SendWarning, "None", py::arg("amsg"));
cls_IGESData_ParamReader.def("AddFail", [](IGESData_ParamReader &self, const Standard_CString a0) -> void { return self.AddFail(a0); });
cls_IGESData_ParamReader.def("AddFail", (void (IGESData_ParamReader::*)(const Standard_CString, const Standard_CString)) &IGESData_ParamReader::AddFail, "None", py::arg("afail"), py::arg("bfail"));
cls_IGESData_ParamReader.def("AddFail", (void (IGESData_ParamReader::*)(const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<TCollection_HAsciiString> &)) &IGESData_ParamReader::AddFail, "feeds the Check with a new fail (as a String or as a CString)", py::arg("af"), py::arg("bf"));
cls_IGESData_ParamReader.def("AddWarning", [](IGESData_ParamReader &self, const Standard_CString a0) -> void { return self.AddWarning(a0); });
cls_IGESData_ParamReader.def("AddWarning", (void (IGESData_ParamReader::*)(const Standard_CString, const Standard_CString)) &IGESData_ParamReader::AddWarning, "None", py::arg("awarn"), py::arg("bwarn"));
cls_IGESData_ParamReader.def("AddWarning", (void (IGESData_ParamReader::*)(const opencascade::handle<TCollection_HAsciiString> &, const opencascade::handle<TCollection_HAsciiString> &)) &IGESData_ParamReader::AddWarning, "feeds the Check with a new Warning message", py::arg("aw"), py::arg("bw"));
cls_IGESData_ParamReader.def("Mend", [](IGESData_ParamReader &self) -> void { return self.Mend(); });
cls_IGESData_ParamReader.def("Mend", (void (IGESData_ParamReader::*)(const Standard_CString)) &IGESData_ParamReader::Mend, "None", py::arg("pref"));
cls_IGESData_ParamReader.def("HasFailed", (Standard_Boolean (IGESData_ParamReader::*)() const) &IGESData_ParamReader::HasFailed, "says if fails have been recorded into the Check");
cls_IGESData_ParamReader.def("Check", (const opencascade::handle<Interface_Check> & (IGESData_ParamReader::*)() const) &IGESData_ParamReader::Check, "returns the Check Note that any error signaled above is also recorded into it");
cls_IGESData_ParamReader.def("CCheck", (opencascade::handle<Interface_Check> & (IGESData_ParamReader::*)()) &IGESData_ParamReader::CCheck, "returns the check in a way which allows to work on it directly (i.e. messages added to the Check are added to ParamReader too)");
cls_IGESData_ParamReader.def("IsCheckEmpty", (Standard_Boolean (IGESData_ParamReader::*)() const) &IGESData_ParamReader::IsCheckEmpty, "Returns True if the Check is Empty Else, it has to be recorded with the Read Entity");

// Enums

}