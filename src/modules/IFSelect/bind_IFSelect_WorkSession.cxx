/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Standard_Transient.hxx>
#include <Standard_TypeDef.hxx>
#include <Standard_Handle.hxx>
#include <IFSelect_ShareOut.hxx>
#include <IFSelect_WorkLibrary.hxx>
#include <Interface_Protocol.hxx>
#include <IFSelect_Signature.hxx>
#include <Interface_InterfaceModel.hxx>
#include <IFSelect_ReturnStatus.hxx>
#include <TCollection_HAsciiString.hxx>
#include <Interface_HGraph.hxx>
#include <Interface_Graph.hxx>
#include <TColStd_HSequenceOfTransient.hxx>
#include <Interface_CheckIterator.hxx>
#include <TColStd_HSequenceOfInteger.hxx>
#include <Standard_Type.hxx>
#include <TColStd_HSequenceOfHAsciiString.hxx>
#include <IFSelect_IntParam.hxx>
#include <TCollection_AsciiString.hxx>
#include <IFSelect_Selection.hxx>
#include <Interface_EntityIterator.hxx>
#include <IFSelect_SelectionIterator.hxx>
#include <IFSelect_SignCounter.hxx>
#include <IFSelect_Dispatch.hxx>
#include <IFSelect_ModelCopier.hxx>
#include <IFSelect_GeneralModifier.hxx>
#include <IFSelect_Modifier.hxx>
#include <IFSelect_Transformer.hxx>
#include <IFSelect_PacketList.hxx>
#include <IFSelect_RemainMode.hxx>
#include <NCollection_Vector.hxx>
#include <Message_Messenger.hxx>
#include <IFSelect_PrintCount.hxx>
#include <IFSelect_SignatureList.hxx>
#include <IFSelect_WorkSession.hxx>
#include <TColStd_IndexedDataMapOfTransientTransient.hxx>
#include <NCollection_DataMap.hxx>
#include <Interface_GTool.hxx>

void bind_IFSelect_WorkSession(py::module &mod){

py::class_<IFSelect_WorkSession, opencascade::handle<IFSelect_WorkSession>, Standard_Transient> cls_IFSelect_WorkSession(mod, "IFSelect_WorkSession", "This class can be used to simply manage a process such as splitting a file, extracting a set of Entities ... It allows to manage different types of Variables : Integer or Text Parameters, Selections, Dispatches, in addition to a ShareOut. To each of these variables, a unique Integer Identifier is attached. A Name can be attached too as desired.");

// Constructors
cls_IFSelect_WorkSession.def(py::init<>());

// Fields

// Methods
cls_IFSelect_WorkSession.def("SetErrorHandle", (void (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::SetErrorHandle, "Changes the Error Handler status (by default, it is not set)", py::arg("toHandle"));
cls_IFSelect_WorkSession.def("ErrorHandle", (Standard_Boolean (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::ErrorHandle, "Returns the Error Handler status");
cls_IFSelect_WorkSession.def("ShareOut", (const opencascade::handle<IFSelect_ShareOut> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::ShareOut, "Returns the ShareOut defined at creation time");
cls_IFSelect_WorkSession.def("SetShareOut", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_ShareOut> &)) &IFSelect_WorkSession::SetShareOut, "Sets a new ShareOut. Fills Items which its content Warning : data from the former ShareOut are lost", py::arg("shareout"));
cls_IFSelect_WorkSession.def("SetModeStat", (void (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::SetModeStat, "Set value of mode responsible for precence of selections after loading If mode set to true that different selections will be accessible after loading else selections will be not accessible after loading( for economy memory in applicatios)", py::arg("theMode"));
cls_IFSelect_WorkSession.def("GetModeStat", (Standard_Boolean (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::GetModeStat, "Return value of mode defining of filling selection during loading");
cls_IFSelect_WorkSession.def("SetLibrary", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_WorkLibrary> &)) &IFSelect_WorkSession::SetLibrary, "Sets a WorkLibrary, which will be used to Read and Write Files", py::arg("theLib"));
cls_IFSelect_WorkSession.def("WorkLibrary", (const opencascade::handle<IFSelect_WorkLibrary> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::WorkLibrary, "Returns the WorkLibrary. Null Handle if not yet set should be C++ : return const &");
cls_IFSelect_WorkSession.def("SetProtocol", (void (IFSelect_WorkSession::*)(const opencascade::handle<Interface_Protocol> &)) &IFSelect_WorkSession::SetProtocol, "Sets a Protocol, which will be used to determine Graphs, to Read and to Write Files", py::arg("protocol"));
cls_IFSelect_WorkSession.def("Protocol", (const opencascade::handle<Interface_Protocol> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::Protocol, "Returns the Protocol. Null Handle if not yet set should be C++ : return const &");
cls_IFSelect_WorkSession.def("SetSignType", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Signature> &)) &IFSelect_WorkSession::SetSignType, "Sets a specific Signature to be the SignType, i.e. the Signature which will determine TypeName from the Model (basic function). It is recorded in the GTool This Signature is also set as 'xst-sign-type' (reserved name)", py::arg("signtype"));
cls_IFSelect_WorkSession.def("SignType", (opencascade::handle<IFSelect_Signature> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::SignType, "Returns the current SignType");
cls_IFSelect_WorkSession.def("HasModel", (Standard_Boolean (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::HasModel, "Returns True is a Model has been set");
cls_IFSelect_WorkSession.def("SetModel", [](IFSelect_WorkSession &self, const opencascade::handle<Interface_InterfaceModel> & a0) -> void { return self.SetModel(a0); });
cls_IFSelect_WorkSession.def("SetModel", (void (IFSelect_WorkSession::*)(const opencascade::handle<Interface_InterfaceModel> &, const Standard_Boolean)) &IFSelect_WorkSession::SetModel, "Sets a Model as input : this will be the Model from which the ShareOut will work if <clearpointed> is True (default) all SelectPointed items are cleared, else they must be managed by the caller Remark : SetModel clears the Graph, recomputes it if a Protocol is set and if the Model is not empty, of course", py::arg("model"), py::arg("clearpointed"));
cls_IFSelect_WorkSession.def("Model", (const opencascade::handle<Interface_InterfaceModel> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::Model, "Returns the Model of the Work Session (Null Handle if none) should be C++ : return const &");
cls_IFSelect_WorkSession.def("SetLoadedFile", (void (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::SetLoadedFile, "Stores the filename used for read for setting the model It is cleared by SetModel and ClearData(1)", py::arg("theFileName"));
cls_IFSelect_WorkSession.def("LoadedFile", (Standard_CString (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::LoadedFile, "Returns the filename used to load current model empty if unknown");
cls_IFSelect_WorkSession.def("ReadFile", (IFSelect_ReturnStatus (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::ReadFile, "Reads a file with the WorkLibrary (sets Model and LoadedFile) Returns a integer status which can be : RetDone if OK, RetVoid if no Protocol not defined, RetError for file not found, RetFail if fail during read", py::arg("filename"));
cls_IFSelect_WorkSession.def("NbStartingEntities", (Standard_Integer (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::NbStartingEntities, "Returns the count of Entities stored in the Model, or 0");
cls_IFSelect_WorkSession.def("StartingEntity", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::StartingEntity, "Returns an Entity stored in the Model of the WorkSession (Null Handle is no Model or num out of range)", py::arg("num"));
cls_IFSelect_WorkSession.def("StartingNumber", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::StartingNumber, "Returns the Number of an Entity in the Model (0 if no Model set or <ent> not in the Model)", py::arg("ent"));
cls_IFSelect_WorkSession.def("NumberFromLabel", [](IFSelect_WorkSession &self, const Standard_CString a0) -> Standard_Integer { return self.NumberFromLabel(a0); });
cls_IFSelect_WorkSession.def("NumberFromLabel", (Standard_Integer (IFSelect_WorkSession::*)(const Standard_CString, const Standard_Integer) const) &IFSelect_WorkSession::NumberFromLabel, "From a given label in Model, returns the corresponding number Starts from first entity by Default, may start after a given number : this number may be given negative, its absolute value is then considered. Hence a loop on NumberFromLabel may be programmed (stop test is : returned value positive or null)", py::arg("val"), py::arg("afternum"));
cls_IFSelect_WorkSession.def("EntityLabel", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::EntityLabel, "Returns the label for <ent>, as the Model does If <ent> is not in the Model or if no Model is loaded, a Null Handle is returned", py::arg("ent"));
cls_IFSelect_WorkSession.def("EntityName", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::EntityName, "Returns the Name of an Entity This Name is computed by the general service Name Returns a Null Handle if fails", py::arg("ent"));
cls_IFSelect_WorkSession.def("CategoryNumber", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::CategoryNumber, "Returns the Category Number determined for an entity it is computed by the class Category An unknown entity (number 0) gives a value -1", py::arg("ent"));
cls_IFSelect_WorkSession.def("CategoryName", (Standard_CString (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::CategoryName, "Returns the Category Name determined for an entity it is computed by the class Category Remark : an unknown entity gives an empty string", py::arg("ent"));
cls_IFSelect_WorkSession.def("ValidityName", (Standard_CString (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::ValidityName, "Returns the Validity Name determined for an entity it is computed by the class SignValidity Remark : an unknown entity gives an empty string", py::arg("ent"));
cls_IFSelect_WorkSession.def("ClearData", (void (IFSelect_WorkSession::*)(const Standard_Integer)) &IFSelect_WorkSession::ClearData, "Clears recorded data (not the items) according mode : 1 : all Data : Model, Graph, CheckList, + ClearData 4 2 : Graph and CheckList (they will then be recomputed later) 3 : CheckList (it will be recomputed by ComputeCheck) 4 : just content of SelectPointed and Counters Plus 0 : does nothing but called by SetModel ClearData is virtual, hence it can be redefined to clear other data of a specialised Work Session", py::arg("mode"));
cls_IFSelect_WorkSession.def("ComputeGraph", [](IFSelect_WorkSession &self) -> Standard_Boolean { return self.ComputeGraph(); });
cls_IFSelect_WorkSession.def("ComputeGraph", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::ComputeGraph, "Computes the Graph used for Selections, Displays ... If a HGraph is already set, with same model as given by method Model, does nothing. Else, computes a new Graph. If <enforce> is given True, computes a new Graph anyway. Remark that a call to ClearGraph will cause ComputeGraph to really compute a new Graph Returns True if Graph is OK, False else (i.e. if no Protocol is set, or if Model is absent or empty).", py::arg("enforce"));
cls_IFSelect_WorkSession.def("HGraph", (opencascade::handle<Interface_HGraph> (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::HGraph, "Returns the Computed Graph as HGraph (Null Handle if not set)");
cls_IFSelect_WorkSession.def("Graph", (const Interface_Graph & (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::Graph, "Returns the Computed Graph, for Read only");
cls_IFSelect_WorkSession.def("Shareds", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &)) &IFSelect_WorkSession::Shareds, "Returns the list of entities shared by <ent> (can be empty) Returns a null Handle if <ent> is unknown", py::arg("ent"));
cls_IFSelect_WorkSession.def("Sharings", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &)) &IFSelect_WorkSession::Sharings, "Returns the list of entities sharing <ent> (can be empty) Returns a null Handle if <ent> is unknown", py::arg("ent"));
cls_IFSelect_WorkSession.def("IsLoaded", (Standard_Boolean (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::IsLoaded, "Returns True if a Model is defined and really loaded (not empty), a Protocol is set and a Graph has been computed. In this case, the WorkSession can start to work");
cls_IFSelect_WorkSession.def("ComputeCheck", [](IFSelect_WorkSession &self) -> Standard_Boolean { return self.ComputeCheck(); });
cls_IFSelect_WorkSession.def("ComputeCheck", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::ComputeCheck, "Computes the CheckList for the Model currently loaded It can then be used for displays, querries ... Returns True if OK, False else (i.e. no Protocol set, or Model absent). If <enforce> is False, works only if not already done or if a new Model has been loaded from last call. Remark : computation is enforced by every call to SetModel or RunTransformer", py::arg("enforce"));
cls_IFSelect_WorkSession.def("ModelCheckList", [](IFSelect_WorkSession &self) -> Interface_CheckIterator { return self.ModelCheckList(); });
cls_IFSelect_WorkSession.def("ModelCheckList", (Interface_CheckIterator (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::ModelCheckList, "Returns the Check List for the Model currently loaded : <complete> = True : complete (syntactic & semantic messages), computed if not yet done <complete> = False : only syntactic (check file form)", py::arg("complete"));
cls_IFSelect_WorkSession.def("CheckOne", [](IFSelect_WorkSession &self, const opencascade::handle<Standard_Transient> & a0) -> Interface_CheckIterator { return self.CheckOne(a0); });
cls_IFSelect_WorkSession.def("CheckOne", (Interface_CheckIterator (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const Standard_Boolean)) &IFSelect_WorkSession::CheckOne, "Returns a Check for a single entity, under the form of a CheckIterator (this gives only one form for the user) if <ent> is Null or equates the current Model, it gives the Global Check, else the Check for the given entity <complete> as for ModelCheckList", py::arg("ent"), py::arg("complete"));
cls_IFSelect_WorkSession.def("LastRunCheckList", (Interface_CheckIterator (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::LastRunCheckList, "Returns the Check List produced by the last execution of either : EvaluateFile(for Split), SendSplit, SendAll, SendSelected, RunTransformer-RunModifier Cleared by SetModel or ClearData(1) The field is protected, hence a specialized WorkSession may fill it");
cls_IFSelect_WorkSession.def("MaxIdent", (Standard_Integer (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::MaxIdent, "Returns the Maximum Value for an Item Identifier. It can be greater to the count of known Items, because some can have been removed");
cls_IFSelect_WorkSession.def("Item", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::Item, "Returns an Item, given its Ident. Returns a Null Handle if no Item corresponds to this Ident.", py::arg("id"));
cls_IFSelect_WorkSession.def("ItemIdent", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::ItemIdent, "Returns the Ident attached to an Item in the WorkSession, or Zero if it is unknown", py::arg("item"));
cls_IFSelect_WorkSession.def("NamedItem", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::NamedItem, "Returns the Item which corresponds to a Variable, given its Name (whatever the type of this Item). Returns a Null Handle if this Name is not recorded", py::arg("name"));
cls_IFSelect_WorkSession.def("NamedItem", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const opencascade::handle<TCollection_HAsciiString> &) const) &IFSelect_WorkSession::NamedItem, "Same as above, but <name> is given through a Handle Especially Usefull with methods SelectionNames, etc...", py::arg("name"));
cls_IFSelect_WorkSession.def("NameIdent", (Standard_Integer (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::NameIdent, "Returns the Ident attached to a Name, 0 if name not recorded", py::arg("name"));
cls_IFSelect_WorkSession.def("HasName", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::HasName, "Returns True if an Item of the WorkSession has an attached Name", py::arg("item"));
cls_IFSelect_WorkSession.def("Name", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::Name, "Returns the Name attached to an Item as a Variable of this WorkSession. If <item> is Null or not recorded, returns an empty string.", py::arg("item"));
cls_IFSelect_WorkSession.def("AddItem", [](IFSelect_WorkSession &self, const opencascade::handle<Standard_Transient> & a0) -> Standard_Integer { return self.AddItem(a0); });
cls_IFSelect_WorkSession.def("AddItem", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const Standard_Boolean)) &IFSelect_WorkSession::AddItem, "Adds an Item and returns its attached Ident. Does nothing if <item> is already recorded (and returns its attached Ident) <active> if True commands call to SetActive (see below) Remark : the determined Ident is used if <item> is a Dispatch, to fill the ShareOut", py::arg("item"), py::arg("active"));
cls_IFSelect_WorkSession.def("AddNamedItem", [](IFSelect_WorkSession &self, const Standard_CString a0, const opencascade::handle<Standard_Transient> & a1) -> Standard_Integer { return self.AddNamedItem(a0, a1); });
cls_IFSelect_WorkSession.def("AddNamedItem", (Standard_Integer (IFSelect_WorkSession::*)(const Standard_CString, const opencascade::handle<Standard_Transient> &, const Standard_Boolean)) &IFSelect_WorkSession::AddNamedItem, "Adds an Item with an attached Name. If the Name is already known in the WorkSession, the older item losts it Returns Ident if Done, 0 else, i.e. if <item> is null If <name> is empty, works as AddItem (i.e. with no name) If <item> is already known but with no attached Name, this method tries to attached a Name to it <active> if True commands call to SetActive (see below)", py::arg("name"), py::arg("item"), py::arg("active"));
cls_IFSelect_WorkSession.def("SetActive", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const Standard_Boolean)) &IFSelect_WorkSession::SetActive, "Following the type of <item> : - Dispatch : Adds or Removes it in the ShareOut & FileNaming - GeneralModifier : Adds or Removes it for final sending (i.e. in the ModelCopier) Returns True if it did something, False else (state unchanged)", py::arg("item"), py::arg("mode"));
cls_IFSelect_WorkSession.def("RemoveNamedItem", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::RemoveNamedItem, "Removes an Item from the Session, given its Name Returns True if Done, False else (Name not recorded) (Applies only on Item which are Named)", py::arg("name"));
cls_IFSelect_WorkSession.def("RemoveName", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::RemoveName, "Removes a Name without removing the Item Returns True if Done, False else (Name not recorded)", py::arg("name"));
cls_IFSelect_WorkSession.def("RemoveItem", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &)) &IFSelect_WorkSession::RemoveItem, "Removes an Item given its Ident. Returns False if <id> is attached to no Item in the WorkSession. For a Named Item, also removes its Name.", py::arg("item"));
cls_IFSelect_WorkSession.def("ClearItems", (void (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::ClearItems, "Clears all the recorded Items : Selections, Dispatches, Modifiers, and Strings & IntParams, with their Idents & Names. Remark that if a Model has been loaded, it is not cleared.");
cls_IFSelect_WorkSession.def("ItemLabel", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::ItemLabel, "Returns a Label which illustrates the content of an Item, given its Ident. This Label is : - for a Text Parameter, 'Text:<text value>' - for an Integer Parameter, 'Integer:<integer value>' - for a Selection, a Dispatch or a Modifier, its Label (see these classes) - for any other kind of Variable, its cdl type", py::arg("id"));
cls_IFSelect_WorkSession.def("ItemIdents", (opencascade::handle<TColStd_HSequenceOfInteger> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Type> &) const) &IFSelect_WorkSession::ItemIdents, "Fills a Sequence with the List of Idents attached to the Items of which Type complies with (IsKind) <type> (alphabetic order) Remark : <type> = TYPE(Standard_Transient) gives all the Idents which are suitable in the WorkSession", py::arg("type"));
cls_IFSelect_WorkSession.def("ItemNames", (opencascade::handle<TColStd_HSequenceOfHAsciiString> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Type> &) const) &IFSelect_WorkSession::ItemNames, "Fills a Sequence with the list of the Names attached to Items of which Type complies with (IsKind) <type> (alphabetic order) Remark : <type> = TYPE(Standard_Transient) gives all the Names", py::arg("type"));
cls_IFSelect_WorkSession.def("ItemNamesForLabel", (opencascade::handle<TColStd_HSequenceOfHAsciiString> (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::ItemNamesForLabel, "Fills a Sequence with the NAMES of the control items, of which the label matches <label> (contain it) : see NextIdentForLabel Search mode is fixed to 'contained' If <label> is empty, returns all Names", py::arg("label"));
cls_IFSelect_WorkSession.def("NextIdentForLabel", [](IFSelect_WorkSession &self, const Standard_CString a0, const Standard_Integer a1) -> Standard_Integer { return self.NextIdentForLabel(a0, a1); });
cls_IFSelect_WorkSession.def("NextIdentForLabel", (Standard_Integer (IFSelect_WorkSession::*)(const Standard_CString, const Standard_Integer, const Standard_Integer) const) &IFSelect_WorkSession::NextIdentForLabel, "For query by Label with possible iterations Searches the Ident of which Item has a Label which matches a given one, the search starts from an initial Ident. Returns the first found Ident which follows <id>, or ZERO", py::arg("label"), py::arg("id"), py::arg("mode"));
cls_IFSelect_WorkSession.def("NewParamFromStatic", [](IFSelect_WorkSession &self, const Standard_CString a0) -> opencascade::handle<Standard_Transient> { return self.NewParamFromStatic(a0); });
cls_IFSelect_WorkSession.def("NewParamFromStatic", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const Standard_CString, const Standard_CString)) &IFSelect_WorkSession::NewParamFromStatic, "Creates a parameter as being bound to a Static If the Static is Integer, this creates an IntParam bound to it by its name. Else this creates a String which is the value of the Static. Returns a null handle if <statname> is unknown as a Static", py::arg("statname"), py::arg("name"));
cls_IFSelect_WorkSession.def("IntParam", (opencascade::handle<IFSelect_IntParam> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::IntParam, "Returns an IntParam, given its Ident in the Session Null result if <id> is not suitable for an IntParam (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("IntValue", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_IntParam> &) const) &IFSelect_WorkSession::IntValue, "Returns Integer Value of an IntParam", py::arg("it"));
cls_IFSelect_WorkSession.def("NewIntParam", [](IFSelect_WorkSession &self) -> opencascade::handle<IFSelect_IntParam> { return self.NewIntParam(); });
cls_IFSelect_WorkSession.def("NewIntParam", (opencascade::handle<IFSelect_IntParam> (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::NewIntParam, "Creates a new IntParam. A Name can be set (Optional) Returns the created IntParam, or a Null Handle in case of Failure (see AddItem/AddNamedItem)", py::arg("name"));
cls_IFSelect_WorkSession.def("SetIntValue", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_IntParam> &, const Standard_Integer)) &IFSelect_WorkSession::SetIntValue, "Changes the Integer Value of an IntParam Returns True if Done, False if <it> is not in the WorkSession", py::arg("it"), py::arg("val"));
cls_IFSelect_WorkSession.def("TextParam", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::TextParam, "Returns a TextParam, given its Ident in the Session Null result if <id> is not suitable for a TextParam (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("TextValue", (TCollection_AsciiString (IFSelect_WorkSession::*)(const opencascade::handle<TCollection_HAsciiString> &) const) &IFSelect_WorkSession::TextValue, "Returns Text Value of a TextParam (a String) or an empty string if <it> is not in the WorkSession", py::arg("par"));
cls_IFSelect_WorkSession.def("NewTextParam", [](IFSelect_WorkSession &self) -> opencascade::handle<TCollection_HAsciiString> { return self.NewTextParam(); });
cls_IFSelect_WorkSession.def("NewTextParam", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::NewTextParam, "Creates a new (empty) TextParam. A Name can be set (Optional) Returns the created TextParam (as an HAsciiString), or a Null Handle in case of Failure (see AddItem/AddNamedItem)", py::arg("name"));
cls_IFSelect_WorkSession.def("SetTextValue", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<TCollection_HAsciiString> &, const Standard_CString)) &IFSelect_WorkSession::SetTextValue, "Changes the Text Value of a TextParam (an HAsciiString) Returns True if Done, False if <it> is not in the WorkSession", py::arg("par"), py::arg("val"));
cls_IFSelect_WorkSession.def("Signature", (opencascade::handle<IFSelect_Signature> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::Signature, "Returns a Signature, given its Ident in the Session Null result if <id> is not suitable for a Signature (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("SignValue", (Standard_CString (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Signature> &, const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::SignValue, "Returns the Value computed by a Signature for an Entity Returns an empty string if the entity does not belong to the loaded model", py::arg("sign"), py::arg("ent"));
cls_IFSelect_WorkSession.def("Selection", (opencascade::handle<IFSelect_Selection> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::Selection, "Returns a Selection, given its Ident in the Session Null result if <id> is not suitable for a Selection (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("EvalSelection", (Interface_EntityIterator (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::EvalSelection, "Evaluates the effect of a Selection applied on the input Model Returned Result remains empty if no input Model has been set", py::arg("sel"));
cls_IFSelect_WorkSession.def("Sources", (IFSelect_SelectionIterator (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::Sources, "Returns the Selections which are source of Selection, given its rank in the List of Selections (see SelectionIterator) Returned value is empty if <num> is out of range or if <sel> is not in the WorkSession", py::arg("sel"));
cls_IFSelect_WorkSession.def("SelectionResult", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::SelectionResult, "Returns the result of a Selection, computed by EvalSelection (see above) under the form of a HSequence (hence, it can be used by a frontal-engine logic). It can be empty Returns a Null Handle if <sel> is not in the WorkSession", py::arg("sel"));
cls_IFSelect_WorkSession.def("SelectionResultFromList", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<TColStd_HSequenceOfTransient> &) const) &IFSelect_WorkSession::SelectionResultFromList, "Returns the result of a Selection, by forcing its input with a given list <list> (unless <list> is Null). RULES : <list> applies only for a SelectDeduct kind Selection : its Input is considered : if it is a SelectDeduct kind Selection, its Input is considered, etc... until an Input is not a Deduct/Extract : its result is replaced by <list> and all the chain of deductions is applied", py::arg("sel"), py::arg("list"));
cls_IFSelect_WorkSession.def("SetItemSelection", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<IFSelect_Selection> &)) &IFSelect_WorkSession::SetItemSelection, "Sets a Selection as input for an item, according its type : if <item> is a Dispatch : as Final Selection if <item> is a GeneralModifier (i.e. any kind of Modifier) : as Selection used to filter entities to modify <sel> Null causes this Selection to be nullified Returns False if <item> is not of a suitable type, or <item> or <sel> is not in the WorkSession", py::arg("item"), py::arg("sel"));
cls_IFSelect_WorkSession.def("ResetItemSelection", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &)) &IFSelect_WorkSession::ResetItemSelection, "Resets input Selection which was set by SetItemSelection Same conditions as for SetItemSelection Returns True if done, False if <item> is not in the WorkSession", py::arg("item"));
cls_IFSelect_WorkSession.def("ItemSelection", (opencascade::handle<IFSelect_Selection> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::ItemSelection, "Returns the Selection of a Dispatch or a GeneralModifier. Returns a Null Handle if none is defined or <item> not good type", py::arg("item"));
cls_IFSelect_WorkSession.def("SignCounter", (opencascade::handle<IFSelect_SignCounter> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::SignCounter, "Returns a SignCounter from its ident in the Session Null result if <id> is not suitable for a SignCounter (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("ComputeCounter", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_SignCounter> & a0) -> Standard_Boolean { return self.ComputeCounter(a0); });
cls_IFSelect_WorkSession.def("ComputeCounter", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_SignCounter> &, const Standard_Boolean)) &IFSelect_WorkSession::ComputeCounter, "Computes the content of a SignCounter when it is defined with a Selection, then returns True Returns False if the SignCounter is not defined with a Selection, or if its Selection Mode is inhibited <forced> to work around optimisations", py::arg("counter"), py::arg("forced"));
cls_IFSelect_WorkSession.def("ComputeCounterFromList", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_SignCounter> & a0, const opencascade::handle<TColStd_HSequenceOfTransient> & a1) -> Standard_Boolean { return self.ComputeCounterFromList(a0, a1); });
cls_IFSelect_WorkSession.def("ComputeCounterFromList", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_SignCounter> &, const opencascade::handle<TColStd_HSequenceOfTransient> &, const Standard_Boolean)) &IFSelect_WorkSession::ComputeCounterFromList, "Computes the content of a SignCounter from an input list If <list> is Null, uses internal definition of the Counter : a Selection, else the whole Model (recomputation forced) If <clear> is True (D), starts from scratch Else, cumulates computations", py::arg("counter"), py::arg("list"), py::arg("clear"));
cls_IFSelect_WorkSession.def("AppliedDispatches", (opencascade::handle<TColStd_HSequenceOfInteger> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::AppliedDispatches, "Returns the ordered list of dispatches stored by the ShareOut");
cls_IFSelect_WorkSession.def("ClearShareOut", (void (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::ClearShareOut, "Clears the list of Dispatches recorded by the ShareOut if <only> disp is True, tha's all. Else, clears also the lists of Modifiers recorded by the ShareOut", py::arg("onlydisp"));
cls_IFSelect_WorkSession.def("Dispatch", (opencascade::handle<IFSelect_Dispatch> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::Dispatch, "Returns a Dispatch, given its Ident in the Session Null result if <id> is not suitable for a Dispatch (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("DispatchRank", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Dispatch> &) const) &IFSelect_WorkSession::DispatchRank, "Returns the rank of a Dispatch in the ShareOut, or 0 if <disp> is not in the ShareOut or not in the WorkSession", py::arg("disp"));
cls_IFSelect_WorkSession.def("ModelCopier", (const opencascade::handle<IFSelect_ModelCopier> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::ModelCopier, "Gives access to the complete ModelCopier");
cls_IFSelect_WorkSession.def("SetModelCopier", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_ModelCopier> &)) &IFSelect_WorkSession::SetModelCopier, "Sets a new ModelCopier. Fills Items which its content", py::arg("copier"));
cls_IFSelect_WorkSession.def("NbFinalModifiers", (Standard_Integer (IFSelect_WorkSession::*)(const Standard_Boolean) const) &IFSelect_WorkSession::NbFinalModifiers, "Returns the count of Modifiers applied to final sending Model Modifiers if <formodel> is True, File Modifiers else (i.e. Modifiers which apply once the Models have been filled)", py::arg("formodel"));
cls_IFSelect_WorkSession.def("FinalModifierIdents", (opencascade::handle<TColStd_HSequenceOfInteger> (IFSelect_WorkSession::*)(const Standard_Boolean) const) &IFSelect_WorkSession::FinalModifierIdents, "Fills a Sequence with a list of Idents, those attached to the Modifiers applied to final sending. Model Modifiers if <formodel> is True, File Modifiers else This list is given in the order in which they will be applied (which takes into account the Changes to Modifier Ranks)", py::arg("formodel"));
cls_IFSelect_WorkSession.def("GeneralModifier", (opencascade::handle<IFSelect_GeneralModifier> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::GeneralModifier, "Returns a Modifier, given its Ident in the Session Null result if <id> is not suitable for a Modifier (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("ModelModifier", (opencascade::handle<IFSelect_Modifier> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::ModelModifier, "Returns a Model Modifier, given its Ident in the Session, i.e. typed as a Modifier (not simply a GeneralModifier) Null result if <id> is not suitable for a Modifier (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("ModifierRank", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_GeneralModifier> &) const) &IFSelect_WorkSession::ModifierRank, "Returns the Rank of a Modifier given its Ident. Model or File Modifier according its type (ModelModifier or not) Remember that Modifiers are applied sequencially following their Rank : first Model Modifiers then File Modifiers Rank is given by rank of call to AddItem and can be changed by ChangeModifierRank", py::arg("item"));
cls_IFSelect_WorkSession.def("ChangeModifierRank", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_Boolean, const Standard_Integer, const Standard_Integer)) &IFSelect_WorkSession::ChangeModifierRank, "Changes the Rank of a Modifier in the Session : Model Modifiers if <formodel> is True, File Modifiers else the Modifier n0 <before> is put to n0 <after> Return True if Done, False if <before> or <after> out of range", py::arg("formodel"), py::arg("before"), py::arg("after"));
cls_IFSelect_WorkSession.def("ClearFinalModifiers", (void (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::ClearFinalModifiers, "Removes all the Modifiers active in the ModelCopier : they become inactive and they are removed from the Session");
cls_IFSelect_WorkSession.def("SetAppliedModifier", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_GeneralModifier> &, const opencascade::handle<Standard_Transient> &)) &IFSelect_WorkSession::SetAppliedModifier, "Sets a GeneralModifier to be applied to an item : - item = ShareOut : applies for final sending (all dispatches) - item is a Dispatch : applies for this dispatch only Returns True if done, False if <modif> or <item> not in <me>", py::arg("modif"), py::arg("item"));
cls_IFSelect_WorkSession.def("ResetAppliedModifier", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_GeneralModifier> &)) &IFSelect_WorkSession::ResetAppliedModifier, "Resets a GeneralModifier to be applied Returns True if done, False if <modif> was not applied", py::arg("modif"));
cls_IFSelect_WorkSession.def("UsesAppliedModifier", (opencascade::handle<Standard_Transient> (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_GeneralModifier> &) const) &IFSelect_WorkSession::UsesAppliedModifier, "Returns the item on which a GeneralModifier is applied : the ShareOut, or a given Dispatch Returns a Null Handle if <modif> is not applied", py::arg("modif"));
cls_IFSelect_WorkSession.def("Transformer", (opencascade::handle<IFSelect_Transformer> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::Transformer, "Returns a Transformer, given its Ident in the Session Null result if <id> is not suitable for a Transformer (undefined, or defined for another kind of variable)", py::arg("id"));
cls_IFSelect_WorkSession.def("RunTransformer", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Transformer> &)) &IFSelect_WorkSession::RunTransformer, "Runs a Transformer on starting Model, which can then be edited or replaced by a new one. The Protocol can also be changed. Fills LastRunCheckList", py::arg("transf"));
cls_IFSelect_WorkSession.def("RunModifier", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Modifier> &, const Standard_Boolean)) &IFSelect_WorkSession::RunModifier, "Runs a Modifier on Starting Model. It can modify entities, or add new ones. But the Model or the Protocol is unchanged. The Modifier is applied on each entity of the Model. See also RunModifierSelected Fills LastRunCheckList", py::arg("modif"), py::arg("copy"));
cls_IFSelect_WorkSession.def("RunModifierSelected", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Modifier> &, const opencascade::handle<IFSelect_Selection> &, const Standard_Boolean)) &IFSelect_WorkSession::RunModifierSelected, "Acts as RunModifier, but the Modifier is applied on the list determined by a Selection, rather than on the whole Model If the selection is a null handle, the whole model is taken", py::arg("modif"), py::arg("sel"), py::arg("copy"));
cls_IFSelect_WorkSession.def("NewTransformStandard", [](IFSelect_WorkSession &self, const Standard_Boolean a0) -> opencascade::handle<IFSelect_Transformer> { return self.NewTransformStandard(a0); });
cls_IFSelect_WorkSession.def("NewTransformStandard", (opencascade::handle<IFSelect_Transformer> (IFSelect_WorkSession::*)(const Standard_Boolean, const Standard_CString)) &IFSelect_WorkSession::NewTransformStandard, "Creates and returns a TransformStandard, empty, with its Copy Option (True = Copy, False = On the Spot) and an optional name. To a TransformStandard, the method SetAppliedModifier applies", py::arg("copy"), py::arg("name"));
cls_IFSelect_WorkSession.def("SetModelContent", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const Standard_Boolean)) &IFSelect_WorkSession::SetModelContent, "Defines a new content from the former one If <keep> is True, it is given by entities selected by Selection <sel> (and all shared entities) Else, it is given by all the former content but entities selected by the Selection <sel> (and properly shared ones) Returns True if done. Returns False if the selected list (from <sel>) is empty, hence nothing is done", py::arg("sel"), py::arg("keep"));
cls_IFSelect_WorkSession.def("FilePrefix", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::FilePrefix, "Returns the defined File Prefix. Null Handle if not defined");
cls_IFSelect_WorkSession.def("DefaultFileRoot", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::DefaultFileRoot, "Returns the defined Default File Root. It is used for Dispatches which have no specific root attached. Null Handle if not defined");
cls_IFSelect_WorkSession.def("FileExtension", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::FileExtension, "Returns the defined File Extension. Null Handle if not defined");
cls_IFSelect_WorkSession.def("FileRoot", (opencascade::handle<TCollection_HAsciiString> (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Dispatch> &) const) &IFSelect_WorkSession::FileRoot, "Returns the File Root defined for a Dispatch. Null if no Root Name is defined for it (hence, no File will be produced)", py::arg("disp"));
cls_IFSelect_WorkSession.def("SetFilePrefix", (void (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::SetFilePrefix, "Defines a File Prefix", py::arg("name"));
cls_IFSelect_WorkSession.def("SetDefaultFileRoot", (Standard_Boolean (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::SetDefaultFileRoot, "Defines a Default File Root Name. Clears it is <name> = '' Returns True if OK, False if <name> already set for a Dispatch", py::arg("name"));
cls_IFSelect_WorkSession.def("SetFileExtension", (void (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::SetFileExtension, "Defines a File Extension", py::arg("name"));
cls_IFSelect_WorkSession.def("SetFileRoot", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Dispatch> &, const Standard_CString)) &IFSelect_WorkSession::SetFileRoot, "Defines a Root for a Dispatch If <name> is empty, clears Root Name This has as effect to inhibit the production of File by <disp> Returns False if <disp> is not in the WorkSession or if a root name is already defined for it", py::arg("disp"), py::arg("name"));
cls_IFSelect_WorkSession.def("GiveFileRoot", (Standard_CString (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::GiveFileRoot, "Extracts File Root Name from a given complete file name (uses OSD_Path)", py::arg("file"));
cls_IFSelect_WorkSession.def("GiveFileComplete", (Standard_CString (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::GiveFileComplete, "Completes a file name as required, with Prefix and Extension (if defined; for a non-defined item, completes nothing)", py::arg("file"));
cls_IFSelect_WorkSession.def("ClearFile", (void (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::ClearFile, "Erases all stored data from the File Evaluation (i.e. ALL former naming informations are lost)");
cls_IFSelect_WorkSession.def("EvaluateFile", (void (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::EvaluateFile, "Performs and stores a File Evaluation. The Results are a List of produced Models and a List of names (Strings), in parallel Fills LastRunCheckList");
cls_IFSelect_WorkSession.def("NbFiles", (Standard_Integer (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::NbFiles, "Returns the count of produced Models");
cls_IFSelect_WorkSession.def("FileModel", (opencascade::handle<Interface_InterfaceModel> (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::FileModel, "Returns a Model, given its rank in the Evaluation List", py::arg("num"));
cls_IFSelect_WorkSession.def("FileName", (TCollection_AsciiString (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::FileName, "Returns the name of a file corresponding to a produced Model, given its rank in the Evaluation List", py::arg("num"));
cls_IFSelect_WorkSession.def("BeginSentFiles", (void (IFSelect_WorkSession::*)(const Standard_Boolean)) &IFSelect_WorkSession::BeginSentFiles, "Commands file sending to clear the list of already sent files, commands to record a new one if <record> is True This list is managed by the ModelCopier when SendSplit is called It allows a global exploitation of the set of sent files", py::arg("record"));
cls_IFSelect_WorkSession.def("SentFiles", (opencascade::handle<TColStd_HSequenceOfHAsciiString> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::SentFiles, "Returns the list of recorded sent files, or a Null Handle is recording has not been enabled");
cls_IFSelect_WorkSession.def("SendSplit", (Standard_Boolean (IFSelect_WorkSession::*)()) &IFSelect_WorkSession::SendSplit, "Performs creation of derived files from the input Model Takes its data (sub-models and names), from result EvaluateFile if active, else by dynamic Evaluation (not stored) After SendSplit, result of EvaluateFile is Cleared Fills LastRunCheckList");
cls_IFSelect_WorkSession.def("EvalSplit", (opencascade::handle<IFSelect_PacketList> (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::EvalSplit, "Returns an Evaluation of the whole ShareOut definition : i.e. how the entities of the starting model are forecast to be sent to various files : list of packets according the dispatches, effective lists of roots for each packet (which determine the content of the corresponding file); plus evaluation of which entities are : forgotten (sent into no file), duplicated (sent into more than one file), sent into a given file. See the class PacketList for more details.");
cls_IFSelect_WorkSession.def("SentList", [](IFSelect_WorkSession &self) -> Interface_EntityIterator { return self.SentList(); });
cls_IFSelect_WorkSession.def("SentList", (Interface_EntityIterator (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::SentList, "Returns the list of Entities sent in files, accourding the count of files each one has been sent (these counts are reset by SetModel or SetRemaining(Forget) ) stored in Graph Status <count> = -1 (default) is for ENtities sent at least once <count> = 0 is for the Remaining List (entities not yet sent) <count> = 1 is for entities sent in one and only one file (the ideal case) Remaining Data are computed on each Sending/Copying output files (see methods EvaluateFile and SendSplit) Graph Status is 0 for Remaining Entity, <count> for Sent into <count> files This status is set to 0 (not yet sent) for all by SetModel and by SetRemaining(mode=Forget,Display)", py::arg("count"));
cls_IFSelect_WorkSession.def("MaxSendingCount", (Standard_Integer (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::MaxSendingCount, "Returns the greater count of different files in which any of the starting entities could be sent. Before any file output, this count is 0. Ideal count is 1. More than 1 means that duplications occur.");
cls_IFSelect_WorkSession.def("SetRemaining", (Standard_Boolean (IFSelect_WorkSession::*)(const IFSelect_RemainMode)) &IFSelect_WorkSession::SetRemaining, "Processes Remaining data (after having sent files), mode : Forget : forget remaining info (i.e. clear all 'Sent' status) Compute : compute and keep remaining (does nothing if : remaining is empty or if no files has been sent) Display : display entities recorded as remaining Undo : restore former state of data (after Remaining(1) ) Returns True if OK, False else (i.e. mode = 2 and Remaining List is either empty or takes all the entities, or mode = 3 and no former computation of remaining data was done)", py::arg("mode"));
cls_IFSelect_WorkSession.def("SendAll", [](IFSelect_WorkSession &self, const Standard_CString a0) -> IFSelect_ReturnStatus { return self.SendAll(a0); });
cls_IFSelect_WorkSession.def("SendAll", (IFSelect_ReturnStatus (IFSelect_WorkSession::*)(const Standard_CString, const Standard_Boolean)) &IFSelect_WorkSession::SendAll, "Sends the starting Model into one file, without splitting, managing remaining data or anything else. <computegraph> true commands the Graph to be recomputed before sending : required when a Model is filled in several steps", py::arg("filename"), py::arg("computegraph"));
cls_IFSelect_WorkSession.def("SendSelected", [](IFSelect_WorkSession &self, const Standard_CString a0, const opencascade::handle<IFSelect_Selection> & a1) -> IFSelect_ReturnStatus { return self.SendSelected(a0, a1); });
cls_IFSelect_WorkSession.def("SendSelected", (IFSelect_ReturnStatus (IFSelect_WorkSession::*)(const Standard_CString, const opencascade::handle<IFSelect_Selection> &, const Standard_Boolean)) &IFSelect_WorkSession::SendSelected, "Sends a part of the starting Model into one file, without splitting. But remaining data are managed. <computegraph> true commands the Graph to be recomputed before sending : required when a Model is filled in several steps", py::arg("filename"), py::arg("sel"), py::arg("computegraph"));
cls_IFSelect_WorkSession.def("WriteFile", (IFSelect_ReturnStatus (IFSelect_WorkSession::*)(const Standard_CString)) &IFSelect_WorkSession::WriteFile, "Writes the current Interface Model globally to a File, and returns a write status which can be : Done OK, Fail file could not be written, Error no norm is selected Remark : It is a simple, one-file writing, other operations are available (such as splitting ...) which calls SendAll", py::arg("filename"));
cls_IFSelect_WorkSession.def("WriteFile", (IFSelect_ReturnStatus (IFSelect_WorkSession::*)(const Standard_CString, const opencascade::handle<IFSelect_Selection> &)) &IFSelect_WorkSession::WriteFile, "Writes a sub-part of the current Interface Model to a File, as defined by a Selection <sel>, recomputes the Graph, and returns a write status which can be : Done OK, Fail file could not be written, Error no norm is selected Remark : It is a simple, one-file writing, other operations are available (such as splitting ...) which calls SendSelected", py::arg("filename"), py::arg("sel"));
cls_IFSelect_WorkSession.def("NbSources", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::NbSources, "Returns the count of Input Selections known for a Selection, or 0 if <sel> not in the WorkSession. This count is one for a SelectDeduct / SelectExtract kind, two for SelectControl kind, variable for a SelectCombine (Union/Intersection), zero else", py::arg("sel"));
cls_IFSelect_WorkSession.def("Source", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_Selection> & a0) -> opencascade::handle<IFSelect_Selection> { return self.Source(a0); });
cls_IFSelect_WorkSession.def("Source", (opencascade::handle<IFSelect_Selection> (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const Standard_Integer) const) &IFSelect_WorkSession::Source, "Returns the <num>th Input Selection of a Selection (see NbSources). Returns a Null Handle if <sel> is not in the WorkSession or if <num> is out of the range <1-NbSources> To obtain more details, see the method Sources", py::arg("sel"), py::arg("num"));
cls_IFSelect_WorkSession.def("IsReversedSelectExtract", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::IsReversedSelectExtract, "Returns True if <sel> a Reversed SelectExtract, False else", py::arg("sel"));
cls_IFSelect_WorkSession.def("ToggleSelectExtract", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &)) &IFSelect_WorkSession::ToggleSelectExtract, "Toggles the Sense (Direct <-> Reversed) of a SelectExtract Returns True if Done, False if <sel> is not a SelectExtract or is not in the WorkSession", py::arg("sel"));
cls_IFSelect_WorkSession.def("SetInputSelection", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<IFSelect_Selection> &)) &IFSelect_WorkSession::SetInputSelection, "Sets an Input Selection (as <input>) to a SelectExtract or a SelectDeduct (as <sel>). Returns True if Done, False if <sel> is neither a SelectExtract nor a SelectDeduct, or not in the WorkSession", py::arg("sel"), py::arg("input"));
cls_IFSelect_WorkSession.def("SetControl", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_Selection> & a0, const opencascade::handle<IFSelect_Selection> & a1) -> Standard_Boolean { return self.SetControl(a0, a1); });
cls_IFSelect_WorkSession.def("SetControl", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<IFSelect_Selection> &, const Standard_Boolean)) &IFSelect_WorkSession::SetControl, "Sets an Input Selection, Main if <formain> is True, Second else (as <sc>) to a SelectControl (as <sel>). Returns True if Done, False if <sel> is not a SelectControl, or <sc> or <sel> is not in the WorkSession", py::arg("sel"), py::arg("sc"), py::arg("formain"));
cls_IFSelect_WorkSession.def("CombineAdd", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_Selection> & a0, const opencascade::handle<IFSelect_Selection> & a1) -> Standard_Integer { return self.CombineAdd(a0, a1); });
cls_IFSelect_WorkSession.def("CombineAdd", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<IFSelect_Selection> &, const Standard_Integer)) &IFSelect_WorkSession::CombineAdd, "Adds an input selection to a SelectCombine (Union or Inters.). Returns new count of inputs for this SelectCombine if Done or 0 if <sel> is not kind of SelectCombine, or if <seladd> or <sel> is not in the WorkSession By default, adding is done at the end of the list Else, it is an insertion to rank <atnum> (usefull for Un-ReDo)", py::arg("selcomb"), py::arg("seladd"), py::arg("atnum"));
cls_IFSelect_WorkSession.def("CombineRemove", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<IFSelect_Selection> &)) &IFSelect_WorkSession::CombineRemove, "Removes an input selection from a SelectCombine (Union or Intersection). Returns True if done, False if <selcomb> is not kind of SelectCombine or <selrem> is not source of <selcomb>", py::arg("selcomb"), py::arg("selrem"));
cls_IFSelect_WorkSession.def("NewSelectPointed", (opencascade::handle<IFSelect_Selection> (IFSelect_WorkSession::*)(const opencascade::handle<TColStd_HSequenceOfTransient> &, const Standard_CString)) &IFSelect_WorkSession::NewSelectPointed, "Creates a new Selection, of type SelectPointed, its content starts with <list>. A name must be given (can be empty)", py::arg("list"), py::arg("name"));
cls_IFSelect_WorkSession.def("SetSelectPointed", (Standard_Boolean (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &, const opencascade::handle<TColStd_HSequenceOfTransient> &, const Standard_Integer) const) &IFSelect_WorkSession::SetSelectPointed, "Changes the content of a Selection of type SelectPointed According <mode> : 0 set <list> as new content (clear former) 1 : adds <list> to actual content -1 : removes <list> from actual content Returns True if done, False if <sel> is not a SelectPointed", py::arg("sel"), py::arg("list"), py::arg("mode"));
cls_IFSelect_WorkSession.def("GiveSelection", (opencascade::handle<IFSelect_Selection> (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::GiveSelection, "Returns a Selection from a Name : - the name of a Selection : this Selection - the name of a Signature + criteria between (..) : a new Selection from this Signature - an entity or a list of entities : a new SelectPointed Else, returns a Null Handle", py::arg("selname"));
cls_IFSelect_WorkSession.def("GiveList", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::GiveList, "Determines a list of entities from an object : <obj> already HSequenceOfTransient : returned itself <obj> Selection : its Result of Evaluation is returned <obj> an entity of the Model : a HSequence which contains it else, an empty HSequence <obj> the Model it self : ALL its content (not only the roots)", py::arg("obj"));
cls_IFSelect_WorkSession.def("GiveList", [](IFSelect_WorkSession &self, const Standard_CString a0) -> opencascade::handle<TColStd_HSequenceOfTransient> { return self.GiveList(a0); });
cls_IFSelect_WorkSession.def("GiveList", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const Standard_CString, const Standard_CString) const) &IFSelect_WorkSession::GiveList, "Computes a List of entities from two alphanums, first and second, as follows : if <first> is a Number or Label of an entity : this entity if <first> is a list of Numbers/Labels : the list of entities if <first> is the name of a Selection in <WS>, and <second> not defined, the standard result of this Selection else, let's consider 'first second' : this whole phrase is splitted by blanks, as follows (RECURSIVE CALL) : - the leftest term is the final selection - the other terms define the result of the selection - and so on (the 'leftest minus one' is a selection, of which the input is given by the remaining ...)", py::arg("first"), py::arg("second"));
cls_IFSelect_WorkSession.def("GiveListFromList", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const Standard_CString, const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::GiveListFromList, "Computes a List of entities from the model as follows <first> beeing a Selection or a combination of Selections, <ent> beeing an entity or a list of entities (as a HSequenceOfTransient) : the standard result of this selection applied to this list if <ent> is Null, the standard definition of the selection is used (which contains a default input selection) if <selname> is erroneous, a null handle is returned", py::arg("selname"), py::arg("ent"));
cls_IFSelect_WorkSession.def("GiveListCombined", (opencascade::handle<TColStd_HSequenceOfTransient> (IFSelect_WorkSession::*)(const opencascade::handle<TColStd_HSequenceOfTransient> &, const opencascade::handle<TColStd_HSequenceOfTransient> &, const Standard_Integer) const) &IFSelect_WorkSession::GiveListCombined, "Combines two lists and returns the result, according to mode : <mode> < 0 : entities in <l1> AND NOT in <l2> <mode> = 0 : entities in <l1> AND in <l2> <mode> > 0 : entities in <l1> OR in <l2>", py::arg("l1"), py::arg("l2"), py::arg("mode"));
cls_IFSelect_WorkSession.def("QueryCheckList", (void (IFSelect_WorkSession::*)(const Interface_CheckIterator &)) &IFSelect_WorkSession::QueryCheckList, "Loads data from a check iterator to query status on it", py::arg("chl"));
cls_IFSelect_WorkSession.def("QueryCheckStatus", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::QueryCheckStatus, "Determines check status for an entity regarding last call to QueryCheckList : -1 : <ent> unknown in the model, ignored 0 : no check at all, immediate or inherited thru Graph 1 : immediate warning (no fail), no inherited check 2 : immediate fail, no inherited check +10 : idem but some inherited warning (no fail) +20 : idem but some inherited fail", py::arg("ent"));
cls_IFSelect_WorkSession.def("QueryParent", (Standard_Integer (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Standard_Transient> &) const) &IFSelect_WorkSession::QueryParent, "Determines if <entdad> is parent of <entson> (in the graph), returns : -1 if no; 0 if <entdad> = <entson> 1 if immediate parent, > 1 if parent, gives count of steps", py::arg("entdad"), py::arg("entson"));
cls_IFSelect_WorkSession.def("SetParams", (void (IFSelect_WorkSession::*)(const NCollection_Vector<opencascade::handle<Standard_Transient> > &, const NCollection_Vector<Standard_Integer> &)) &IFSelect_WorkSession::SetParams, "Sets a list of Parameters, i.e. TypedValue, to be handled through an Editor The two lists are parallel, if <params> is longer than <uses>, surnumeral parameters are for general use", py::arg("params"), py::arg("uselist"));
cls_IFSelect_WorkSession.def("TraceStatics", [](IFSelect_WorkSession &self, const Standard_Integer a0) -> void { return self.TraceStatics(a0); });
cls_IFSelect_WorkSession.def("TraceStatics", (void (IFSelect_WorkSession::*)(const Standard_Integer, const Standard_Integer) const) &IFSelect_WorkSession::TraceStatics, "Traces the Statics attached to a given use number If <use> is given positive (normal), the trace is embedded with a header and a trailer If <use> is negative, just values are printed (this allows to make compositions) Remark : use number 5 commands use -2 to be traced Remark : use numbers 4 and 6 command use -3 to be traced", py::arg("use"), py::arg("mode"));
cls_IFSelect_WorkSession.def("DumpShare", (void (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::DumpShare, "Dumps contents of the ShareOut (on 'cout')");
cls_IFSelect_WorkSession.def("ListItems", [](IFSelect_WorkSession &self) -> void { return self.ListItems(); });
cls_IFSelect_WorkSession.def("ListItems", (void (IFSelect_WorkSession::*)(const Standard_CString) const) &IFSelect_WorkSession::ListItems, "Lists the Labels of all Items of the WorkSession If <label> is defined, lists labels which contain it", py::arg("label"));
cls_IFSelect_WorkSession.def("ListFinalModifiers", (void (IFSelect_WorkSession::*)(const Standard_Boolean) const) &IFSelect_WorkSession::ListFinalModifiers, "Lists the Modifiers of the session (for each one, displays its Label). Listing is done following Ranks (Modifiers are invoked following their ranks) Model Modifiers if <formodel> is True, File Modifiers else", py::arg("formodel"));
cls_IFSelect_WorkSession.def("DumpSelection", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::DumpSelection, "Lists a Selection and its Sources (see SelectionIterator), given its rank in the list", py::arg("sel"));
cls_IFSelect_WorkSession.def("DumpModel", (void (IFSelect_WorkSession::*)(const Standard_Integer, const opencascade::handle<Message_Messenger> &)) &IFSelect_WorkSession::DumpModel, "Lists the content of the Input Model (if there is one) According level : 0 -> gives only count of Entities and Roots 1 -> Lists also Roots; 2 -> Lists all Entities (by TraceType) 3 -> Performs a call to CheckList (Fails) and lists the result 4 -> as 3 but all CheckList (Fails + Warnings) 5,6,7 : as 3 but resp. Count,List,Labels by Fail 8,9,10 : as 4 but resp. Count,List,Labels by message", py::arg("level"), py::arg("S"));
cls_IFSelect_WorkSession.def("TraceDumpModel", (void (IFSelect_WorkSession::*)(const Standard_Integer)) &IFSelect_WorkSession::TraceDumpModel, "Dumps the current Model (as inherited DumpModel), on currently defined Default Trace File (default is standard output)", py::arg("mode"));
cls_IFSelect_WorkSession.def("DumpEntity", (void (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer, const opencascade::handle<Message_Messenger> &) const) &IFSelect_WorkSession::DumpEntity, "Dumps a starting entity according to the current norm. To do this, it calls DumpEntity from WorkLibrary. <level> is to be interpreted for each norm : see specific classes of WorkLibrary for it. Generally, 0 if for very basic (only type ...), greater values give more and more details.", py::arg("ent"), py::arg("level"), py::arg("S"));
cls_IFSelect_WorkSession.def("PrintEntityStatus", (void (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const opencascade::handle<Message_Messenger> &)) &IFSelect_WorkSession::PrintEntityStatus, "Prints main informations about an entity : its number, type, validity (and checks if any), category, shareds and sharings.. mutable because it can recompute checks as necessary", py::arg("ent"), py::arg("S"));
cls_IFSelect_WorkSession.def("TraceDumpEntity", (void (IFSelect_WorkSession::*)(const opencascade::handle<Standard_Transient> &, const Standard_Integer) const) &IFSelect_WorkSession::TraceDumpEntity, "Dumps an entity from the current Model as inherited DumpEntity on currently defined Default Trace File (<level> interpreted according to the Norm, see WorkLibrary)", py::arg("ent"), py::arg("level"));
cls_IFSelect_WorkSession.def("PrintCheckList", (void (IFSelect_WorkSession::*)(const Interface_CheckIterator &, const Standard_Boolean, const IFSelect_PrintCount) const) &IFSelect_WorkSession::PrintCheckList, "Prints a CheckIterator to the current Trace File, controlled with the current Model complete or fails only, according to <failsonly> <mode> defines the mode of printing 0 : sequential, according entities; else with a CheckCounter 1 : according messages, count of entities 2 : id but with list of entities, designated by their numbers 3 : as 2 but with labels of entities", py::arg("checklist"), py::arg("failsonly"), py::arg("mode"));
cls_IFSelect_WorkSession.def("PrintSignatureList", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_SignatureList> &, const IFSelect_PrintCount) const) &IFSelect_WorkSession::PrintSignatureList, "Prints a SignatureList to the current Trace File, controlled with the current Model <mode> defines the mode of printing (see SignatureList)", py::arg("signlist"), py::arg("mode"));
cls_IFSelect_WorkSession.def("EvaluateSelection", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Selection> &) const) &IFSelect_WorkSession::EvaluateSelection, "Displays the list of Entities selected by a Selection (i.e. the result of EvalSelection).", py::arg("sel"));
cls_IFSelect_WorkSession.def("EvaluateDispatch", [](IFSelect_WorkSession &self, const opencascade::handle<IFSelect_Dispatch> & a0) -> void { return self.EvaluateDispatch(a0); });
cls_IFSelect_WorkSession.def("EvaluateDispatch", (void (IFSelect_WorkSession::*)(const opencascade::handle<IFSelect_Dispatch> &, const Standard_Integer) const) &IFSelect_WorkSession::EvaluateDispatch, "Displays the result of applying a Dispatch on the input Model (also shows Remainder if there is) <mode> = 0 (default), displays nothing else <mode> = 1 : displays also duplicated entities (because of this dispatch) <mode> = 2 : displays the entities of the starting Model which are not taken by this dispatch (forgotten entities) <mode> = 3 : displays both duplicated and forgotten entities Remark : EvaluateComplete displays these data evaluated for for all the dispatches, if there are several", py::arg("disp"), py::arg("mode"));
cls_IFSelect_WorkSession.def("EvaluateComplete", [](IFSelect_WorkSession &self) -> void { return self.EvaluateComplete(); });
cls_IFSelect_WorkSession.def("EvaluateComplete", (void (IFSelect_WorkSession::*)(const Standard_Integer) const) &IFSelect_WorkSession::EvaluateComplete, "Displays the effect of applying the ShareOut on the input Model. <mode> = 0 (default) : displays only roots for each packet, <mode> = 1 : displays all entities for each packet, plus duplicated entities <mode> = 2 : same as <mode> = 1, plus displays forgotten entities (which are in no packet at all)", py::arg("mode"));
cls_IFSelect_WorkSession.def("ListEntities", (void (IFSelect_WorkSession::*)(const Interface_EntityIterator &, const Standard_Integer) const) &IFSelect_WorkSession::ListEntities, "Internal method which displays an EntityIterator <mode> 0 gives short display (only entity numbers) 1 gives a more complete trace (1 line per Entity) (can be used each time a trace has to be output from a list) 2 gives a form suitable for givelist : (n1,n2,n3...)", py::arg("iter"), py::arg("mode"));
cls_IFSelect_WorkSession.def_static("get_type_name_", (const char * (*)()) &IFSelect_WorkSession::get_type_name, "None");
cls_IFSelect_WorkSession.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &IFSelect_WorkSession::get_type_descriptor, "None");
cls_IFSelect_WorkSession.def("DynamicType", (const opencascade::handle<Standard_Type> & (IFSelect_WorkSession::*)() const) &IFSelect_WorkSession::DynamicType, "None");

// Enums

}