/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Geom_BoundedCurve.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <Standard_TypeDef.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <GeomAbs_Shape.hxx>
#include <GeomAbs_BSplKnotDistribution.hxx>
#include <gp_Trsf.hxx>
#include <Standard_Handle.hxx>
#include <Geom_Geometry.hxx>
#include <Geom_BSplineCurve.hxx>
#include <Standard_Type.hxx>
#include <TColgp_HArray1OfPnt.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <TColStd_HArray1OfInteger.hxx>

void bind_Geom_BSplineCurve(py::module &mod){

py::class_<Geom_BSplineCurve, opencascade::handle<Geom_BSplineCurve>, Geom_BoundedCurve> cls_Geom_BSplineCurve(mod, "Geom_BSplineCurve", "Definition of the B_spline curve. A B-spline curve can be Uniform or non-uniform Rational or non-rational Periodic or non-periodic");

// Constructors
cls_Geom_BSplineCurve.def(py::init<const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("Poles"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"));
cls_Geom_BSplineCurve.def(py::init<const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"), py::arg("Periodic"));
cls_Geom_BSplineCurve.def(py::init<const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer>(), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"));
cls_Geom_BSplineCurve.def(py::init<const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"), py::arg("Periodic"));
cls_Geom_BSplineCurve.def(py::init<const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Poles"), py::arg("Weights"), py::arg("Knots"), py::arg("Multiplicities"), py::arg("Degree"), py::arg("Periodic"), py::arg("CheckRational"));

// Fields

// Methods
cls_Geom_BSplineCurve.def("IncreaseDegree", (void (Geom_BSplineCurve::*)(const Standard_Integer)) &Geom_BSplineCurve::IncreaseDegree, "Increases the degree of this BSpline curve to Degree. As a result, the poles, weights and multiplicities tables are modified; the knots table is not changed. Nothing is done if Degree is less than or equal to the current degree. Exceptions Standard_ConstructionError if Degree is greater than Geom_BSplineCurve::MaxDegree().", py::arg("Degree"));
cls_Geom_BSplineCurve.def("IncreaseMultiplicity", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Integer)) &Geom_BSplineCurve::IncreaseMultiplicity, "Increases the multiplicity of the knot <Index> to <M>.", py::arg("Index"), py::arg("M"));
cls_Geom_BSplineCurve.def("IncreaseMultiplicity", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineCurve::IncreaseMultiplicity, "Increases the multiplicities of the knots in [I1,I2] to <M>.", py::arg("I1"), py::arg("I2"), py::arg("M"));
cls_Geom_BSplineCurve.def("IncrementMultiplicity", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineCurve::IncrementMultiplicity, "Increment the multiplicities of the knots in [I1,I2] by <M>.", py::arg("I1"), py::arg("I2"), py::arg("M"));
cls_Geom_BSplineCurve.def("InsertKnot", [](Geom_BSplineCurve &self, const Standard_Real a0) -> void { return self.InsertKnot(a0); });
cls_Geom_BSplineCurve.def("InsertKnot", [](Geom_BSplineCurve &self, const Standard_Real a0, const Standard_Integer a1) -> void { return self.InsertKnot(a0, a1); });
cls_Geom_BSplineCurve.def("InsertKnot", [](Geom_BSplineCurve &self, const Standard_Real a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.InsertKnot(a0, a1, a2); });
cls_Geom_BSplineCurve.def("InsertKnot", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Boolean)) &Geom_BSplineCurve::InsertKnot, "Inserts a knot value in the sequence of knots. If <U> is an existing knot the multiplicity is increased by <M>.", py::arg("U"), py::arg("M"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineCurve.def("InsertKnots", [](Geom_BSplineCurve &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1) -> void { return self.InsertKnots(a0, a1); });
cls_Geom_BSplineCurve.def("InsertKnots", [](Geom_BSplineCurve &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1, const Standard_Real a2) -> void { return self.InsertKnots(a0, a1, a2); });
cls_Geom_BSplineCurve.def("InsertKnots", (void (Geom_BSplineCurve::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &Geom_BSplineCurve::InsertKnots, "Inserts a set of knots values in the sequence of knots.", py::arg("Knots"), py::arg("Mults"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineCurve.def("RemoveKnot", (Standard_Boolean (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom_BSplineCurve::RemoveKnot, "Reduces the multiplicity of the knot of index Index to M. If M is equal to 0, the knot is removed. With a modification of this type, the array of poles is also modified. Two different algorithms are systematically used to compute the new poles of the curve. If, for each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is less than Tolerance, this ensures that the curve is not modified by more than Tolerance. Under these conditions, true is returned; otherwise, false is returned. A low tolerance is used to prevent modification of the curve. A high tolerance is used to 'smooth' the curve. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table. pole insertion and pole removing this operation is limited to the Uniform or QuasiUniform BSplineCurve. The knot values are modified . If the BSpline is NonUniform or Piecewise Bezier an exception Construction error is raised.", py::arg("Index"), py::arg("M"), py::arg("Tolerance"));
cls_Geom_BSplineCurve.def("Reverse", (void (Geom_BSplineCurve::*)()) &Geom_BSplineCurve::Reverse, "Changes the direction of parametrization of <me>. The Knot sequence is modified, the FirstParameter and the LastParameter are not modified. The StartPoint of the initial curve becomes the EndPoint of the reversed curve and the EndPoint of the initial curve becomes the StartPoint of the reversed curve.");
cls_Geom_BSplineCurve.def("ReversedParameter", (Standard_Real (Geom_BSplineCurve::*)(const Standard_Real) const) &Geom_BSplineCurve::ReversedParameter, "Returns the parameter on the reversed curve for the point of parameter U on <me>.", py::arg("U"));
cls_Geom_BSplineCurve.def("Segment", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Real)) &Geom_BSplineCurve::Segment, "Modifies this BSpline curve by segmenting it between U1 and U2. Either of these values can be outside the bounds of the curve, but U2 must be greater than U1. All data structure tables of this BSpline curve are modified, but the knots located between U1 and U2 are retained. The degree of the curve is not modified. Warnings : Even if <me> is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the curve <me> or if the curve makes loop. After the segmentation the length of a curve can be null. raises if U2 < U1. Standard_DomainError if U2 - U1 exceeds the period for periodic curves. i.e. ((U2 - U1) - Period) > Precision::PConfusion().", py::arg("U1"), py::arg("U2"));
cls_Geom_BSplineCurve.def("SetKnot", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Real)) &Geom_BSplineCurve::SetKnot, "Modifies this BSpline curve by assigning the value K to the knot of index Index in the knots table. This is a relatively local modification because K must be such that: Knots(Index - 1) < K < Knots(Index + 1) The second syntax allows you also to increase the multiplicity of the knot to M (but it is not possible to decrease the multiplicity of the knot with this function). Standard_ConstructionError if: - K is not such that: Knots(Index - 1) < K < Knots(Index + 1) - M is greater than the degree of this BSpline curve or lower than the previous multiplicity of knot of index Index in the knots table. Standard_OutOfRange if Index is outside the bounds of the knots table.", py::arg("Index"), py::arg("K"));
cls_Geom_BSplineCurve.def("SetKnots", (void (Geom_BSplineCurve::*)(const TColStd_Array1OfReal &)) &Geom_BSplineCurve::SetKnots, "Modifies this BSpline curve by assigning the array K to its knots table. The multiplicity of the knots is not modified. Exceptions Standard_ConstructionError if the values in the array K are not in ascending order. Standard_OutOfRange if the bounds of the array K are not respectively 1 and the number of knots of this BSpline curve.", py::arg("K"));
cls_Geom_BSplineCurve.def("SetKnot", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Real, const Standard_Integer)) &Geom_BSplineCurve::SetKnot, "Changes the knot of range Index with its multiplicity. You can increase the multiplicity of a knot but it is not allowed to decrease the multiplicity of an existing knot.", py::arg("Index"), py::arg("K"), py::arg("M"));
cls_Geom_BSplineCurve.def("PeriodicNormalization", [](Geom_BSplineCurve &self, Standard_Real & U){ self.PeriodicNormalization(U); return U; }, "returns the parameter normalized within the period if the curve is periodic : otherwise does not do anything", py::arg("U"));
cls_Geom_BSplineCurve.def("SetPeriodic", (void (Geom_BSplineCurve::*)()) &Geom_BSplineCurve::SetPeriodic, "Changes this BSpline curve into a periodic curve. To become periodic, the curve must first be closed. Next, the knot sequence must be periodic. For this, FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2, the indexes in the knots array of the knots corresponding to the first and last parameters of this BSpline curve. The period is therefore: Knots(I2) - Knots(I1). Consequently, the knots and poles tables are modified. Exceptions Standard_ConstructionError if this BSpline curve is not closed.");
cls_Geom_BSplineCurve.def("SetOrigin", (void (Geom_BSplineCurve::*)(const Standard_Integer)) &Geom_BSplineCurve::SetOrigin, "Assigns the knot of index Index in the knots table as the origin of this periodic BSpline curve. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this curve is not periodic. Standard_DomainError if Index is outside the bounds of the knots table.", py::arg("Index"));
cls_Geom_BSplineCurve.def("SetOrigin", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Real)) &Geom_BSplineCurve::SetOrigin, "Set the origin of a periodic curve at Knot U. If U is not a knot of the BSpline a new knot is inseted. KnotVector and poles are modified. Raised if the curve is not periodic", py::arg("U"), py::arg("Tol"));
cls_Geom_BSplineCurve.def("SetNotPeriodic", (void (Geom_BSplineCurve::*)()) &Geom_BSplineCurve::SetNotPeriodic, "Changes this BSpline curve into a non-periodic curve. If this curve is already non-periodic, it is not modified. Note: the poles and knots tables are modified. Warning If this curve is periodic, as the multiplicity of the first and last knots is not modified, and is not equal to Degree + 1, where Degree is the degree of this BSpline curve, the start and end points of the curve are not its first and last poles.");
cls_Geom_BSplineCurve.def("SetPole", (void (Geom_BSplineCurve::*)(const Standard_Integer, const gp_Pnt &)) &Geom_BSplineCurve::SetPole, "Modifies this BSpline curve by assigning P to the pole of index Index in the poles table. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table. Standard_ConstructionError if Weight is negative or null.", py::arg("Index"), py::arg("P"));
cls_Geom_BSplineCurve.def("SetPole", (void (Geom_BSplineCurve::*)(const Standard_Integer, const gp_Pnt &, const Standard_Real)) &Geom_BSplineCurve::SetPole, "Modifies this BSpline curve by assigning P to the pole of index Index in the poles table. This syntax also allows you to modify the weight of the modified pole, which becomes Weight. In this case, if this BSpline curve is non-rational, it can become rational and vice versa. Exceptions Standard_OutOfRange if Index is outside the bounds of the poles table. Standard_ConstructionError if Weight is negative or null.", py::arg("Index"), py::arg("P"), py::arg("Weight"));
cls_Geom_BSplineCurve.def("SetWeight", (void (Geom_BSplineCurve::*)(const Standard_Integer, const Standard_Real)) &Geom_BSplineCurve::SetWeight, "Changes the weight for the pole of range Index. If the curve was non rational it can become rational. If the curve was rational it can become non rational.", py::arg("Index"), py::arg("Weight"));
cls_Geom_BSplineCurve.def("MovePoint", [](Geom_BSplineCurve &self, const Standard_Real U, const gp_Pnt & P, const Standard_Integer Index1, const Standard_Integer Index2, Standard_Integer & FirstModifiedPole, Standard_Integer & LastModifiedPole){ self.MovePoint(U, P, Index1, Index2, FirstModifiedPole, LastModifiedPole); return std::tuple<Standard_Integer &, Standard_Integer &>(FirstModifiedPole, LastModifiedPole); }, "Moves the point of parameter U of this BSpline curve to P. Index1 and Index2 are the indexes in the table of poles of this BSpline curve of the first and last poles designated to be moved. FirstModifiedPole and LastModifiedPole are the indexes of the first and last poles which are effectively modified. In the event of incompatibility between Index1, Index2 and the value U: - no change is made to this BSpline curve, and - the FirstModifiedPole and LastModifiedPole are returned null. Exceptions Standard_OutOfRange if: - Index1 is greater than or equal to Index2, or - Index1 or Index2 is less than 1 or greater than the number of poles of this BSpline curve.", py::arg("U"), py::arg("P"), py::arg("Index1"), py::arg("Index2"), py::arg("FirstModifiedPole"), py::arg("LastModifiedPole"));
cls_Geom_BSplineCurve.def("MovePointAndTangent", [](Geom_BSplineCurve &self, const Standard_Real U, const gp_Pnt & P, const gp_Vec & Tangent, const Standard_Real Tolerance, const Standard_Integer StartingCondition, const Standard_Integer EndingCondition, Standard_Integer & ErrorStatus){ self.MovePointAndTangent(U, P, Tangent, Tolerance, StartingCondition, EndingCondition, ErrorStatus); return ErrorStatus; }, "Move a point with parameter U to P. and makes it tangent at U be Tangent. StartingCondition = -1 means first can move EndingCondition = -1 means last point can move StartingCondition = 0 means the first point cannot move EndingCondition = 0 means the last point cannot move StartingCondition = 1 means the first point and tangent cannot move EndingCondition = 1 means the last point and tangent cannot move and so forth ErrorStatus != 0 means that there are not enought degree of freedom with the constrain to deform the curve accordingly", py::arg("U"), py::arg("P"), py::arg("Tangent"), py::arg("Tolerance"), py::arg("StartingCondition"), py::arg("EndingCondition"), py::arg("ErrorStatus"));
cls_Geom_BSplineCurve.def("IsCN", (Standard_Boolean (Geom_BSplineCurve::*)(const Standard_Integer) const) &Geom_BSplineCurve::IsCN, "Returns the continuity of the curve, the curve is at least C0. Raised if N < 0.", py::arg("N"));
cls_Geom_BSplineCurve.def("IsG1", (Standard_Boolean (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Real, const Standard_Real) const) &Geom_BSplineCurve::IsG1, "Check if curve has at least G1 continuity in interval [theTf, theTl] Returns true if IsCN(1) or angle betweem 'left' and 'right' first derivatives at knots with C0 continuity is less then theAngTol only knots in interval [theTf, theTl] is checked", py::arg("theTf"), py::arg("theTl"), py::arg("theAngTol"));
cls_Geom_BSplineCurve.def("IsClosed", (Standard_Boolean (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::IsClosed, "Returns true if the distance between the first point and the last point of the curve is lower or equal to Resolution from package gp. Warnings : The first and the last point can be different from the first pole and the last pole of the curve.");
cls_Geom_BSplineCurve.def("IsPeriodic", (Standard_Boolean (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::IsPeriodic, "Returns True if the curve is periodic.");
cls_Geom_BSplineCurve.def("IsRational", (Standard_Boolean (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::IsRational, "Returns True if the weights are not identical. The tolerance criterion is Epsilon of the class Real.");
cls_Geom_BSplineCurve.def("Continuity", (GeomAbs_Shape (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Continuity, "Returns the global continuity of the curve : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Curve, C2 : continuity of the second derivative all along the Curve, C3 : continuity of the third derivative all along the Curve, CN : the order of continuity is infinite. For a B-spline curve of degree d if a knot Ui has a multiplicity p the B-spline curve is only Cd-p continuous at Ui. So the global continuity of the curve can't be greater than Cd-p where p is the maximum multiplicity of the interior Knots. In the interior of a knot span the curve is infinitely continuously differentiable.");
cls_Geom_BSplineCurve.def("Degree", (Standard_Integer (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Degree, "Returns the degree of this BSpline curve. The degree of a Geom_BSplineCurve curve cannot be greater than Geom_BSplineCurve::MaxDegree(). Computation of value and derivatives");
cls_Geom_BSplineCurve.def("D0", (void (Geom_BSplineCurve::*)(const Standard_Real, gp_Pnt &) const) &Geom_BSplineCurve::D0, "Returns in P the point of parameter U.", py::arg("U"), py::arg("P"));
cls_Geom_BSplineCurve.def("D1", (void (Geom_BSplineCurve::*)(const Standard_Real, gp_Pnt &, gp_Vec &) const) &Geom_BSplineCurve::D1, "Raised if the continuity of the curve is not C1.", py::arg("U"), py::arg("P"), py::arg("V1"));
cls_Geom_BSplineCurve.def("D2", (void (Geom_BSplineCurve::*)(const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &) const) &Geom_BSplineCurve::D2, "Raised if the continuity of the curve is not C2.", py::arg("U"), py::arg("P"), py::arg("V1"), py::arg("V2"));
cls_Geom_BSplineCurve.def("D3", (void (Geom_BSplineCurve::*)(const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineCurve::D3, "Raised if the continuity of the curve is not C3.", py::arg("U"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
cls_Geom_BSplineCurve.def("DN", (gp_Vec (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer) const) &Geom_BSplineCurve::DN, "For the point of parameter U of this BSpline curve, computes the vector corresponding to the Nth derivative. Warning On a point where the continuity of the curve is not the one requested, this function impacts the part defined by the parameter with a value greater than U, i.e. the part of the curve to the 'right' of the singularity. Exceptions Standard_RangeError if N is less than 1.", py::arg("U"), py::arg("N"));
cls_Geom_BSplineCurve.def("LocalValue", (gp_Pnt (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer) const) &Geom_BSplineCurve::LocalValue, "Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"));
cls_Geom_BSplineCurve.def("LocalD0", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt &) const) &Geom_BSplineCurve::LocalD0, "Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"));
cls_Geom_BSplineCurve.def("LocalD1", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &) const) &Geom_BSplineCurve::LocalD1, "Raised if the local continuity of the curve is not C1 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"));
cls_Geom_BSplineCurve.def("LocalD2", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &, gp_Vec &) const) &Geom_BSplineCurve::LocalD2, "Raised if the local continuity of the curve is not C2 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"), py::arg("V2"));
cls_Geom_BSplineCurve.def("LocalD3", (void (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineCurve::LocalD3, "Raised if the local continuity of the curve is not C3 between the knot K1 and the knot K2. Raised if FromK1 = ToK2.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("P"), py::arg("V1"), py::arg("V2"), py::arg("V3"));
cls_Geom_BSplineCurve.def("LocalDN", (gp_Vec (Geom_BSplineCurve::*)(const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer) const) &Geom_BSplineCurve::LocalDN, "Raised if the local continuity of the curve is not CN between the knot K1 and the knot K2. Raised if FromK1 = ToK2. Raised if N < 1.", py::arg("U"), py::arg("FromK1"), py::arg("ToK2"), py::arg("N"));
cls_Geom_BSplineCurve.def("EndPoint", (gp_Pnt (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::EndPoint, "Returns the last point of the curve. Warnings : The last point of the curve is different from the last pole of the curve if the multiplicity of the last knot is lower than Degree.");
cls_Geom_BSplineCurve.def("FirstUKnotIndex", (Standard_Integer (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::FirstUKnotIndex, "Returns the index in the knot array of the knot corresponding to the first or last parameter of this BSpline curve. For a BSpline curve, the first (or last) parameter (which gives the start (or end) point of the curve) is a knot value. However, if the multiplicity of the first (or last) knot is less than Degree + 1, where Degree is the degree of the curve, it is not the first (or last) knot of the curve.");
cls_Geom_BSplineCurve.def("FirstParameter", (Standard_Real (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::FirstParameter, "Returns the value of the first parameter of this BSpline curve. This is a knot value. The first parameter is the one of the start point of the BSpline curve.");
cls_Geom_BSplineCurve.def("Knot", (Standard_Real (Geom_BSplineCurve::*)(const Standard_Integer) const) &Geom_BSplineCurve::Knot, "Returns the knot of range Index. When there is a knot with a multiplicity greater than 1 the knot is not repeated. The method Multiplicity can be used to get the multiplicity of the Knot. Raised if Index < 1 or Index > NbKnots", py::arg("Index"));
cls_Geom_BSplineCurve.def("Knots", (void (Geom_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom_BSplineCurve::Knots, "returns the knot values of the B-spline curve; Warning A knot with a multiplicity greater than 1 is not repeated in the knot table. The Multiplicity function can be used to obtain the multiplicity of each knot.", py::arg("K"));
cls_Geom_BSplineCurve.def("Knots", (const TColStd_Array1OfReal & (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Knots, "returns the knot values of the B-spline curve; Warning A knot with a multiplicity greater than 1 is not repeated in the knot table. The Multiplicity function can be used to obtain the multiplicity of each knot.");
cls_Geom_BSplineCurve.def("KnotSequence", (void (Geom_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom_BSplineCurve::KnotSequence, "Returns K, the knots sequence of this BSpline curve. In this sequence, knots with a multiplicity greater than 1 are repeated. In the case of a non-periodic curve the length of the sequence must be equal to the sum of the NbKnots multiplicities of the knots of the curve (where NbKnots is the number of knots of this BSpline curve). This sum is also equal to : NbPoles + Degree + 1 where NbPoles is the number of poles and Degree the degree of this BSpline curve. In the case of a periodic curve, if there are k periodic knots, the period is Knot(k+1) - Knot(1). The initial sequence is built by writing knots 1 to k+1, which are repeated according to their corresponding multiplicities. If Degree is the degree of the curve, the degree of continuity of the curve at the knot of index 1 (or k+1) is equal to c = Degree + 1 - Mult(1). c knots are then inserted at the beginning and end of the initial sequence: - the c values of knots preceding the first item Knot(k+1) in the initial sequence are inserted at the beginning; the period is subtracted from these c values; - the c values of knots following the last item Knot(1) in the initial sequence are inserted at the end; the period is added to these c values. The length of the sequence must therefore be equal to: NbPoles + 2*Degree - Mult(1) + 2. Example For a non-periodic BSpline curve of degree 2 where: - the array of knots is: { k1 k2 k3 k4 }, - with associated multiplicities: { 3 1 2 3 }, the knot sequence is: K = { k1 k1 k1 k2 k3 k3 k4 k4 k4 } For a periodic BSpline curve of degree 4 , which is 'C1' continuous at the first knot, and where : - the periodic knots are: { k1 k2 k3 (k4) } (3 periodic knots: the points of parameter k1 and k4 are identical, the period is p = k4 - k1), - with associated multiplicities: { 3 1 2 (3) }, the degree of continuity at knots k1 and k4 is: Degree + 1 - Mult(i) = 2. 2 supplementary knots are added at the beginning and end of the sequence: - at the beginning: the 2 knots preceding k4 minus the period; in this example, this is k3 - p both times; - at the end: the 2 knots following k1 plus the period; in this example, this is k2 + p and k3 + p. The knot sequence is therefore: K = { k3-p k3-p k1 k1 k1 k2 k3 k3 k4 k4 k4 k2+p k3+p } Exceptions Raised if K.Lower() is less than number of first knot in knot sequence with repetitions or K.Upper() is more than number of last knot in knot sequence with repetitions.", py::arg("K"));
cls_Geom_BSplineCurve.def("KnotSequence", (const TColStd_Array1OfReal & (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::KnotSequence, "returns the knots of the B-spline curve. Knots with multiplicit greater than 1 are repeated");
cls_Geom_BSplineCurve.def("KnotDistribution", (GeomAbs_BSplKnotDistribution (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::KnotDistribution, "Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot the BSpline Curve can be : - Uniform if all the knots are of multiplicity 1, - QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1, - PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree A piecewise Bezier with only two knots is a BezierCurve. else the curve is non uniform. The tolerance criterion is Epsilon from class Real.");
cls_Geom_BSplineCurve.def("LastUKnotIndex", (Standard_Integer (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::LastUKnotIndex, "For a BSpline curve the last parameter (which gives the end point of the curve) is a knot value but if the multiplicity of the last knot index is lower than Degree + 1 it is not the last knot of the curve. This method computes the index of the knot corresponding to the last parameter.");
cls_Geom_BSplineCurve.def("LastParameter", (Standard_Real (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::LastParameter, "Computes the parametric value of the end point of the curve. It is a knot value.");
cls_Geom_BSplineCurve.def("LocateU", [](Geom_BSplineCurve &self, const Standard_Real U, const Standard_Real ParametricTolerance, Standard_Integer & I1, Standard_Integer & I2, const Standard_Boolean WithKnotRepetition){ self.LocateU(U, ParametricTolerance, I1, I2, WithKnotRepetition); return std::tuple<Standard_Integer &, Standard_Integer &>(I1, I2); }, "Locates the parametric value U in the sequence of knots. If 'WithKnotRepetition' is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. Knots (I1) <= U <= Knots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 < 1 => U < Knots (1) - Abs(ParametricTolerance) . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)", py::arg("U"), py::arg("ParametricTolerance"), py::arg("I1"), py::arg("I2"), py::arg("WithKnotRepetition"));
cls_Geom_BSplineCurve.def("Multiplicity", (Standard_Integer (Geom_BSplineCurve::*)(const Standard_Integer) const) &Geom_BSplineCurve::Multiplicity, "Returns the multiplicity of the knots of range Index. Raised if Index < 1 or Index > NbKnots", py::arg("Index"));
cls_Geom_BSplineCurve.def("Multiplicities", (void (Geom_BSplineCurve::*)(TColStd_Array1OfInteger &) const) &Geom_BSplineCurve::Multiplicities, "Returns the multiplicity of the knots of the curve.", py::arg("M"));
cls_Geom_BSplineCurve.def("Multiplicities", (const TColStd_Array1OfInteger & (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Multiplicities, "returns the multiplicity of the knots of the curve.");
cls_Geom_BSplineCurve.def("NbKnots", (Standard_Integer (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::NbKnots, "Returns the number of knots. This method returns the number of knot without repetition of multiple knots.");
cls_Geom_BSplineCurve.def("NbPoles", (Standard_Integer (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::NbPoles, "Returns the number of poles");
cls_Geom_BSplineCurve.def("Pole", (const gp_Pnt & (Geom_BSplineCurve::*)(const Standard_Integer) const) &Geom_BSplineCurve::Pole, "Returns the pole of range Index. Raised if Index < 1 or Index > NbPoles.", py::arg("Index"));
cls_Geom_BSplineCurve.def("Poles", (void (Geom_BSplineCurve::*)(TColgp_Array1OfPnt &) const) &Geom_BSplineCurve::Poles, "Returns the poles of the B-spline curve;", py::arg("P"));
cls_Geom_BSplineCurve.def("Poles", (const TColgp_Array1OfPnt & (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Poles, "Returns the poles of the B-spline curve;");
cls_Geom_BSplineCurve.def("StartPoint", (gp_Pnt (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::StartPoint, "Returns the start point of the curve. Warnings : This point is different from the first pole of the curve if the multiplicity of the first knot is lower than Degree.");
cls_Geom_BSplineCurve.def("Weight", (Standard_Real (Geom_BSplineCurve::*)(const Standard_Integer) const) &Geom_BSplineCurve::Weight, "Returns the weight of the pole of range Index . Raised if Index < 1 or Index > NbPoles.", py::arg("Index"));
cls_Geom_BSplineCurve.def("Weights", (void (Geom_BSplineCurve::*)(TColStd_Array1OfReal &) const) &Geom_BSplineCurve::Weights, "Returns the weights of the B-spline curve;", py::arg("W"));
cls_Geom_BSplineCurve.def("Weights", (const TColStd_Array1OfReal * (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Weights, "Returns the weights of the B-spline curve;");
cls_Geom_BSplineCurve.def("Transform", (void (Geom_BSplineCurve::*)(const gp_Trsf &)) &Geom_BSplineCurve::Transform, "Applies the transformation T to this BSpline curve.", py::arg("T"));
cls_Geom_BSplineCurve.def_static("MaxDegree_", (Standard_Integer (*)()) &Geom_BSplineCurve::MaxDegree, "Returns the value of the maximum degree of the normalized B-spline basis functions in this package.");
cls_Geom_BSplineCurve.def("Resolution", [](Geom_BSplineCurve &self, const Standard_Real Tolerance3D, Standard_Real & UTolerance){ self.Resolution(Tolerance3D, UTolerance); return UTolerance; }, "Computes for this BSpline curve the parametric tolerance UTolerance for a given 3D tolerance Tolerance3D. If f(t) is the equation of this BSpline curve, UTolerance ensures that: | t1 - t0| < Utolerance ===> |f(t1) - f(t0)| < Tolerance3D", py::arg("Tolerance3D"), py::arg("UTolerance"));
cls_Geom_BSplineCurve.def("Copy", (opencascade::handle<Geom_Geometry> (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::Copy, "Creates a new object which is a copy of this BSpline curve.");
cls_Geom_BSplineCurve.def("IsEqual", (Standard_Boolean (Geom_BSplineCurve::*)(const opencascade::handle<Geom_BSplineCurve> &, const Standard_Real) const) &Geom_BSplineCurve::IsEqual, "Comapare two Bspline curve on identity;", py::arg("theOther"), py::arg("thePreci"));
cls_Geom_BSplineCurve.def_static("get_type_name_", (const char * (*)()) &Geom_BSplineCurve::get_type_name, "None");
cls_Geom_BSplineCurve.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Geom_BSplineCurve::get_type_descriptor, "None");
cls_Geom_BSplineCurve.def("DynamicType", (const opencascade::handle<Standard_Type> & (Geom_BSplineCurve::*)() const) &Geom_BSplineCurve::DynamicType, "None");

// Enums

}