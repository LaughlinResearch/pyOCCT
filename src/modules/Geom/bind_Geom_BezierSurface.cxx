/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Geom_BoundedSurface.hxx>
#include <TColgp_Array2OfPnt.hxx>
#include <TColStd_Array2OfReal.hxx>
#include <Standard_TypeDef.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <gp_Pnt.hxx>
#include <GeomAbs_Shape.hxx>
#include <gp_Vec.hxx>
#include <Standard_Handle.hxx>
#include <Geom_Curve.hxx>
#include <BSplSLib.hxx>
#include <gp_Trsf.hxx>
#include <Geom_Geometry.hxx>
#include <Geom_BezierSurface.hxx>
#include <Standard_Type.hxx>
#include <TColgp_HArray2OfPnt.hxx>
#include <TColStd_HArray2OfReal.hxx>

void bind_Geom_BezierSurface(py::module &mod){

py::class_<Geom_BezierSurface, opencascade::handle<Geom_BezierSurface>, Geom_BoundedSurface> cls_Geom_BezierSurface(mod, "Geom_BezierSurface", "Describes a rational or non-rational Bezier surface. - A non-rational Bezier surface is defined by a table of poles (also known as control points). - A rational Bezier surface is defined by a table of poles with varying associated weights. This data is manipulated using two associative 2D arrays: - the poles table, which is a 2D array of gp_Pnt, and - the weights table, which is a 2D array of reals. The bounds of these arrays are: - 1 and NbUPoles for the row bounds, where NbUPoles is the number of poles of the surface in the u parametric direction, and - 1 and NbVPoles for the column bounds, where NbVPoles is the number of poles of the surface in the v parametric direction. The poles of the surface, the 'control points', are the points used to shape and reshape the surface. They comprise a rectangular network of points: - The points (1, 1), (NbUPoles, 1), (1, NbVPoles) and (NbUPoles, NbVPoles) are the four parametric 'corners' of the surface. - The first column of poles and the last column of poles define two Bezier curves which delimit the surface in the v parametric direction. These are the v isoparametric curves corresponding to values 0 and 1 of the v parameter. - The first row of poles and the last row of poles define two Bezier curves which delimit the surface in the u parametric direction. These are the u isoparametric curves corresponding to values 0 and 1 of the u parameter. It is more difficult to define a geometrical significance for the weights. However they are useful for representing a quadric surface precisely. Moreover, if the weights of all the poles are equal, the surface has a polynomial equation, and hence is a 'non-rational surface'. The non-rational surface is a special, but frequently used, case, where all poles have identical weights. The weights are defined and used only in the case of a rational surface. This rational characteristic is defined in each parametric direction. Hence, a surface can be rational in the u parametric direction, and non-rational in the v parametric direction. Likewise, the degree of a surface is defined in each parametric direction. The degree of a Bezier surface in a given parametric direction is equal to the number of poles of the surface in that parametric direction, minus 1. This must be greater than or equal to 1. However, the degree for a Geom_BezierSurface is limited to a value of (25) which is defined and controlled by the system. This value is returned by the function MaxDegree. The parameter range for a Bezier surface is [ 0, 1 ] in the two parametric directions. A Bezier surface can also be closed, or open, in each parametric direction. If the first row of poles is identical to the last row of poles, the surface is closed in the u parametric direction. If the first column of poles is identical to the last column of poles, the surface is closed in the v parametric direction. The continuity of a Bezier surface is infinite in the u parametric direction and the in v parametric direction. Note: It is not possible to build a Bezier surface with negative weights. Any weight value that is less than, or equal to, gp::Resolution() is considered to be zero. Two weight values, W1 and W2, are considered equal if: |W2-W1| <= gp::Resolution()");

// Constructors
cls_Geom_BezierSurface.def(py::init<const TColgp_Array2OfPnt &>(), py::arg("SurfacePoles"));
cls_Geom_BezierSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &>(), py::arg("SurfacePoles"), py::arg("PoleWeights"));

// Fields

// Methods
cls_Geom_BezierSurface.def("ExchangeUV", (void (Geom_BezierSurface::*)()) &Geom_BezierSurface::ExchangeUV, "Exchanges the direction U and V on a Bezier surface As a consequence: - the poles and weights tables are transposed, - degrees, rational characteristics and so on are exchanged between the two parametric directions, and - the orientation of the surface is reversed.");
cls_Geom_BezierSurface.def("Increase", (void (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer)) &Geom_BezierSurface::Increase, "Increases the degree of this Bezier surface in the two parametric directions.", py::arg("UDeg"), py::arg("VDeg"));
cls_Geom_BezierSurface.def("InsertPoleColAfter", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::InsertPoleColAfter, "Inserts a column of poles. If the surface is rational the weights values associated with CPoles are equal defaulted to 1.", py::arg("VIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("InsertPoleColAfter", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::InsertPoleColAfter, "Inserts a column of poles and weights. If the surface was non-rational it can become rational.", py::arg("VIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("InsertPoleColBefore", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::InsertPoleColBefore, "Inserts a column of poles. If the surface is rational the weights values associated with CPoles are equal defaulted to 1.", py::arg("VIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("InsertPoleColBefore", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::InsertPoleColBefore, "Inserts a column of poles and weights. If the surface was non-rational it can become rational.", py::arg("VIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("InsertPoleRowAfter", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::InsertPoleRowAfter, "Inserts a row of poles. If the surface is rational the weights values associated with CPoles are equal defaulted to 1.", py::arg("UIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("InsertPoleRowAfter", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::InsertPoleRowAfter, "Inserts a row of poles and weights. If the surface was non-rational it can become rational.", py::arg("UIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("InsertPoleRowBefore", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::InsertPoleRowBefore, "Inserts a row of poles. If the surface is rational the weights values associated with CPoles are equal defaulted to 1.", py::arg("UIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("InsertPoleRowBefore", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::InsertPoleRowBefore, "Inserts a row of poles and weights. If the surface was non-rational it can become rational.", py::arg("UIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("RemovePoleCol", (void (Geom_BezierSurface::*)(const Standard_Integer)) &Geom_BezierSurface::RemovePoleCol, "Removes a column of poles. If the surface was rational it can become non-rational.", py::arg("VIndex"));
cls_Geom_BezierSurface.def("RemovePoleRow", (void (Geom_BezierSurface::*)(const Standard_Integer)) &Geom_BezierSurface::RemovePoleRow, "Removes a row of poles. If the surface was rational it can become non-rational.", py::arg("UIndex"));
cls_Geom_BezierSurface.def("Segment", (void (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real)) &Geom_BezierSurface::Segment, "Modifies this Bezier surface by segmenting it between U1 and U2 in the u parametric direction, and between V1 and V2 in the v parametric direction. U1, U2, V1, and V2 can be outside the bounds of this surface. - U1 and U2 isoparametric Bezier curves, segmented between V1 and V2, become the two bounds of the surface in the v parametric direction (0. and 1. u isoparametric curves). - V1 and V2 isoparametric Bezier curves, segmented between U1 and U2, become the two bounds of the surface in the u parametric direction (0. and 1. v isoparametric curves). The poles and weights tables are modified, but the degree of this surface in the u and v parametric directions does not change. U1 can be greater than U2, and V1 can be greater than V2. In these cases, the corresponding parametric direction is inverted. The orientation of the surface is inverted if one (and only one) parametric direction is inverted.", py::arg("U1"), py::arg("U2"), py::arg("V1"), py::arg("V2"));
cls_Geom_BezierSurface.def("SetPole", (void (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer, const gp_Pnt &)) &Geom_BezierSurface::SetPole, "Modifies a pole value. If the surface is rational the weight of range (UIndex, VIndex) is not modified.", py::arg("UIndex"), py::arg("VIndex"), py::arg("P"));
cls_Geom_BezierSurface.def("SetPole", (void (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer, const gp_Pnt &, const Standard_Real)) &Geom_BezierSurface::SetPole, "Substitutes the pole and the weight of range UIndex, VIndex. If the surface <me> is not rational it can become rational. if the surface was rational it can become non-rational.", py::arg("UIndex"), py::arg("VIndex"), py::arg("P"), py::arg("Weight"));
cls_Geom_BezierSurface.def("SetPoleCol", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::SetPoleCol, "Modifies a column of poles. The length of CPoles can be lower but not greater than NbUPoles so you can modify just a part of the column. Raised if VIndex < 1 or VIndex > NbVPoles", py::arg("VIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("SetPoleCol", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::SetPoleCol, "Modifies a column of poles. If the surface was rational it can become non-rational If the surface was non-rational it can become rational. The length of CPoles can be lower but not greater than NbUPoles so you can modify just a part of the column. Raised if VIndex < 1 or VIndex > NbVPoles", py::arg("VIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("SetPoleRow", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BezierSurface::SetPoleRow, "Modifies a row of poles. The length of CPoles can be lower but not greater than NbVPoles so you can modify just a part of the row. Raised if UIndex < 1 or UIndex > NbUPoles", py::arg("UIndex"), py::arg("CPoles"));
cls_Geom_BezierSurface.def("SetPoleRow", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BezierSurface::SetPoleRow, "Modifies a row of poles and weights. If the surface was rational it can become non-rational. If the surface was non-rational it can become rational. The length of CPoles can be lower but not greater than NbVPoles so you can modify just a part of the row. Raised if UIndex < 1 or UIndex > NbUPoles", py::arg("UIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("SetWeight", (void (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom_BezierSurface::SetWeight, "Modifies the weight of the pole of range UIndex, VIndex. If the surface was non-rational it can become rational. If the surface was rational it can become non-rational.", py::arg("UIndex"), py::arg("VIndex"), py::arg("Weight"));
cls_Geom_BezierSurface.def("SetWeightCol", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColStd_Array1OfReal &)) &Geom_BezierSurface::SetWeightCol, "Modifies a column of weights. If the surface was rational it can become non-rational. If the surface was non-rational it can become rational. The length of CPoleWeights can be lower but not greater than NbUPoles. Raised if VIndex < 1 or VIndex > NbVPoles", py::arg("VIndex"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("SetWeightRow", (void (Geom_BezierSurface::*)(const Standard_Integer, const TColStd_Array1OfReal &)) &Geom_BezierSurface::SetWeightRow, "Modifies a row of weights. If the surface was rational it can become non-rational. If the surface was non-rational it can become rational. The length of CPoleWeights can be lower but not greater than NbVPoles. Raised if UIndex < 1 or UIndex > NbUPoles", py::arg("UIndex"), py::arg("CPoleWeights"));
cls_Geom_BezierSurface.def("UReverse", (void (Geom_BezierSurface::*)()) &Geom_BezierSurface::UReverse, "Changes the orientation of this Bezier surface in the u parametric direction. The bounds of the surface are not changed, but the given parametric direction is reversed. Hence, the orientation of the surface is reversed.");
cls_Geom_BezierSurface.def("UReversedParameter", (Standard_Real (Geom_BezierSurface::*)(const Standard_Real) const) &Geom_BezierSurface::UReversedParameter, "Computes the u (or v) parameter on the modified surface, produced by reversing its u (or v) parametric direction, for any point of u parameter U (or of v parameter V) on this Bezier surface. In the case of a Bezier surface, these functions return respectively: - 1.-U, or 1.-V.", py::arg("U"));
cls_Geom_BezierSurface.def("VReverse", (void (Geom_BezierSurface::*)()) &Geom_BezierSurface::VReverse, "Changes the orientation of this Bezier surface in the v parametric direction. The bounds of the surface are not changed, but the given parametric direction is reversed. Hence, the orientation of the surface is reversed.");
cls_Geom_BezierSurface.def("VReversedParameter", (Standard_Real (Geom_BezierSurface::*)(const Standard_Real) const) &Geom_BezierSurface::VReversedParameter, "Computes the u (or v) parameter on the modified surface, produced by reversing its u (or v) parametric direction, for any point of u parameter U (or of v parameter V) on this Bezier surface. In the case of a Bezier surface, these functions return respectively: - 1.-U, or 1.-V.", py::arg("V"));
cls_Geom_BezierSurface.def("Bounds", [](Geom_BezierSurface &self, Standard_Real & U1, Standard_Real & U2, Standard_Real & V1, Standard_Real & V2){ self.Bounds(U1, U2, V1, V2); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(U1, U2, V1, V2); }, "Returns the parametric bounds U1, U2, V1 and V2 of this Bezier surface. In the case of a Bezier surface, this function returns U1 = 0, V1 = 0, U2 = 1, V2 = 1.", py::arg("U1"), py::arg("U2"), py::arg("V1"), py::arg("V2"));
cls_Geom_BezierSurface.def("Continuity", (GeomAbs_Shape (Geom_BezierSurface::*)() const) &Geom_BezierSurface::Continuity, "Returns the continuity of the surface CN : the order of continuity is infinite.");
cls_Geom_BezierSurface.def("D0", (void (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &) const) &Geom_BezierSurface::D0, "None", py::arg("U"), py::arg("V"), py::arg("P"));
cls_Geom_BezierSurface.def("D1", (void (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &) const) &Geom_BezierSurface::D1, "None", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"));
cls_Geom_BezierSurface.def("D2", (void (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BezierSurface::D2, "None", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"));
cls_Geom_BezierSurface.def("D3", (void (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BezierSurface::D3, "Computes P, the point of parameters (U, V) of this Bezier surface, and - one or more of the following sets of vectors: - D1U and D1V, the first derivative vectors at this point, - D2U, D2V and D2UV, the second derivative vectors at this point, - D3U, D3V, D3UUV and D3UVV, the third derivative vectors at this point. Note: The parameters U and V can be outside the bounds of the surface.", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"), py::arg("D3U"), py::arg("D3V"), py::arg("D3UUV"), py::arg("D3UVV"));
cls_Geom_BezierSurface.def("DN", (gp_Vec (Geom_BezierSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer) const) &Geom_BezierSurface::DN, "Computes the derivative of order Nu in the u parametric direction, and Nv in the v parametric direction, at the point of parameters (U, V) of this Bezier surface. Note: The parameters U and V can be outside the bounds of the surface. Exceptions Standard_RangeError if: - Nu + Nv is less than 1, or Nu or Nv is negative.", py::arg("U"), py::arg("V"), py::arg("Nu"), py::arg("Nv"));
cls_Geom_BezierSurface.def("NbUPoles", (Standard_Integer (Geom_BezierSurface::*)() const) &Geom_BezierSurface::NbUPoles, "Returns the number of poles in the U direction.");
cls_Geom_BezierSurface.def("NbVPoles", (Standard_Integer (Geom_BezierSurface::*)() const) &Geom_BezierSurface::NbVPoles, "Returns the number of poles in the V direction.");
cls_Geom_BezierSurface.def("Pole", (const gp_Pnt & (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer) const) &Geom_BezierSurface::Pole, "Returns the pole of range UIndex, VIndex Raised if UIndex < 1 or UIndex > NbUPoles, or VIndex < 1 or VIndex > NbVPoles.", py::arg("UIndex"), py::arg("VIndex"));
cls_Geom_BezierSurface.def("Poles", (void (Geom_BezierSurface::*)(TColgp_Array2OfPnt &) const) &Geom_BezierSurface::Poles, "Returns the poles of the Bezier surface.", py::arg("P"));
cls_Geom_BezierSurface.def("Poles", (const TColgp_Array2OfPnt & (Geom_BezierSurface::*)() const) &Geom_BezierSurface::Poles, "Returns the poles of the Bezier surface.");
cls_Geom_BezierSurface.def("UDegree", (Standard_Integer (Geom_BezierSurface::*)() const) &Geom_BezierSurface::UDegree, "Returns the degree of the surface in the U direction it is NbUPoles - 1");
cls_Geom_BezierSurface.def("UIso", (opencascade::handle<Geom_Curve> (Geom_BezierSurface::*)(const Standard_Real) const) &Geom_BezierSurface::UIso, "Computes the U isoparametric curve. For a Bezier surface the UIso curve is a Bezier curve.", py::arg("U"));
cls_Geom_BezierSurface.def("VDegree", (Standard_Integer (Geom_BezierSurface::*)() const) &Geom_BezierSurface::VDegree, "Returns the degree of the surface in the V direction it is NbVPoles - 1");
cls_Geom_BezierSurface.def("VIso", (opencascade::handle<Geom_Curve> (Geom_BezierSurface::*)(const Standard_Real) const) &Geom_BezierSurface::VIso, "Computes the V isoparametric curve. For a Bezier surface the VIso curve is a Bezier curve.", py::arg("V"));
cls_Geom_BezierSurface.def("Weight", (Standard_Real (Geom_BezierSurface::*)(const Standard_Integer, const Standard_Integer) const) &Geom_BezierSurface::Weight, "Returns the weight of range UIndex, VIndex", py::arg("UIndex"), py::arg("VIndex"));
cls_Geom_BezierSurface.def("Weights", (void (Geom_BezierSurface::*)(TColStd_Array2OfReal &) const) &Geom_BezierSurface::Weights, "Returns the weights of the Bezier surface.", py::arg("W"));
cls_Geom_BezierSurface.def("Weights", (const TColStd_Array2OfReal * (Geom_BezierSurface::*)() const) &Geom_BezierSurface::Weights, "Returns the weights of the Bezier surface.");
cls_Geom_BezierSurface.def("IsUClosed", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsUClosed, "Returns True if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp.");
cls_Geom_BezierSurface.def("IsVClosed", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsVClosed, "Returns True if the first control points column and the last control points column are identical. The tolerance criterion is Resolution from package gp.");
cls_Geom_BezierSurface.def("IsCNu", (Standard_Boolean (Geom_BezierSurface::*)(const Standard_Integer) const) &Geom_BezierSurface::IsCNu, "Returns True, a Bezier surface is always CN", py::arg("N"));
cls_Geom_BezierSurface.def("IsCNv", (Standard_Boolean (Geom_BezierSurface::*)(const Standard_Integer) const) &Geom_BezierSurface::IsCNv, "Returns True, a BezierSurface is always CN", py::arg("N"));
cls_Geom_BezierSurface.def("IsUPeriodic", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsUPeriodic, "Returns False.");
cls_Geom_BezierSurface.def("IsVPeriodic", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsVPeriodic, "Returns False.");
cls_Geom_BezierSurface.def("IsURational", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsURational, "Returns False if the weights are identical in the U direction, The tolerance criterion is Resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|");
cls_Geom_BezierSurface.def("IsVRational", (Standard_Boolean (Geom_BezierSurface::*)() const) &Geom_BezierSurface::IsVRational, "Returns False if the weights are identical in the V direction, The tolerance criterion is Resolution from package gp. Example : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|");
cls_Geom_BezierSurface.def("Transform", (void (Geom_BezierSurface::*)(const gp_Trsf &)) &Geom_BezierSurface::Transform, "Applies the transformation T to this Bezier surface.", py::arg("T"));
cls_Geom_BezierSurface.def_static("MaxDegree_", (Standard_Integer (*)()) &Geom_BezierSurface::MaxDegree, "Returns the value of the maximum polynomial degree of a Bezier surface. This value is 25.");
cls_Geom_BezierSurface.def("Resolution", [](Geom_BezierSurface &self, const Standard_Real Tolerance3D, Standard_Real & UTolerance, Standard_Real & VTolerance){ self.Resolution(Tolerance3D, UTolerance, VTolerance); return std::tuple<Standard_Real &, Standard_Real &>(UTolerance, VTolerance); }, "Computes two tolerance values for this Bezier surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are: - UTolerance in the u parametric direction, and - VTolerance in the v parametric direction. If f(u,v) is the equation of this Bezier surface, UTolerance and VTolerance guarantee that: | u1 - u0 | < UTolerance and | v1 - v0 | < VTolerance ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D", py::arg("Tolerance3D"), py::arg("UTolerance"), py::arg("VTolerance"));
cls_Geom_BezierSurface.def("Copy", (opencascade::handle<Geom_Geometry> (Geom_BezierSurface::*)() const) &Geom_BezierSurface::Copy, "Creates a new object which is a copy of this Bezier surface.");
cls_Geom_BezierSurface.def_static("get_type_name_", (const char * (*)()) &Geom_BezierSurface::get_type_name, "None");
cls_Geom_BezierSurface.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Geom_BezierSurface::get_type_descriptor, "None");
cls_Geom_BezierSurface.def("DynamicType", (const opencascade::handle<Standard_Type> & (Geom_BezierSurface::*)() const) &Geom_BezierSurface::DynamicType, "None");

// Enums

}