/*
This file is part of pyOCCT which provides Python bindings to the OpenCASCADE
geometry kernel.

Copyright (C) 2016-2018  Laughlin Research, LLC
Copyright (C) 2019 Trevor Laughlin and the pyOCCT contributors

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <pyOCCT_Common.hxx>
#include <Geom_BoundedSurface.hxx>
#include <TColgp_Array2OfPnt.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_Array1OfInteger.hxx>
#include <Standard_TypeDef.hxx>
#include <TColStd_Array2OfReal.hxx>
#include <gp_Pnt.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <GeomAbs_Shape.hxx>
#include <GeomAbs_BSplKnotDistribution.hxx>
#include <gp_Vec.hxx>
#include <Standard_Handle.hxx>
#include <Geom_Curve.hxx>
#include <gp_Trsf.hxx>
#include <Geom_Geometry.hxx>
#include <Geom_BSplineSurface.hxx>
#include <Standard_Type.hxx>
#include <TColgp_HArray2OfPnt.hxx>
#include <TColStd_HArray2OfReal.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <TColStd_HArray1OfInteger.hxx>

void bind_Geom_BSplineSurface(py::module &mod){

py::class_<Geom_BSplineSurface, opencascade::handle<Geom_BSplineSurface>, Geom_BoundedSurface> cls_Geom_BSplineSurface(mod, "Geom_BSplineSurface", "Describes a BSpline surface. In each parametric direction, a BSpline surface can be: - uniform or non-uniform, - rational or non-rational, - periodic or non-periodic. A BSpline surface is defined by: - its degrees, in the u and v parametric directions, - its periodic characteristic, in the u and v parametric directions, - a table of poles, also called control points (together with the associated weights if the surface is rational), and - a table of knots, together with the associated multiplicities. The degree of a Geom_BSplineSurface is limited to a value (25) which is defined and controlled by the system. This value is returned by the function MaxDegree. Poles and Weights Poles and Weights are manipulated using two associative double arrays: - the poles table, which is a double array of gp_Pnt points, and - the weights table, which is a double array of reals. The bounds of the poles and weights arrays are: - 1 and NbUPoles for the row bounds (provided that the BSpline surface is not periodic in the u parametric direction), where NbUPoles is the number of poles of the surface in the u parametric direction, and - 1 and NbVPoles for the column bounds (provided that the BSpline surface is not periodic in the v parametric direction), where NbVPoles is the number of poles of the surface in the v parametric direction. The poles of the surface are the points used to shape and reshape the surface. They comprise a rectangular network. If the surface is not periodic: - The points (1, 1), (NbUPoles, 1), (1, NbVPoles), and (NbUPoles, NbVPoles) are the four parametric 'corners' of the surface. - The first column of poles and the last column of poles define two BSpline curves which delimit the surface in the v parametric direction. These are the v isoparametric curves corresponding to the two bounds of the v parameter. - The first row of poles and the last row of poles define two BSpline curves which delimit the surface in the u parametric direction. These are the u isoparametric curves corresponding to the two bounds of the u parameter. If the surface is periodic, these geometric properties are not verified. It is more difficult to define a geometrical significance for the weights. However they are useful for representing a quadric surface precisely. Moreover, if the weights of all the poles are equal, the surface has a polynomial equation, and hence is a 'non-rational surface'. The non-rational surface is a special, but frequently used, case, where all poles have identical weights. The weights are defined and used only in the case of a rational surface. The rational characteristic is defined in each parametric direction. A surface can be rational in the u parametric direction, and non-rational in the v parametric direction. Knots and Multiplicities For a Geom_BSplineSurface the table of knots is made up of two increasing sequences of reals, without repetition, one for each parametric direction. The multiplicities define the repetition of the knots. A BSpline surface comprises multiple contiguous patches, which are themselves polynomial or rational surfaces. The knots are the parameters of the isoparametric curves which limit these contiguous patches. The multiplicity of a knot on a BSpline surface (in a given parametric direction) is related to the degree of continuity of the surface at that knot in that parametric direction: Degree of continuity at knot(i) = Degree - Multi(i) where: - Degree is the degree of the BSpline surface in the given parametric direction, and - Multi(i) is the multiplicity of knot number i in the given parametric direction. There are some special cases, where the knots are regularly spaced in one parametric direction (i.e. the difference between two consecutive knots is a constant). - 'Uniform': all the multiplicities are equal to 1. - 'Quasi-uniform': all the multiplicities are equal to 1, except for the first and last knots in this parametric direction, and these are equal to Degree + 1. - 'Piecewise Bezier': all the multiplicities are equal to Degree except for the first and last knots, which are equal to Degree + 1. This surface is a concatenation of Bezier patches in the given parametric direction. If the BSpline surface is not periodic in a given parametric direction, the bounds of the knots and multiplicities tables are 1 and NbKnots, where NbKnots is the number of knots of the BSpline surface in that parametric direction. If the BSpline surface is periodic in a given parametric direction, and there are k periodic knots and p periodic poles in that parametric direction: - the period is such that: period = Knot(k+1) - Knot(1), and - the poles and knots tables in that parametric direction can be considered as infinite tables, such that: Knot(i+k) = Knot(i) + period, and Pole(i+p) = Pole(i) Note: The data structure tables for a periodic BSpline surface are more complex than those of a non-periodic one. References : . A survey of curve and surface methods in CADG Wolfgang BOHM CAGD 1 (1984) . On de Boor-like algorithms and blossoming Wolfgang BOEHM cagd 5 (1988) . Blossoming and knot insertion algorithms for B-spline curves Ronald N. GOLDMAN . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA . Curves and Surfaces for Computer Aided Geometric Design, a practical guide Gerald Farin");

// Constructors
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer>(), py::arg("Poles"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"));
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UPeriodic"));
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Poles"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UPeriodic"), py::arg("VPeriodic"));
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer>(), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"));
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const Standard_Boolean>(), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UPeriodic"));
cls_Geom_BSplineSurface.def(py::init<const TColgp_Array2OfPnt &, const TColStd_Array2OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const TColStd_Array1OfInteger &, const Standard_Integer, const Standard_Integer, const Standard_Boolean, const Standard_Boolean>(), py::arg("Poles"), py::arg("Weights"), py::arg("UKnots"), py::arg("VKnots"), py::arg("UMults"), py::arg("VMults"), py::arg("UDegree"), py::arg("VDegree"), py::arg("UPeriodic"), py::arg("VPeriodic"));

// Fields

// Methods
cls_Geom_BSplineSurface.def("ExchangeUV", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::ExchangeUV, "Exchanges the u and v parametric directions on this BSpline surface. As a consequence: - the poles and weights tables are transposed, - the knots and multiplicities tables are exchanged, - degrees of continuity, and rational, periodic and uniform characteristics are exchanged, and - the orientation of the surface is inverted.");
cls_Geom_BSplineSurface.def("SetUPeriodic", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::SetUPeriodic, "Sets the surface U periodic. Modifies this surface to be periodic in the U parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.");
cls_Geom_BSplineSurface.def("SetVPeriodic", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::SetVPeriodic, "Sets the surface V periodic. Modifies this surface to be periodic in the V parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstVKnotIndex and LastVKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.");
cls_Geom_BSplineSurface.def("PeriodicNormalization", [](Geom_BSplineSurface &self, Standard_Real & U, Standard_Real & V){ self.PeriodicNormalization(U, V); return std::tuple<Standard_Real &, Standard_Real &>(U, V); }, "returns the parameter normalized within the period if the surface is periodic : otherwise does not do anything", py::arg("U"), py::arg("V"));
cls_Geom_BSplineSurface.def("SetUOrigin", (void (Geom_BSplineSurface::*)(const Standard_Integer)) &Geom_BSplineSurface::SetUOrigin, "Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.", py::arg("Index"));
cls_Geom_BSplineSurface.def("SetVOrigin", (void (Geom_BSplineSurface::*)(const Standard_Integer)) &Geom_BSplineSurface::SetVOrigin, "Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.", py::arg("Index"));
cls_Geom_BSplineSurface.def("SetUNotPeriodic", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::SetUNotPeriodic, "Sets the surface U not periodic. Changes this BSpline surface into a non-periodic surface along U direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.");
cls_Geom_BSplineSurface.def("SetVNotPeriodic", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::SetVNotPeriodic, "Sets the surface V not periodic. Changes this BSpline surface into a non-periodic surface along V direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.");
cls_Geom_BSplineSurface.def("UReverse", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::UReverse, "Changes the orientation of this BSpline surface in the U parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.");
cls_Geom_BSplineSurface.def("VReverse", (void (Geom_BSplineSurface::*)()) &Geom_BSplineSurface::VReverse, "Changes the orientation of this BSpline surface in the V parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.");
cls_Geom_BSplineSurface.def("UReversedParameter", (Standard_Real (Geom_BSplineSurface::*)(const Standard_Real) const) &Geom_BSplineSurface::UReversedParameter, "Computes the u parameter on the modified surface, produced by reversing its U parametric direction, for the point of u parameter U, on this BSpline surface. For a BSpline surface, these functions return respectively: - UFirst + ULast - U, where UFirst, ULast are the values of the first and last parameters of this BSpline surface, in the u parametric directions.", py::arg("U"));
cls_Geom_BSplineSurface.def("VReversedParameter", (Standard_Real (Geom_BSplineSurface::*)(const Standard_Real) const) &Geom_BSplineSurface::VReversedParameter, "Computes the v parameter on the modified surface, produced by reversing its V parametric direction, for the point of v parameter V on this BSpline surface. For a BSpline surface, these functions return respectively: - VFirst + VLast - V, VFirst and VLast are the values of the first and last parameters of this BSpline surface, in the v pametric directions.", py::arg("V"));
cls_Geom_BSplineSurface.def("IncreaseDegree", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncreaseDegree, "Increases the degrees of this BSpline surface to UDegree and VDegree in the u and v parametric directions respectively. As a result, the tables of poles, weights and multiplicities are modified. The tables of knots is not changed. Note: Nothing is done if the given degree is less than or equal to the current degree in the corresponding parametric direction. Exceptions Standard_ConstructionError if UDegree or VDegree is greater than Geom_BSplineSurface::MaxDegree().", py::arg("UDegree"), py::arg("VDegree"));
cls_Geom_BSplineSurface.def("InsertUKnots", [](Geom_BSplineSurface &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1) -> void { return self.InsertUKnots(a0, a1); });
cls_Geom_BSplineSurface.def("InsertUKnots", [](Geom_BSplineSurface &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1, const Standard_Real a2) -> void { return self.InsertUKnots(a0, a1, a2); });
cls_Geom_BSplineSurface.def("InsertUKnots", (void (Geom_BSplineSurface::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &Geom_BSplineSurface::InsertUKnots, "Inserts into the knots table for the U parametric direction of this BSpline surface: - the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is: - increased by M, if Add is true (the default), or - increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning - If a given multiplicity coefficient is null, or negative, nothing is done. - The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance.", py::arg("Knots"), py::arg("Mults"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineSurface.def("InsertVKnots", [](Geom_BSplineSurface &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1) -> void { return self.InsertVKnots(a0, a1); });
cls_Geom_BSplineSurface.def("InsertVKnots", [](Geom_BSplineSurface &self, const TColStd_Array1OfReal & a0, const TColStd_Array1OfInteger & a1, const Standard_Real a2) -> void { return self.InsertVKnots(a0, a1, a2); });
cls_Geom_BSplineSurface.def("InsertVKnots", (void (Geom_BSplineSurface::*)(const TColStd_Array1OfReal &, const TColStd_Array1OfInteger &, const Standard_Real, const Standard_Boolean)) &Geom_BSplineSurface::InsertVKnots, "Inserts into the knots table for the V parametric direction of this BSpline surface: - the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is: - increased by M, if Add is true (the default), or - increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning - If a given multiplicity coefficient is null, or negative, nothing is done. - The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance.", py::arg("Knots"), py::arg("Mults"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineSurface.def("RemoveUKnot", (Standard_Boolean (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom_BSplineSurface::RemoveUKnot, "Reduces to M the multiplicity of the knot of index Index in the U parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance 'smoothes' the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.", py::arg("Index"), py::arg("M"), py::arg("Tolerance"));
cls_Geom_BSplineSurface.def("RemoveVKnot", (Standard_Boolean (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom_BSplineSurface::RemoveVKnot, "Reduces to M the multiplicity of the knot of index Index in the V parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance 'smoothes' the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.", py::arg("Index"), py::arg("M"), py::arg("Tolerance"));
cls_Geom_BSplineSurface.def("IncreaseUMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncreaseUMultiplicity, "Increases the multiplicity of the knot of range UIndex in the UKnots sequence. M is the new multiplicity. M must be greater than the previous multiplicity and lower or equal to the degree of the surface in the U parametric direction. Raised if M is not in the range [1, UDegree]", py::arg("UIndex"), py::arg("M"));
cls_Geom_BSplineSurface.def("IncreaseUMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncreaseUMultiplicity, "Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the U direction. This method can be used to make a B_spline surface into a PiecewiseBezier B_spline surface. If <me> was uniform, it can become non uniform.", py::arg("FromI1"), py::arg("ToI2"), py::arg("M"));
cls_Geom_BSplineSurface.def("IncrementUMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncrementUMultiplicity, "Increments the multiplicity of the consecutives uknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the UDegree of the B_spline.", py::arg("FromI1"), py::arg("ToI2"), py::arg("Step"));
cls_Geom_BSplineSurface.def("IncreaseVMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncreaseVMultiplicity, "Increases the multiplicity of a knot in the V direction. M is the new multiplicity.", py::arg("VIndex"), py::arg("M"));
cls_Geom_BSplineSurface.def("IncreaseVMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncreaseVMultiplicity, "Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the V direction. This method can be used to make a BSplineSurface into a PiecewiseBezier B_spline surface. If <me> was uniform, it can become non-uniform.", py::arg("FromI1"), py::arg("ToI2"), py::arg("M"));
cls_Geom_BSplineSurface.def("IncrementVMultiplicity", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Integer)) &Geom_BSplineSurface::IncrementVMultiplicity, "Increments the multiplicity of the consecutives vknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the VDegree of the B_spline.", py::arg("FromI1"), py::arg("ToI2"), py::arg("Step"));
cls_Geom_BSplineSurface.def("InsertUKnot", [](Geom_BSplineSurface &self, const Standard_Real a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.InsertUKnot(a0, a1, a2); });
cls_Geom_BSplineSurface.def("InsertUKnot", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Boolean)) &Geom_BSplineSurface::InsertUKnot, "Inserts a knot value in the sequence of UKnots. If U is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M else it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.", py::arg("U"), py::arg("M"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineSurface.def("InsertVKnot", [](Geom_BSplineSurface &self, const Standard_Real a0, const Standard_Integer a1, const Standard_Real a2) -> void { return self.InsertVKnot(a0, a1, a2); });
cls_Geom_BSplineSurface.def("InsertVKnot", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Integer, const Standard_Real, const Standard_Boolean)) &Geom_BSplineSurface::InsertVKnot, "Inserts a knot value in the sequence of VKnots. If V is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M otherwise it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.", py::arg("V"), py::arg("M"), py::arg("ParametricTolerance"), py::arg("Add"));
cls_Geom_BSplineSurface.def("Segment", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real)) &Geom_BSplineSurface::Segment, "Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same. Warnings : Even if <me> is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface <me> or if the surface makes loop. raises if U2 < U1 or V2 < V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) > Precision::PConfusion(). Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) > Precision::PConfusion()).", py::arg("U1"), py::arg("U2"), py::arg("V1"), py::arg("V2"));
cls_Geom_BSplineSurface.def("CheckAndSegment", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Real, const Standard_Real)) &Geom_BSplineSurface::CheckAndSegment, "Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction.", py::arg("U1"), py::arg("U2"), py::arg("V1"), py::arg("V2"));
cls_Geom_BSplineSurface.def("SetUKnot", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Real)) &Geom_BSplineSurface::SetUKnot, "Substitutes the UKnots of range UIndex with K.", py::arg("UIndex"), py::arg("K"));
cls_Geom_BSplineSurface.def("SetUKnots", (void (Geom_BSplineSurface::*)(const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetUKnots, "Changes all the U-knots of the surface. The multiplicity of the knots are not modified.", py::arg("UK"));
cls_Geom_BSplineSurface.def("SetUKnot", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Real, const Standard_Integer)) &Geom_BSplineSurface::SetUKnot, "Changes the value of the UKnots of range UIndex and increases its multiplicity.", py::arg("UIndex"), py::arg("K"), py::arg("M"));
cls_Geom_BSplineSurface.def("SetVKnot", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Real)) &Geom_BSplineSurface::SetVKnot, "Substitutes the VKnots of range VIndex with K.", py::arg("VIndex"), py::arg("K"));
cls_Geom_BSplineSurface.def("SetVKnots", (void (Geom_BSplineSurface::*)(const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetVKnots, "Changes all the V-knots of the surface. The multiplicity of the knots are not modified.", py::arg("VK"));
cls_Geom_BSplineSurface.def("SetVKnot", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Real, const Standard_Integer)) &Geom_BSplineSurface::SetVKnot, "Changes the value of the VKnots of range VIndex and increases its multiplicity.", py::arg("VIndex"), py::arg("K"), py::arg("M"));
cls_Geom_BSplineSurface.def("LocateU", [](Geom_BSplineSurface &self, const Standard_Real U, const Standard_Real ParametricTolerance, Standard_Integer & I1, Standard_Integer & I2, const Standard_Boolean WithKnotRepetition){ self.LocateU(U, ParametricTolerance, I1, I2, WithKnotRepetition); return std::tuple<Standard_Integer &, Standard_Integer &>(I1, I2); }, "Locates the parametric value U in the sequence of UKnots. If 'WithKnotRepetition' is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. UKnots (I1) <= U <= UKnots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 < 1 => U < UKnots(1) - Abs(ParametricTolerance) . if I2 > NbUKnots => U > UKnots(NbUKnots)+Abs(ParametricTolerance)", py::arg("U"), py::arg("ParametricTolerance"), py::arg("I1"), py::arg("I2"), py::arg("WithKnotRepetition"));
cls_Geom_BSplineSurface.def("LocateV", [](Geom_BSplineSurface &self, const Standard_Real V, const Standard_Real ParametricTolerance, Standard_Integer & I1, Standard_Integer & I2, const Standard_Boolean WithKnotRepetition){ self.LocateV(V, ParametricTolerance, I1, I2, WithKnotRepetition); return std::tuple<Standard_Integer &, Standard_Integer &>(I1, I2); }, "Locates the parametric value V in the sequence of knots. If 'WithKnotRepetition' is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. VKnots (I1) <= V <= VKnots (I2) . if I1 = I2 V is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 < 1 => V < VKnots(1) - Abs(ParametricTolerance) . if I2 > NbVKnots => V > VKnots(NbVKnots)+Abs(ParametricTolerance) poles insertion and removing The following methods are available only if the surface is Uniform or QuasiUniform in the considered direction The knot repartition is modified.", py::arg("V"), py::arg("ParametricTolerance"), py::arg("I1"), py::arg("I2"), py::arg("WithKnotRepetition"));
cls_Geom_BSplineSurface.def("SetPole", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const gp_Pnt &)) &Geom_BSplineSurface::SetPole, "Substitutes the pole of range (UIndex, VIndex) with P. If the surface is rational the weight of range (UIndex, VIndex) is not modified.", py::arg("UIndex"), py::arg("VIndex"), py::arg("P"));
cls_Geom_BSplineSurface.def("SetPole", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const gp_Pnt &, const Standard_Real)) &Geom_BSplineSurface::SetPole, "Substitutes the pole and the weight of range (UIndex, VIndex) with P and W.", py::arg("UIndex"), py::arg("VIndex"), py::arg("P"), py::arg("Weight"));
cls_Geom_BSplineSurface.def("SetPoleCol", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BSplineSurface::SetPoleCol, "Changes a column of poles or a part of this column. Raised if Vindex < 1 or VIndex > NbVPoles.", py::arg("VIndex"), py::arg("CPoles"));
cls_Geom_BSplineSurface.def("SetPoleCol", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetPoleCol, "Changes a column of poles or a part of this column with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Vindex < 1 or VIndex > NbVPoles.", py::arg("VIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BSplineSurface.def("SetPoleRow", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &, const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetPoleRow, "Changes a row of poles or a part of this row with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Uindex < 1 or UIndex > NbUPoles.", py::arg("UIndex"), py::arg("CPoles"), py::arg("CPoleWeights"));
cls_Geom_BSplineSurface.def("SetPoleRow", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColgp_Array1OfPnt &)) &Geom_BSplineSurface::SetPoleRow, "Changes a row of poles or a part of this row. Raised if Uindex < 1 or UIndex > NbUPoles.", py::arg("UIndex"), py::arg("CPoles"));
cls_Geom_BSplineSurface.def("SetWeight", (void (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer, const Standard_Real)) &Geom_BSplineSurface::SetWeight, "Changes the weight of the pole of range UIndex, VIndex. If the surface was non rational it can become rational. If the surface was rational it can become non rational.", py::arg("UIndex"), py::arg("VIndex"), py::arg("Weight"));
cls_Geom_BSplineSurface.def("SetWeightCol", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetWeightCol, "Changes a column of weights of a part of this column.", py::arg("VIndex"), py::arg("CPoleWeights"));
cls_Geom_BSplineSurface.def("SetWeightRow", (void (Geom_BSplineSurface::*)(const Standard_Integer, const TColStd_Array1OfReal &)) &Geom_BSplineSurface::SetWeightRow, "Changes a row of weights or a part of this row.", py::arg("UIndex"), py::arg("CPoleWeights"));
cls_Geom_BSplineSurface.def("MovePoint", [](Geom_BSplineSurface &self, const Standard_Real U, const Standard_Real V, const gp_Pnt & P, const Standard_Integer UIndex1, const Standard_Integer UIndex2, const Standard_Integer VIndex1, const Standard_Integer VIndex2, Standard_Integer & UFirstIndex, Standard_Integer & ULastIndex, Standard_Integer & VFirstIndex, Standard_Integer & VLastIndex){ self.MovePoint(U, V, P, UIndex1, UIndex2, VIndex1, VIndex2, UFirstIndex, ULastIndex, VFirstIndex, VLastIndex); return std::tuple<Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &>(UFirstIndex, ULastIndex, VFirstIndex, VLastIndex); }, "Move a point with parameter U and V to P. given u,v as parameters) to reach a new position UIndex1, UIndex2, VIndex1, VIndex2: indicates the poles which can be moved if Problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("UIndex1"), py::arg("UIndex2"), py::arg("VIndex1"), py::arg("VIndex2"), py::arg("UFirstIndex"), py::arg("ULastIndex"), py::arg("VFirstIndex"), py::arg("VLastIndex"));
cls_Geom_BSplineSurface.def("IsUClosed", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsUClosed, "Returns true if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp.");
cls_Geom_BSplineSurface.def("IsVClosed", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsVClosed, "Returns true if the first control points column and the last last control points column are identical. The tolerance criterion is Resolution from package gp.");
cls_Geom_BSplineSurface.def("IsCNu", (Standard_Boolean (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::IsCNu, "Returns True if the order of continuity of the surface in the U direction is N. Raised if N < 0.", py::arg("N"));
cls_Geom_BSplineSurface.def("IsCNv", (Standard_Boolean (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::IsCNv, "Returns True if the order of continuity of the surface in the V direction is N. Raised if N < 0.", py::arg("N"));
cls_Geom_BSplineSurface.def("IsUPeriodic", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsUPeriodic, "Returns True if the surface is closed in the U direction and if the B-spline has been turned into a periodic surface using the function SetUPeriodic.");
cls_Geom_BSplineSurface.def("IsURational", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsURational, "Returns False if for each row of weights all the weights are identical. The tolerance criterion is resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|");
cls_Geom_BSplineSurface.def("IsVPeriodic", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsVPeriodic, "Returns True if the surface is closed in the V direction and if the B-spline has been turned into a periodic surface using the function SetVPeriodic.");
cls_Geom_BSplineSurface.def("IsVRational", (Standard_Boolean (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::IsVRational, "Returns False if for each column of weights all the weights are identical. The tolerance criterion is resolution from package gp. Examples : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|");
cls_Geom_BSplineSurface.def("Bounds", [](Geom_BSplineSurface &self, Standard_Real & U1, Standard_Real & U2, Standard_Real & V1, Standard_Real & V2){ self.Bounds(U1, U2, V1, V2); return std::tuple<Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &>(U1, U2, V1, V2); }, "Returns the parametric bounds of the surface. Warnings : These parametric values are the bounds of the array of knots UKnots and VKnots only if the first knots and the last knots have a multiplicity equal to UDegree + 1 or VDegree + 1", py::arg("U1"), py::arg("U2"), py::arg("V1"), py::arg("V2"));
cls_Geom_BSplineSurface.def("Continuity", (GeomAbs_Shape (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::Continuity, "Returns the continuity of the surface : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Surface, C2 : continuity of the second derivative all along the Surface, C3 : continuity of the third derivative all along the Surface, CN : the order of continuity is infinite. A B-spline surface is infinitely continuously differentiable for the couple of parameters U, V such thats U != UKnots(i) and V != VKnots(i). The continuity of the surface at a knot value depends on the multiplicity of this knot. Example : If the surface is C1 in the V direction and C2 in the U direction this function returns Shape = C1.");
cls_Geom_BSplineSurface.def("FirstUKnotIndex", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::FirstUKnotIndex, "Computes the Index of the UKnots which gives the first parametric value of the surface in the U direction. The UIso curve corresponding to this value is a boundary curve of the surface.");
cls_Geom_BSplineSurface.def("FirstVKnotIndex", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::FirstVKnotIndex, "Computes the Index of the VKnots which gives the first parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.");
cls_Geom_BSplineSurface.def("LastUKnotIndex", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::LastUKnotIndex, "Computes the Index of the UKnots which gives the last parametric value of the surface in the U direction. The UIso curve corresponding to this knot is a boundary curve of the surface.");
cls_Geom_BSplineSurface.def("LastVKnotIndex", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::LastVKnotIndex, "Computes the Index of the VKnots which gives the last parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.");
cls_Geom_BSplineSurface.def("NbUKnots", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::NbUKnots, "Returns the number of knots in the U direction.");
cls_Geom_BSplineSurface.def("NbUPoles", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::NbUPoles, "Returns number of poles in the U direction.");
cls_Geom_BSplineSurface.def("NbVKnots", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::NbVKnots, "Returns the number of knots in the V direction.");
cls_Geom_BSplineSurface.def("NbVPoles", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::NbVPoles, "Returns the number of poles in the V direction.");
cls_Geom_BSplineSurface.def("Pole", (const gp_Pnt & (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer) const) &Geom_BSplineSurface::Pole, "Returns the pole of range (UIndex, VIndex).", py::arg("UIndex"), py::arg("VIndex"));
cls_Geom_BSplineSurface.def("Poles", (void (Geom_BSplineSurface::*)(TColgp_Array2OfPnt &) const) &Geom_BSplineSurface::Poles, "Returns the poles of the B-spline surface.", py::arg("P"));
cls_Geom_BSplineSurface.def("Poles", (const TColgp_Array2OfPnt & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::Poles, "Returns the poles of the B-spline surface.");
cls_Geom_BSplineSurface.def("UDegree", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::UDegree, "Returns the degree of the normalized B-splines Ni,n in the U direction.");
cls_Geom_BSplineSurface.def("UKnot", (Standard_Real (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::UKnot, "Returns the Knot value of range UIndex. Raised if UIndex < 1 or UIndex > NbUKnots", py::arg("UIndex"));
cls_Geom_BSplineSurface.def("UKnotDistribution", (GeomAbs_BSplKnotDistribution (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::UKnotDistribution, "Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the U direction the B-spline surface can be : - Uniform if all the knots are of multiplicity 1, - QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1, - PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the U direction The tolerance criterion is Resolution from package gp.");
cls_Geom_BSplineSurface.def("UKnots", (void (Geom_BSplineSurface::*)(TColStd_Array1OfReal &) const) &Geom_BSplineSurface::UKnots, "Returns the knots in the U direction.", py::arg("Ku"));
cls_Geom_BSplineSurface.def("UKnots", (const TColStd_Array1OfReal & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::UKnots, "Returns the knots in the U direction.");
cls_Geom_BSplineSurface.def("UKnotSequence", (void (Geom_BSplineSurface::*)(TColStd_Array1OfReal &) const) &Geom_BSplineSurface::UKnotSequence, "Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}", py::arg("Ku"));
cls_Geom_BSplineSurface.def("UKnotSequence", (const TColStd_Array1OfReal & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::UKnotSequence, "Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}");
cls_Geom_BSplineSurface.def("UMultiplicity", (Standard_Integer (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::UMultiplicity, "Returns the multiplicity value of knot of range UIndex in the u direction. Raised if UIndex < 1 or UIndex > NbUKnots.", py::arg("UIndex"));
cls_Geom_BSplineSurface.def("UMultiplicities", (void (Geom_BSplineSurface::*)(TColStd_Array1OfInteger &) const) &Geom_BSplineSurface::UMultiplicities, "Returns the multiplicities of the knots in the U direction.", py::arg("Mu"));
cls_Geom_BSplineSurface.def("UMultiplicities", (const TColStd_Array1OfInteger & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::UMultiplicities, "Returns the multiplicities of the knots in the U direction.");
cls_Geom_BSplineSurface.def("VDegree", (Standard_Integer (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::VDegree, "Returns the degree of the normalized B-splines Ni,d in the V direction.");
cls_Geom_BSplineSurface.def("VKnot", (Standard_Real (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::VKnot, "Returns the Knot value of range VIndex. Raised if VIndex < 1 or VIndex > NbVKnots", py::arg("VIndex"));
cls_Geom_BSplineSurface.def("VKnotDistribution", (GeomAbs_BSplKnotDistribution (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::VKnotDistribution, "Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the V direction the B-spline surface can be : - Uniform if all the knots are of multiplicity 1, - QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1, - PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the V direction. The tolerance criterion is Resolution from package gp.");
cls_Geom_BSplineSurface.def("VKnots", (void (Geom_BSplineSurface::*)(TColStd_Array1OfReal &) const) &Geom_BSplineSurface::VKnots, "Returns the knots in the V direction.", py::arg("Kv"));
cls_Geom_BSplineSurface.def("VKnots", (const TColStd_Array1OfReal & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::VKnots, "Returns the knots in the V direction.");
cls_Geom_BSplineSurface.def("VKnotSequence", (void (Geom_BSplineSurface::*)(TColStd_Array1OfReal &) const) &Geom_BSplineSurface::VKnotSequence, "Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Kv = {k1, k1, k1, k2, k3, k3, k4, k4, k4}", py::arg("Kv"));
cls_Geom_BSplineSurface.def("VKnotSequence", (const TColStd_Array1OfReal & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::VKnotSequence, "Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}");
cls_Geom_BSplineSurface.def("VMultiplicity", (Standard_Integer (Geom_BSplineSurface::*)(const Standard_Integer) const) &Geom_BSplineSurface::VMultiplicity, "Returns the multiplicity value of knot of range VIndex in the v direction. Raised if VIndex < 1 or VIndex > NbVKnots", py::arg("VIndex"));
cls_Geom_BSplineSurface.def("VMultiplicities", (void (Geom_BSplineSurface::*)(TColStd_Array1OfInteger &) const) &Geom_BSplineSurface::VMultiplicities, "Returns the multiplicities of the knots in the V direction.", py::arg("Mv"));
cls_Geom_BSplineSurface.def("VMultiplicities", (const TColStd_Array1OfInteger & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::VMultiplicities, "Returns the multiplicities of the knots in the V direction.");
cls_Geom_BSplineSurface.def("Weight", (Standard_Real (Geom_BSplineSurface::*)(const Standard_Integer, const Standard_Integer) const) &Geom_BSplineSurface::Weight, "Returns the weight value of range UIndex, VIndex.", py::arg("UIndex"), py::arg("VIndex"));
cls_Geom_BSplineSurface.def("Weights", (void (Geom_BSplineSurface::*)(TColStd_Array2OfReal &) const) &Geom_BSplineSurface::Weights, "Returns the weights of the B-spline surface.", py::arg("W"));
cls_Geom_BSplineSurface.def("Weights", (const TColStd_Array2OfReal * (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::Weights, "Returns the weights of the B-spline surface. value and derivatives computation");
cls_Geom_BSplineSurface.def("D0", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &) const) &Geom_BSplineSurface::D0, "None", py::arg("U"), py::arg("V"), py::arg("P"));
cls_Geom_BSplineSurface.def("D1", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::D1, "Raised if the continuity of the surface is not C1.", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"));
cls_Geom_BSplineSurface.def("D2", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::D2, "Raised if the continuity of the surface is not C2.", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"));
cls_Geom_BSplineSurface.def("D3", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::D3, "Raised if the continuity of the surface is not C3.", py::arg("U"), py::arg("V"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"), py::arg("D3U"), py::arg("D3V"), py::arg("D3UUV"), py::arg("D3UVV"));
cls_Geom_BSplineSurface.def("DN", (gp_Vec (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer) const) &Geom_BSplineSurface::DN, "Nu is the order of derivation in the U parametric direction and Nv is the order of derivation in the V parametric direction.", py::arg("U"), py::arg("V"), py::arg("Nu"), py::arg("Nv"));
cls_Geom_BSplineSurface.def("LocalD0", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, gp_Pnt &) const) &Geom_BSplineSurface::LocalD0, "Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"), py::arg("P"));
cls_Geom_BSplineSurface.def("LocalD1", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::LocalD1, "Raised if the local continuity of the surface is not C1 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"), py::arg("P"), py::arg("D1U"), py::arg("D1V"));
cls_Geom_BSplineSurface.def("LocalD2", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::LocalD2, "Raised if the local continuity of the surface is not C2 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"));
cls_Geom_BSplineSurface.def("LocalD3", (void (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, gp_Pnt &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &, gp_Vec &) const) &Geom_BSplineSurface::LocalD3, "Raised if the local continuity of the surface is not C3 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"), py::arg("P"), py::arg("D1U"), py::arg("D1V"), py::arg("D2U"), py::arg("D2V"), py::arg("D2UV"), py::arg("D3U"), py::arg("D3V"), py::arg("D3UUV"), py::arg("D3UVV"));
cls_Geom_BSplineSurface.def("LocalDN", (gp_Vec (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer) const) &Geom_BSplineSurface::LocalDN, "Raised if the local continuity of the surface is not CNu between the knots FromUK1, ToUK2 and CNv between the knots FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"), py::arg("Nu"), py::arg("Nv"));
cls_Geom_BSplineSurface.def("LocalValue", (gp_Pnt (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Real, const Standard_Integer, const Standard_Integer, const Standard_Integer, const Standard_Integer) const) &Geom_BSplineSurface::LocalValue, "Computes the point of parameter U, V on the BSpline surface patch defines between the knots UK1 UK2, VK1, VK2. U can be out of the bounds [Knot UK1, Knot UK2] and V can be outof the bounds [Knot VK1, Knot VK2] but for the computation we only use the definition of the surface between these knot values. Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2.", py::arg("U"), py::arg("V"), py::arg("FromUK1"), py::arg("ToUK2"), py::arg("FromVK1"), py::arg("ToVK2"));
cls_Geom_BSplineSurface.def("UIso", (opencascade::handle<Geom_Curve> (Geom_BSplineSurface::*)(const Standard_Real) const) &Geom_BSplineSurface::UIso, "Computes the U isoparametric curve. A B-spline curve is returned.", py::arg("U"));
cls_Geom_BSplineSurface.def("VIso", (opencascade::handle<Geom_Curve> (Geom_BSplineSurface::*)(const Standard_Real) const) &Geom_BSplineSurface::VIso, "Computes the V isoparametric curve. A B-spline curve is returned.", py::arg("V"));
cls_Geom_BSplineSurface.def("UIso", (opencascade::handle<Geom_Curve> (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Boolean) const) &Geom_BSplineSurface::UIso, "Computes the U isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned.", py::arg("U"), py::arg("CheckRational"));
cls_Geom_BSplineSurface.def("VIso", (opencascade::handle<Geom_Curve> (Geom_BSplineSurface::*)(const Standard_Real, const Standard_Boolean) const) &Geom_BSplineSurface::VIso, "Computes the V isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. transformations", py::arg("V"), py::arg("CheckRational"));
cls_Geom_BSplineSurface.def("Transform", (void (Geom_BSplineSurface::*)(const gp_Trsf &)) &Geom_BSplineSurface::Transform, "Applies the transformation T to this BSpline surface.", py::arg("T"));
cls_Geom_BSplineSurface.def_static("MaxDegree_", (Standard_Integer (*)()) &Geom_BSplineSurface::MaxDegree, "Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v directions.");
cls_Geom_BSplineSurface.def("Resolution", [](Geom_BSplineSurface &self, const Standard_Real Tolerance3D, Standard_Real & UTolerance, Standard_Real & VTolerance){ self.Resolution(Tolerance3D, UTolerance, VTolerance); return std::tuple<Standard_Real &, Standard_Real &>(UTolerance, VTolerance); }, "Computes two tolerance values for this BSpline surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are: - UTolerance in the u parametric direction, and - VTolerance in the v parametric direction. If f(u,v) is the equation of this BSpline surface, UTolerance and VTolerance guarantee that : | u1 - u0 | < UTolerance and | v1 - v0 | < VTolerance ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D", py::arg("Tolerance3D"), py::arg("UTolerance"), py::arg("VTolerance"));
cls_Geom_BSplineSurface.def("Copy", (opencascade::handle<Geom_Geometry> (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::Copy, "Creates a new object which is a copy of this BSpline surface.");
cls_Geom_BSplineSurface.def_static("get_type_name_", (const char * (*)()) &Geom_BSplineSurface::get_type_name, "None");
cls_Geom_BSplineSurface.def_static("get_type_descriptor_", (const opencascade::handle<Standard_Type> & (*)()) &Geom_BSplineSurface::get_type_descriptor, "None");
cls_Geom_BSplineSurface.def("DynamicType", (const opencascade::handle<Standard_Type> & (Geom_BSplineSurface::*)() const) &Geom_BSplineSurface::DynamicType, "None");

// Enums

}